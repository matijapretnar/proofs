%%%% Non-stuckness

non-stuck : comp -> type.

non-stuck/val  : non-stuck (val _).
non-stuck/op   : non-stuck (op _ _ _ _).
non-stuck/step : non-stuck C <- step C _.

%%%% Auxiliary progress theorem for let-statements

progress-let : {C2} non-stuck C1 -> non-stuck (let C1 C2) -> type.
%mode progress-let +C2 +NS1 -NS.

- : progress-let _
     non-stuck/val
     (non-stuck/step step/let-val).

- : progress-let _
     non-stuck/op
     (non-stuck/step step/let-op).

- : progress-let _
     (non-stuck/step S1)
     (non-stuck/step (step/let-step S1)).

%worlds () (progress-let _ _ _).
%total {C2 NS1} (progress-let C2 NS1 _).

% The main progress theorem is mutually recursive with an auxiliary
% progress theorem for the handling construct.

progress-handle : eof E (A ==> B) -> cof C A -> non-stuck (handle E C) -> type.
%mode progress-handle +EO +CO -NS.

progress : cof C _ -> non-stuck C -> type.
%mode progress +CO -NS.

% Progress for the handling construct

% Effectiveness lemmas for looking up cases in a handler

can-handler-get-val : {H} eof (hnd H) (A ==> B) ->  handler-get-val H K -> type.
%mode can-handler-get-val +H +HO -K.

- : can-handler-get-val (handler/val _) _ handler-get-val/val.
- : can-handler-get-val (handler/op _ _ _ H) (eof/hnd-op _ _ _ _ EO) (handler-get-val/op K)
     <- can-handler-get-val H EO K.

%worlds () (can-handler-get-val _ _ _).
%total {H} (can-handler-get-val H _ _).


- : progress-handle _ CO (non-stuck/step (step/handle-step S))
     <- progress CO (non-stuck/step S).

- : {K} progress-handle _ CO (non-stuck/step (step/handle-val K))
     <- progress CO non-stuck/val.

- : progress (cof/val _) non-stuck/val.

- : progress (cof/op _ _ _ _ _) non-stuck/op.

- : progress (cof/let C1 _) NS
     <- progress C1 NS1
     <- progress-let _ NS1 NS.

- : progress (cof/letr _ _) (non-stuck/step step/letr).

- : progress (cof/zro? eof/zro) (non-stuck/step step/zro?-zro).

- : progress (cof/zro? (eof/suc _)) (non-stuck/step step/zro?-suc).

- : progress (cof/cond eof/tru _ _) (non-stuck/step step/cond-tru).

- : progress (cof/cond eof/fls _ _) (non-stuck/step step/cond-fls).

- : progress (cof/app _ _) (non-stuck/step step/app).

- : progress (cof/handle H C) NS
     <- progress-handle H C NS.

%worlds () (progress _ _) (progress-handle _ _ _).
%total {EO CO CO'} (progress CO _) (progress-handle EO CO' _).

%%%% Preservation theorem

preservation : cof C A -> step C C' -> cof C' A -> type.
%mode preservation +CO +S -CO'.

- : preservation (cof/let (cof/val E1) C2) step/let-val (C2 _ E1).

- : preservation (cof/let (cof/op Ei O Ep K D) C2) step/let-op (cof/op Ei O Ep ([_] [y] (cof/let (K _ y) C2)) D).

- : preservation (cof/let C1 C2) (step/let-step S1) (cof/let C1' C2)
     <- preservation C1 S1 C1'.

- : preservation (cof/letr C1 C2) step/letr (C2 _ (eof/fun ([_] [y] (cof/letr C1 ([_] [f] C1 _ _ f y))))).

- : preservation (cof/zro? eof/zro) step/zro?-zro (cof/val eof/tru).

- : preservation (cof/zro? (eof/suc _)) step/zro?-suc (cof/val eof/fls).

- : preservation (cof/cond eof/tru C1 _) step/cond-tru C1.

- : preservation (cof/cond eof/fls _ C2) step/cond-fls C2.

- : preservation (cof/app (eof/fun E1) E2) step/app (E1 _ E2).

%worlds (vars) (preservation _ _ _).
%total {CO S} (preservation CO S _).
