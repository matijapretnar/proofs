%%%%{ Progress theorem }%%%%%

progress-let : {C2} non-stuck C1 -> non-stuck (let C1 C2) -> type.
%mode progress-let +C2 +NS1 -NS.

- : progress-let _
     non-stuck/val
     (non-stuck/step step/let-val).

- : progress-let _
     (non-stuck/step S1)
     (non-stuck/step (step/let-step S1)).

%worlds () (progress-let _ _ _).
%total {} (progress-let _ _ _).


progress : cof C A -> non-stuck C -> type.
%mode progress +CO -NS.

- : progress (cof/val E) non-stuck/val.

- : progress (cof/zro? eof/zro) (non-stuck/step step/zro?-zro).

- : progress (cof/zro? (eof/suc _)) (non-stuck/step step/zro?-suc).

- : progress (cof/cond eof/tru C1 C2) (non-stuck/step step/cond-tru).

- : progress (cof/cond eof/fls C1 C2) (non-stuck/step step/cond-fls).

- : progress (cof/app E1 E2) (non-stuck/step step/app).

- : progress (cof/let C1 C2) NS
     <- progress C1 NS1
     <- progress-let _ NS1 NS.

%worlds () (progress _ _).
%total {CO} (progress CO _).



%%%%{ Preservation theorem }%%%%%

preservation : cof C A -> step C C' -> cof C' A -> type.
%mode preservation +CO +S -CO'.

- : preservation (cof/zro? eof/zro) step/zro?-zro (cof/val eof/tru).

- : preservation (cof/zro? (eof/suc _)) step/zro?-suc (cof/val eof/fls).

- : preservation (cof/cond eof/tru C1 C2) step/cond-tru C1.

- : preservation (cof/cond eof/fls C1 C2) step/cond-fls C2.

- : preservation (cof/app (eof/fun E1) E2) (step/app) (E1 _ E2).

- : preservation (cof/let (cof/val E1) C2) (step/let-val) (C2 _ E1).

- : preservation (cof/let C1 C2) (step/let-step S1) (cof/let C1' C2)
     <- preservation C1 S1 C1'.


%worlds () (preservation _ _ _).
%total {CO S} (preservation CO S _).
