%%%%{ Non-stuckness }%%%%%

non-stuck : comp -> type.

non-stuck/val  : non-stuck (val _).
non-stuck/op   : non-stuck (op _ _ _ _).
non-stuck/step : non-stuck C
		  <- step C _.


%%%%{ Progress theorem }%%%%%

progress-let : {C2} non-stuck C1 -> non-stuck (let C1 C2) -> type.
%mode progress-let +C2 +NS1 -NS.

- : progress-let _
     non-stuck/val
     (non-stuck/step step/let-val).

- : progress-let _
     non-stuck/op
     (non-stuck/step step/let-op).

- : progress-let _
     (non-stuck/step S1)
     (non-stuck/step (step/let-step S1)).

%worlds (vars) (progress-let _ _ _).
%total {NS1} (progress-let _ NS1 _).



progress-zro? : eof E nat -> non-stuck (zro? E) -> type.
%mode progress-zro? +E -NS.

- : progress-zro? eof/zro (non-stuck/step step/zro?-zro).
- : progress-zro? (eof/suc _) (non-stuck/step step/zro?-suc).
- : progress-zro? (eof/sub E _) NS
     <- progress-zro? E NS.

%worlds (vars) (progress-zro? _ _).
%total {E} (progress-zro? E _).



progress-cond : {C1} {C2} eof E bool -> non-stuck (cond E C1 C2) -> type.
%mode progress-cond +C1 +C2 +E -NS.

- : progress-cond _ _ eof/tru (non-stuck/step step/cond-tru).
- : progress-cond _ _ eof/fls (non-stuck/step step/cond-fls).
- : progress-cond _ _ (eof/sub E _) NS
     <- progress-cond _ _ E NS.

%worlds (vars) (progress-cond _ _ _ _).
%total {E} (progress-cond _ _ E _).



progress-absd : eof E empty -> non-stuck (absd E) -> type.
%mode progress-absd +E -NS.

- : progress-absd (eof/sub E _) NS
     <- progress-absd E NS.

%worlds (vars) (progress-absd _ _).
%total {E} (progress-absd E _).



progress-app : eof E1 (A --> B) -> {E2} non-stuck (app E1 E2) -> type.
%mode progress-app +E1 +E2 -NS.

- : progress-app (eof/fun _) _ (non-stuck/step step/app).
- : progress-app (eof/sub E1 _) E2 NS
     <- progress-app E1 E2 NS.

%worlds (vars) (progress-app _ _ _).
%total {E1} (progress-app E1 _ _).

progress : cof C _ -> non-stuck C -> type.
%mode progress +CO -NS.

- : progress (cof/val _) non-stuck/val.

- : progress (cof/op _ _ _ _ _) non-stuck/op.

- : progress (cof/let C1 _) NS
     <- progress C1 NS1
     <- progress-let _ NS1 NS.

- : progress (cof/letr _ _) (non-stuck/step step/letr).

- : progress (cof/zro? E) NS
     <- progress-zro? E NS.

- : progress (cof/cond E _ _) NS
     <- progress-cond _ _ E NS.

- : progress (cof/absd E) NS
     <- progress-absd E NS.

- : progress (cof/app E1 E2) NS
     <- progress-app E1 _ NS.

- : progress (cof/sub C CC') NS
     <- progress C NS.

%worlds (vars) (progress _ _).
%total {C} (progress C _).



%%%%{ Preservation theorem }%%%%%

preservation : cof C A -> step C C' -> cof C' A -> type.
%mode preservation +CO +S -CO'.

- : preservation (cof/let (cof/val E1) C2) step/let-val (C2 _ E1).

- : preservation (cof/let (cof/op Ei O Ep K D) C2) step/let-op (cof/op Ei O Ep ([_] [y] (cof/let (K _ y) C2)) D).

- : preservation (cof/let C1 C2) (step/let-step S1) (cof/let C1' C2)
     <- preservation C1 S1 C1'.

- : preservation (cof/letr C1 C2) step/letr (C2 _ (eof/fun ([_] [y] (cof/letr C1 ([_] [f] C1 _ _ f y))))).

- : preservation (cof/zro? eof/zro) step/zro?-zro (cof/val eof/tru).

- : preservation (cof/zro? (eof/suc _)) step/zro?-suc (cof/val eof/fls).

- : preservation (cof/cond eof/tru C1 _) step/cond-tru C1.

- : preservation (cof/cond eof/fls _ C2) step/cond-fls C2.

- : preservation (cof/app (eof/fun E1) E2) step/app (E1 _ E2).


%worlds (vars) (preservation _ _ _).
%total {CO S} (preservation CO S _).
