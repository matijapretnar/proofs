Specification "exp2ml".
Import "common".

Close exp/sig, exp/comp_ty, exp/coer_ty, exp/val_ty.
Close ml/sig, ml/ty, ml/term, ml/coer_ty, ml/hand, ml/coer, op.
Close dirt.

Set subgoals off.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contexts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define e2m/ctx : exp/sig -> ml/sig -> olist -> olist -> prop by

  e2m/ctx Sig_t Sig_m nil nil
    := {e2m/sig Sig_t Sig_m};

  nabla x x', e2m/ctx Sig_e Sig_m
    (e2m/val Sig_e x A x' :: Ctx_e2m)
    (ml/of_term Sig_m x' A' :: Ctx_m)
    := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ {Ctx_e2m |- e2m/val_ty A A'};

   nabla t t', e2m/ctx Sig_t Sig_m
     (e2m/val_ty t t' :: Ctx_t2m)
     (ml/wf_ty t' :: Ctx_m)
     := e2m/ctx Sig_t Sig_m Ctx_t2m Ctx_m;

   nabla d, e2m/ctx Sig_t Sig_m
     (e2m/full_dirt d :: Ctx_t2m)
     (Ctx_m)
     := e2m/ctx Sig_t Sig_m Ctx_t2m Ctx_m
.
Theorem ctx_m_member: 
  forall  Sig_t Sig_m Ctx_e2m Ctx_m F,
    e2m/ctx Sig_t Sig_m Ctx_e2m Ctx_m ->
    member F Ctx_m ->
    (exists X' A',
       fresh X' /\ (F = ml/of_term Sig_m X' A'))
    \/
    (exists T',
       fresh T' /\ (F = ml/wf_ty T')).
% PROOF
induction on 1. intros. case H1 (keep).
  case H2.
  case H2. 
    search.
    apply IH to H3 H5. search.
  case H2.
    search.
    apply IH to H3 H4. search.
  apply IH to H3 H2. search.
% QED

Theorem ctx_t2m_member: 
  forall Sig_t Sig_m Ctx_e2m Ctx_m F,
    e2m/ctx Sig_t Sig_m Ctx_e2m Ctx_m ->
    member F Ctx_e2m ->
      (exists X A X' A',
         fresh X /\ fresh X' /\ (F = e2m/val Sig_t X A X') /\ {Ctx_e2m |- e2m/val_ty A A'})
      \/
      (exists T T',
         fresh T /\ fresh T' /\ (F = e2m/val_ty T T') /\ member (ml/wf_ty T') Ctx_m)
      \/
      (exists D,
         fresh D /\ (F = e2m/full_dirt D)).
% PROOF
induction on 1. intros. case H1 (keep).
  case H2.
  case H2.
    search.
    apply IH to H3 H5. case H6.
      left. left. exists (X n2 n1), A1, (X' n2), A'1. search.
      left. right. search.
      right. search.
  case H2.
    search.
    apply IH to H3 H4. case H5. 
      search. 
      search.
      search.
  case H2.
    search.
    apply IH to H3 H4. case H5. 
      search. 
      search.
      search.
% QED
      

%   nabla t, e2m/ctx Sig_t Sig_e
%     (exp/skel_val_ty t Te :: Ctx_t)
%     (exp/skel_val_ty t Te :: Ctx_t2e)
%     Ctx_e
%     := e2m/ctx Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e;
%   nabla w, e2m/ctx Sig_t Sig_e
%     (exp/of_coer w (exp/val_ty_coer_ty At1 At2) :: Ctx_t)
%     Ctx_t2e
%     Ctx_e
%     := e2m/ctx Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e /\ exists S, {Ctx_t |- exp/skel_val_ty At1 S} /\ {Ctx_t |- exp/skel_val_ty At2 S};
%   nabla w, e2m/ctx Sig_t Sig_e
%     (exp/of_coer w (exp/comp_ty_coer_ty At1 At2) :: Ctx_t)
%     Ctx_t2e
%     Ctx_e
%     := e2m/ctx Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e /\ exists S, {Ctx_t |- exp/skel_comp_ty At1 S} /\ {Ctx_t |- exp/skel_comp_ty At2 S};
%   nabla w, e2m/ctx Sig_t Sig_e
%     (exp/of_coer w (exp/dirt_coer_ty D1 D2) :: Ctx_t)
%     Ctx_t2e
%     Ctx_e
%     := e2m/ctx Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e.

Theorem from_impure :
  (
    forall A D Y D' A1 A2,
      {from_impure/val A D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/val_ty (A D') A1} ->
      {e2m/val_ty (A D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall C D Y D' A1 A2,
      {from_impure/comp C D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/comp_ty (C D') A1} ->
      {e2m/comp_ty (C D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall A D Y D' A1 A2,
      {to_impure/val A D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/val_ty (A D') A1} ->
      {e2m/val_ty (A D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ) /\
  (
    forall C D Y D' A1 A2,
      {to_impure/comp C D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/comp_ty (C D') A1} ->
      {e2m/comp_ty (C D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ).
skip.
% induction on 1 1 1 1. split.
% % from_impure/val
% intros. case H1.
%   % unit_ty
%   case H3. case H4. search.
%   % fun_ty
%   case H3. case H4.
%   apply IH2 to H5 H2 H7 H9.
%   apply IH1 to H6 H2 H8 H10.
%   search.
% % from_impure/comp
% intros. case H1.
%   % empty
%   case H3. % see what the full dirt D' is
%     % trivial case
%     case H2.
%     % interesting case
%     case H4.
%       % interesting case
%       apply IH to H5 H2 H7 H8. search.
%       case H8.
%   % non-empty case
%   case H3.
%     case H2.
%     case H4.
%       case H6.
%       apply IH to H5 H2 H8 H10. search.
% % to_impure/val
% skip.
% % to_impure/comp
% skip.
  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Strenghtening Lemma
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem ml/ty_strengthen :
  (
    forall Sig_t Sig_ml Ctx_t2m Ctx_m A T, 
         e2m/ctx Sig_t Sig_ml Ctx_t2m Ctx_m
      -> {Ctx_t2m, e2m/val Sig_t n1 A n2 |- e2m/val_ty A T} 
      -> {Ctx_t2m |- e2m/val_ty A T}
  ) /\ (
    forall Sig_t Sig_ml Ctx_t2m Ctx_m A C T, 
         e2m/ctx Sig_t Sig_ml Ctx_t2m Ctx_m 
      -> {Ctx_t2m, e2m/val Sig_t n1 A n2 |- e2m/comp_ty C T} 
      -> {Ctx_t2m |- e2m/comp_ty C T}
  ).
skip.
% induction on 2 2. split.

Split ml/ty_strengthen as ml/strengthen_val_ty, ml/strengthen_comp_ty.

Theorem member_meaning:
  forall Ctx F,
    member F Ctx -> {Ctx |- F}.
% PROOF
induction on 1. intros. case H1 (keep).
  search.
  apply IH to H2. search.
% QED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wf_ty preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_wf_ty :
  (forall A A' Sig_t Sig_m Ctx_e2m Ctx_m, 
     e2m/ctx Sig_t Sig_m Ctx_e2m Ctx_m -> {Ctx_e2m |- e2m/val_ty A A'} -> {Ctx_m |- ml/wf_ty A'}) /\
  (forall C C' Sig_t Sig_m Ctx_e2m Ctx_m, 
     e2m/ctx Sig_t Sig_m Ctx_e2m Ctx_m -> {Ctx_e2m |- e2m/comp_ty C C'} -> {Ctx_m |- ml/wf_ty C'}).
induction on 2 2. split.

  intros. case H2 (keep).
    search.
    apply IH to _ H3. apply IH1 to _ H4. search.
    apply IH to _ H3. apply IH1 to _ H4. search.
    apply IH to _ H3. apply IH to _ H5. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. apply IH to _ H4. apply IH to _ H5. search.
    apply IH1 to _ H3. apply IH1 to _ H4. apply IH to _ H5. search.
    apply IH to _ H3. search.
    % backchain
    apply ctx_t2m_member to H1 H4. case H5.
      case H3.
      case H3. search.
      case H3.

  intros. case H2 (keep).
    apply IH to _ H3. search.
    apply IH to _ H4. search.
     % backchain
    apply ctx_t2m_member to H1 H4. case H5.
      case H3.
      case H3.
      case H3.
% QED?

Split e2m/preserve_wf_ty as e2m/preserve_wf_val_ty, e2m/preserve_wf_comp_ty.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% of_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_ty_coer:
  (forall Y A B Y',
    {e2m/coer Y (exp/val_ty_coer_ty A B) Y'} ->
      (exists A' B',
         {e2m/val_ty A A'} /\ 
         {e2m/val_ty B B'} /\   
         {ml/of_coer Y' (ml/ty_coer_ty A' B')}))
  /\
  (forall Y A B Y',
    {e2m/coer Y (exp/comp_ty_coer_ty A B) Y'} ->
      (exists A' B',
         {e2m/comp_ty A A'} /\ 
         {e2m/comp_ty B B'} /\   
         {ml/of_coer Y' (ml/ty_coer_ty A' B')})).
% PROOF
induction on 1 1. split.

  intros. case H1 (keep).
    search.
    apply IH to H2. apply IH1 to H3.
      exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1). split.
        search.
        search.
        case H6 (keep). case H9 (keep). case H10. case H12. search.
    apply IH1 to H2. apply IH1 to H3. 
      exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1). split. 
        case H4. 
          case H5. 
            search.
            case H11. 
          case H10.
        case H4. 
          case H5. 
            search.
            case H11. 
          case H10.
        case H6 (keep). case H9 (keep). case H10. case H12. search.
    apply IH1 to H2. apply IH to H5. 
      case H6. case H4. case H7. case H3.
        exists (ml/hand_ty A'3 A'1), (ml/hand_ty A'2 B'1). split.
          search.
          search.
          case H8 (keep). case H11 (keep). case H16. case H18. case H20. case H21. search.
    apply IH1 to H2. apply IH1 to H4.
        
        

...
% QED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main Theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/of_val :
 (forall Sig_t Sig_ml V_t V_ml A_t Ctx_t2m Ctx_m,
        e2m/ctx Sig_t Sig_ml Ctx_t2m Ctx_m
     -> {Ctx_t2m |- e2m/val Sig_t V_t A_t V_ml}
     -> exists T, {Ctx_t2m |- e2m/val_ty A_t (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml V_ml T})
 /\
 (forall Sig_t Sig_ml C_t C_ml D_t Ctx_t2m Ctx_m,
        e2m/ctx Sig_t Sig_ml Ctx_t2m Ctx_m
     -> {Ctx_t2m |- e2m/comp Sig_t C_t D_t C_ml}
     -> exists T, {Ctx_t2m |- e2m/comp_ty D_t (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml C_ml T})
 .
induction on 2 2. split.
% VALUES
intros.
case H2 (keep).
  % UNIT
  search.
  % FUN
  apply IH1 to _ H4.
  exists (ml/fun_ty Aml T).
  split.
    apply ml/strengthen_comp_ty to _ H5. search.
    apply e2m/preserve_wf_val_ty to _ H3. 
      apply ml/strengthen_comp_ty to _ H5.
      apply e2m/preserve_wf_comp_ty to _ H8.
      search.
  % HAND
  case H3 (keep).  apply IH1 to _ H5. skip.
  skip.
  skip.
  % LAM_SKEL
  apply IH to _ H3. exists T. search.
  % APP_SKEL
  apply IH to _ H3. exists T. split.
    case H4. 
      inst H6 with n1 = S. search.
      skip. % backchain
    search.
  % LAM_TY
  skip. % TODO: handle exp/skel_val_ty n1 S in context
  % APP_TY 
  apply IH to _ H3. case H6. exists (A' Am1). split.
    inst H8 with n1 = At1, n2 = Am1. cut H9 with H4. search.
    apply e2m/preserve_wf_val_ty to _ H4. case H7.
      case H10. inst H12 with n1 = Am1. cut H13 with H9. search.
    skip. % backchain
    skip. % backchain
    skip. % backchain
  % LAM_DIRT
  apply IH to _ H3. exists T. split.
    search.
    search.
  % APP_DIRT
  apply IH to _ H4.
  skip.
  % LAM_COER VAL
  
  ...

exists (ml/fun_ty A1' 
    ...
  ...
% SKELETON LAMBDA
apply IH to _ H3.
exists T.
split.
search.
search.
% SKELETON APPLY
apply IH to _ H3.
exists T.
split..
case H4.
inst H6 with n1 = S.
search.
%
