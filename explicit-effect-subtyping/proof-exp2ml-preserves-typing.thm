Specification "exp2ml".
Import "common".
Import "proof-exp2ml-lemmas".

Set subgoals off.

Theorem lemma_26:
  forall Sig_e Sig_m Ctx_e2m Ctx_m A B,
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    {Ctx_m |- ml/wf_coer_ty (ml/ty_coer_ty A B)} ->
    {Ctx_m |- ml/wf_ty A} /\ {Ctx_m |- ml/wf_ty B}.
% PROOF
induction on 2. intros. case H2 (keep).
  search.
  apply ctx_m_member to _ H4. case H5.
    case H3.
    case H3.
    case H3.
% QED

Theorem lemma_27:
  forall Sig_e Sig_m Ctx_e2m Ctx_m Y A B,
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A B)} ->
    {Ctx_m |- ml/wf_ty A} /\ {Ctx_m |- ml/wf_ty B}.
% PROOF
induction on 2. intros. case H2 (keep).
  apply lemma_26 to _ H3. search.
  apply ctx_m_member to _ H4. case H5.
    case H3.
    case H3.
    case H3. search.
% QED

Theorem e2m/from_impure :
  (
    forall Sig_e Sig_m Ctx_e2m Ctx_m A D Y A1 S,
      e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
      {Ctx_e2m |- from_impure/val A D Y} ->
      nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/val_ty (A d) S A1} ->
      exists A2, {Ctx_e2m |- e2m/val_ty (A D) S A2} /\
      {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall Sig_e Sig_m Ctx_e2m Ctx_m C D Y A1 S,
      e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
      {Ctx_e2m |- from_impure/comp C D Y} ->
      nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/comp_ty (C d) S A1} ->
      exists A2, {Ctx_e2m |- e2m/comp_ty (C D) S A2} /\
      {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall Sig_e Sig_m Ctx_e2m Ctx_m A D Y A1 S,
      e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
      {Ctx_e2m |- to_impure/val A D Y} ->
      nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/val_ty (A d) S A1} ->
      exists A2, {Ctx_e2m |- e2m/val_ty (A D) S A2} /\
      {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ) /\
  (
    forall Sig_e Sig_m Ctx_e2m Ctx_m C D Y A1 S,
      e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
      {Ctx_e2m |- to_impure/comp C D Y} ->
      nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/comp_ty (C d) S A1} ->
      exists A2, {Ctx_e2m |- e2m/comp_ty (C D) S A2} /\
      {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ).
induction on 2 2 2 2. split.
% from_impure/val
intros Hctx. case H2.
    % unit_ty
    case H1.
      % interesting case
      search.
      % backchain case
      apply e2m/from_impure_val_member to _ _ _.
    % fun_ty
    case H1.
      % interesting case
      apply IH2 to _ H5 with A = A2, D = D, Y = Ya, A1 = A', S = S1.
      apply H7 to H3.
      apply IH1 to _ H6 with Y = Yc, A1 = C', S = S2.
      apply H10 to H4.
      apply e2m/preserve_wf_val_ty to _ H3.
      apply e2m/preserve_wf_val_ty to _ H8.
      apply e2m/preserve_wf_comp_ty to _ H4.
      apply e2m/preserve_wf_comp_ty to _ H11.
      search.
      % backchain case
      apply e2m/from_impure_val_member to _ _ _.
    % hand_ty
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % all_skel
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % all_ty
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % all_dirt
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % qual_ty ty
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % qual_ty comp
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % qual_ty dirt
    case H1.
      apply e2m/from_impure_val_member to _ _ _.
    % backchain 
    case H1.
      apply ctx_e2m_member to _ H4. case H5.
        case H3.
        case H3. case H6.
        case H3.
        case H3.
        case H3.
      apply ctx_e2m_member to _ H4. case H7.
        case H3.
        case H3. case H8.
        case H3.
        case H3.
        case H3.
      apply e2m/from_impure_val_member to _ _ _.

% from_impure/comp
intros Hctx. case H2.
  % bang empty.
  case H1.
    apply e2m/from_impure_comp_member to _ _ _.
  % bang full dirt
  case H1.
    % interesting case
    apply IH to _ H5 with A1 = A', S = S. apply H6 to _. 
      apply lemma_27 to _ _. search.
    apply IH to _ H5 with A1 = A', S = S. apply H7 to _. 
      apply lemma_27 to _ _. search.
    % backchain case
    apply e2m/from_impure_comp_member to _ _ _.
  % backchain case
  apply e2m/comp_ty_member to _ H3 H4.
  
% to_impure/val
intros Hctx. case H2.
    % unit_ty
    case H1.
      % interesting case
      search.
      % backchain case
      apply e2m/to_impure_val_member to _ _ _.
    % fun_ty
    case H1.
      % interesting case
      apply IH to _ H5 with A = A2, D = D, Y = Ya, A1 = A', S = S1.
      apply H7 to H3.
      apply IH3 to _ H6 with Y = Yc, A1 = C', S = S2.
      apply H10 to H4.
      apply e2m/preserve_wf_val_ty to _ H3.
      apply e2m/preserve_wf_val_ty to _ H8.
      apply e2m/preserve_wf_comp_ty to _ H4.
      apply e2m/preserve_wf_comp_ty to _ H11.
      search.
      % backchain case
      apply e2m/to_impure_val_member to _ _ _.
    % hand_ty
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % all_skel
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % all_ty
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % all_dirt
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % qual_ty ty
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % qual_ty comp
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % qual_ty dirt
    case H1.
      apply e2m/to_impure_val_member to _ _ _.
    % backchain 
    case H1.
      apply ctx_e2m_member to _ H4. case H5.
        case H3.
        case H3. case H6.
        case H3.
        case H3.
        case H3.
      apply ctx_e2m_member to _ H4. case H7.
        case H3.
        case H3. case H8.
        case H3.
        case H3.
        case H3.
      apply e2m/to_impure_val_member to _ _ _.

% to_impure/comp
intros Hctx. case H2.
  % bang empty
  case H1.
    apply e2m/to_impure_comp_member to _ _ _.
  % bang full dirt
  case H1.
    apply IH2 to _ H5 with A1 = A', S = S. apply H6 to _.
      apply lemma_27 to _ _. search.
    apply IH2 to _ H5 with A1 = A', S = S. apply H7 to _.
      apply lemma_27 to _ _. search.
    apply e2m/to_impure_comp_member to _ _ _.
    apply e2m/comp_ty_member to _ H3 H4. 
% QED

Split e2m/from_impure as e2m/from_impure_val, e2m/from_impure_comp, e2m/to_impure_val, e2m/to_impure_comp.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% dirt_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_dirt_coer:
  forall D1 D2 Y1' Y2' A1 A2 A1' A2' S,
    {e2m/dirt_coer D1 D2 Y1' Y2'} ->
    {ml/of_coer Y1' (ml/ty_coer_ty A1' A2')} ->
    {e2m/val_ty A1 S A1'} ->
    {e2m/val_ty A2 S A2'} ->
    (exists A3' A4',
       {ml/of_coer Y2' (ml/ty_coer_ty A3' A4')} /\
       {e2m/comp_ty (exp/bang A1 D1) S A3'} /\ 
       {e2m/comp_ty (exp/bang A2 D2) S A4'}).
% PROOF
intros. case H1 (keep).
  exists (ml/comp_ty A1'), (ml/comp_ty A2'). case H2 (keep). case H7. search.
  exists A1', (ml/comp_ty A2'). case H2 (keep). case H6. search.
  exists A1', A2'. search. 
% QED
   
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% of_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem lemma_28:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m A S A',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- e2m/comp_ty (exp/bang A empty) S A'} ->
    {Ctx_e2m |- e2m/val_ty A S A'}.
%PROOF
intros. case H2.
  search.
  apply e2m/empty_dirt_is_not_full to _ _.
  apply e2m/comp_ty_member to _ _ _.
%QED

Theorem e2m/preserve_ty_coer:
  (forall Sig_e Sig_ml Ctx_e2m Ctx_m Y A B Y',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->  
    {Ctx_e2m |- e2m/coer Y (exp/val_ty_coer_ty A B) Y'} ->
      (exists A' B' S,
         {Ctx_e2m |- e2m/val_ty A S A'} /\ 
         {Ctx_e2m |- e2m/val_ty B S B'} /\   
         {Ctx_m |- ml/of_coer Y' (ml/ty_coer_ty A' B')}))
  /\
  (forall Sig_e Sig_ml Ctx_e2m Ctx_m Y A B Y',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- e2m/coer Y (exp/comp_ty_coer_ty A B) Y'} ->
      (exists A' B' S,
         {Ctx_e2m |- e2m/comp_ty A S A'} /\ 
         {Ctx_e2m |- e2m/comp_ty B S B'} /\   
         {Ctx_m |- ml/of_coer Y' (ml/ty_coer_ty A' B')})).
% PROOF
induction on 2 2. split.
% val_ty
intros Hctx. case H1 (keep).
  % unit_refl_coer 
  search.
  % fun_coer
  apply IH to _ H2. apply IH1 to _ H3.
    exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1), (fun_skel S S1). split.
      search.
      search.
      apply lemma_27 to _ H6. apply lemma_27 to _ H9. search.
  % hand_coer ~> fun_coer
  apply IH1 to _ H2. apply IH1 to _ H3.
    exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1), (hand_skel S S1). 
      case H4.
        case H5.
          split.
            % a)
            search.
            % b)
            search.
            % c)
            apply lemma_27 to _ H6. apply lemma_27 to _ H9.  search.
          apply e2m/empty_dirt_is_not_full to _ _.
        apply e2m/comp_ty_member to _ _ _.
      apply e2m/empty_dirt_is_not_full to _ _.
    apply e2m/comp_ty_member to _ _ _.
  % hand_coer ~> hand_coer
  apply IH1 to _ H2. apply IH to _ H5.
    case H6.
      apply e2m/empty_dirt_is_not_full to _ _.
      case H7.
        apply e2m/empty_dirt_is_not_full to _ _.
        exists (ml/hand_ty A'3 A'1), (ml/hand_ty A'2 B'1), (hand_skel S S1).  split.
          % a)
          search.
          % b)
          search.          % c)
apply lemma_27 to _ H8. apply lemma_27 to _ H11. 
            apply ml/ctx_wf_ty_comp to _ H16.
            apply ml/ctx_wf_ty_comp to _ H17. search.
      apply e2m/comp_ty_member to _ _ _.
    apply e2m/comp_ty_member to _ _ _.
  % hand_coer ~> hand2fun_coer unsafe_coer
  apply IH to _ H2. apply IH1 to _ H4. apply lemma_28 to _ H8.
  exists (ml/hand_ty B' A'1), (ml/fun_ty A' B'1), (hand_skel S S1). split.
    search.
    search.
    apply lemma_27 to _ H7. apply lemma_27 to _ H10. search.
  % hand_coer ~> hand2fun_coer
  apply IH to _ H2. apply IH1 to _ H5.
    case H9.
      apply e2m/empty_dirt_is_not_full to _ _.
      exists (ml/hand_ty B' A'2), (ml/fun_ty A' B'1), (hand_skel S S1). split.
        search.
        search.
        apply lemma_27 to _ H8. apply lemma_27 to _ H11. apply ml/ctx_wf_ty_comp to _ H16.  search.
      apply e2m/comp_ty_member to _ H12 _.
  % lam_skel_coer
  apply IH to _ H2. exists A', B', (all_skel S).  search.
  % lam_ty_coer
  apply IH to _ H2. exists (ml/all_ty A'), (ml/all_ty B'), S1. split.
    search.
    search.
    assert (e2m/ctx Sig_e Sig_ml (e2m/val_ty n1 S n2 :: Ctx_e2m) (ml/wf_ty n2 :: Ctx_m)).
    apply lemma_27 to H6 H5. search.
  % lam_dirt_coer
  apply IH to _ H2. search.
  % lam_coer_coer val
  apply IH to _ H2. apply lemma_27 to _ H7. 
  exists (ml/qual_ty (ml/ty_coer_ty A3' A4') A'), (ml/qual_ty (ml/ty_coer_ty A3' A4') B'), S. split.
    search.
    search.
    apply e2m/preserve_wf_val_ty to _ H3. apply e2m/preserve_wf_val_ty to _ H4. search.
  % lam_coer_coer comp
  apply IH to _ H2. apply lemma_27 to _ H7. 
  exists (ml/qual_ty (ml/ty_coer_ty C1' C2') A'), (ml/qual_ty (ml/ty_coer_ty C1' C2') B'), S. split.
    search.
    search.
    apply e2m/preserve_wf_comp_ty to _ H3. apply e2m/preserve_wf_comp_ty to _ H4. search.
  % lam_coer_coer dirt
  apply IH to _ H2. apply lemma_27 to _ H5. search.
  % backchain
  apply ctx_e2m_member to _ _. case H4.
    case H2.
    case H2.
    case H2.
    case H2. apply e2m/val_ty_coer_member to Hctx H3. search.
    case H2.

% comp_ty
intros Hctx. case H1 (keep).
  % comp_ty_coer
  apply IH to _ H2. case H4.
    exists (ml/comp_ty A'), (ml/comp_ty B'), S. apply lemma_27 to _ H7. search.
    exists A', (ml/comp_ty B'), S. apply lemma_27 to _ H7. search.
    exists A', B', S. apply lemma_27 to _ H7. search.
    apply ctx_e2m_member to _ _. case H10.
      case H8.
      case H8.
      case H8.
      case H8.
      case H8.
  % backchain
  apply ctx_e2m_member to _ _. case H4.
    case H2.
    case H2.
    case H2.
    case H2.  
    skip.
% QED

Split e2m/preserve_ty_coer as e2m/preserve_val_ty_coer, e2m/preserve_comp_ty_coer.

Theorem e2m/transport_is_op:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m O,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- is_op O} ->
    {Ctx_m |- is_op O}.
% PROOF
induction on 2. intros. case H2 (keep).
  search.
  apply IH to _ H3. search.
  apply ctx_e2m_member to _ H4. case H5.
    case H3.
    case H3.
    case H3.
    case H3.
    case H3.
% QED

Theorem e2m/ctx_entail_sig:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {e2m/sig Sig_e Sig_ml}.
% PROOF
induction on 1. intros. case H1 (keep).
  search.
  apply IH to H2. search.
  apply IH to H2. search.
  apply IH to H2. search.
  apply IH to H2. search.
  apply IH to H2. search.
% QED


Define exp/sig_suffix : exp/sig -> exp/sig -> prop by

  exp/sig_suffix Sig Sig;

  exp/sig_suffix (exp/cons_sig O  A  B Sig) Sig'
   := exp/sig_suffix Sig Sig'.

Theorem exp/suffix_of_suffix:
  forall Sig1 Sig2 Sig3,
    exp/sig_suffix Sig1 Sig2 ->
    exp/sig_suffix Sig2 Sig3 ->
    exp/sig_suffix Sig1 Sig3. 
% PROOF
induction on 1. intros. case H1 (keep).
  search.
  apply IH to H3 H2. search.
% QED

Define ml/sig_suffix : ml/sig -> ml/sig -> prop by

  ml/sig_suffix Sig Sig;

  ml/sig_suffix (ml/cons_sig O  A  B Sig) Sig'
   := ml/sig_suffix Sig Sig'.

Theorem ml/suffix_of_suffix:
  forall Sig1 Sig2 Sig3,
    ml/sig_suffix Sig1 Sig2 ->
    ml/sig_suffix Sig2 Sig3 ->
    ml/sig_suffix Sig1 Sig3. 
% PROOF
induction on 1. intros. case H1 (keep).
  search.
  apply IH to H3 H2. search.
% QED

Theorem e2m/strengthen_apart:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m O1 O2, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- apart O1 O2} ->
    {apart O1 O2}.
% PROOF
induction on 2. intros. case H2 (keep).
  search.
  search.
  apply IH to _ H3. search.
  apply ctx_e2m_member to _ H4. case H5.
    case H3.
    case H3.
    case H3.
    case H3.
    case H3.
% QED

Theorem e2m/strengthen_of_op:
  forall Sig_e Sig_e' Sig_ml Ctx_e2m Ctx_m O A B,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    exp/sig_suffix Sig_e Sig_e' -> 
    {Ctx_e2m |- exp/of_op Sig_e' O A B} ->
    {exp/of_op Sig_e' O A B}.
% PROOF
induction on 3. intros. case H3 (keep).
  search.
  assert (exp/sig_suffix Sig_e Sig).
    assert (exp/sig_suffix (exp/cons_sig O1 A1 B1 Sig) Sig).
    apply exp/suffix_of_suffix to H2 _. search.
  apply IH to H1 H6 H4.
  apply e2m/strengthen_apart to _ H5. search.
  apply ctx_e2m_member to _ H5. case H6.
    case H4.
    case H4.
    case H4.
    case H4.
    case H4.
% QED

Theorem e2m/transport_of_op'':
  forall Sig_e Sig_ml O A B,
    {exp/of_op Sig_e O A B} ->
    {e2m/sig Sig_e Sig_ml} ->
    exists A' S1 B' S2,
      {e2m/val_ty A S1 A'} /\
      {e2m/val_ty B S2 B'} /\
      {ml/of_op Sig_ml O A' B'}.
% PROOF
induction on 1. intros. case H1 (keep).
  case H2. exists B1, X, B2, X1. split. 
    search.
    search.
    apply e2m/preserve_wf_val_ty to _ H3.
    apply e2m/preserve_wf_val_ty to _ H4. search.
  case H2. apply IH to H3 H7. exists A', S1, B', S2. split.
    search.
    search.
    search.
% QED

Theorem e2m/transport_of_op2:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m O A B,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- exp/of_op Sig_e O A B} ->
    exists A' S1 B' S2,
      {Ctx_e2m |- e2m/val_ty A S1 A'} /\
      {Ctx_e2m |- e2m/val_ty B S2 B'} /\
      {Ctx_m |- ml/of_op Sig_ml O A' B'}.
% PROOF
intros.
  apply e2m/strengthen_of_op to _ _ H2.
  apply e2m/ctx_entail_sig to H1.
  apply e2m/transport_of_op'' to H3 H4.
  assert {Ctx_m |- e2m/val_ty A S1 A'}.
  assert {Ctx_m |- e2m/val_ty B S2 B'}.
  assert {Ctx_m |- ml/of_op Sig_ml O A' B'}.
  search.
% QED

Theorem e2m/transport_of_op':
  forall Sig_e Sig_e' Sig_ml Sig_ml' Ctx_e2m Ctx_m O A S1 A' B S2 B',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {exp/of_op Sig_e' O A B} ->
    {Ctx_e2m |- e2m/val_ty A S1 A'} ->
    {Ctx_e2m |- e2m/val_ty B S2 B'} ->
    {e2m/sig Sig_e' Sig_ml'} ->
    (exp/sig_suffix Sig_e Sig_e') ->
    (ml/sig_suffix Sig_ml Sig_ml') ->
    {ml/of_op Sig_ml' O A' B'}.
% PROOF
induction on 2. intros. 
  case H2 (keep).
    case H5.
      assert {Ctx_e2m |- e2m/val_ty A X B1}.
      assert {Ctx_e2m |- e2m/val_ty B X1 B2}.
      apply e2m/val_ty_unique to _ H3 H11.
      apply e2m/val_ty_unique to _ H4 H12.
      assert (e2m/ctx Sig_e Sig_ml nil nil).
        apply e2m/ctx_entail_sig to H1. search.
      apply e2m/preserve_wf_val_ty to H13 H8.
      apply e2m/preserve_wf_val_ty to H13 H9.
      search.
    case H5.
      apply IH to H1 H8 H3 H4 H12 _ _.
        assert (ml/sig_suffix (ml/cons_sig O1 B3 B2 Sig_e1) Sig_e1).
        apply ml/suffix_of_suffix to H7 H13. search.
        assert (exp/sig_suffix (exp/cons_sig O1 A1 B1 Sig) Sig).
        apply exp/suffix_of_suffix to H6 H13. search.
      search.
% QED

Theorem e2m/transport_of_op:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m O A S1 A' B S2 B',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- exp/of_op Sig_e O A B} ->
    {Ctx_e2m |- e2m/val_ty A S1 A'} ->
    {Ctx_e2m |- e2m/val_ty B S2 B'} ->
    {Ctx_m |- ml/of_op Sig_ml O A' B'}.
% PROOF
intros.
apply e2m/ctx_entail_sig to H1.
assert (exp/sig_suffix Sig_e Sig_e).
assert (ml/sig_suffix Sig_ml Sig_ml).
apply e2m/strengthen_of_op to H1 H6 H2.
apply e2m/transport_of_op' to H1 H8 H3 H4 H5 H6 H7.
search.
% QED

Theorem e2m/strengthen_coer_ty:
(
  forall Sig_e Sig_ml Ctx_e2m Ctx_m Y Pi Y' A S A',
     e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
     {Ctx_e2m, e2m/coer Y Pi Y' |- e2m/val_ty A S A'} ->
     {Ctx_e2m |- e2m/val_ty A S A'}
) /\
(
  forall Sig_e Sig_ml Ctx_e2m Ctx_m Y Pi Y' C S C',
     e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
     {Ctx_e2m, e2m/coer Y Pi Y' |- e2m/comp_ty C S C'} ->
     {Ctx_e2m |- e2m/comp_ty C S C'}
) /\ 
(
  forall Sig_e Sig_ml Ctx_e2m Ctx_m Y Pi Y' D,
     e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
     {Ctx_e2m, e2m/coer Y Pi Y' |- e2m/full_dirt D} ->
     {Ctx_e2m |- e2m/full_dirt D}
).
% PROOF
induction on 2 2 2. split.

intros. case H2 (keep).
  search.
  apply IH to _ H3. apply IH1 to _ H4. search.
  apply IH to _ H3. apply IH1 to _ H4. search.
  apply IH to _ H3. apply IH2 to _ H4. apply IH  to _ H5. search.
  apply IH to _ H3. search.
  apply IH to _ H3. search.
  monotone H3 with (e2m/coer Y Pi Y' :: e2m/full_dirt n1 :: Ctx_e2m).
    intros. case H4.
      search.
      case H5.
        search.
        search.
    apply IH to _ H4. search.
  apply IH to _ H3. apply IH to _ H4. apply IH to _ H5. search.
  apply IH1 to _ H3. apply IH1 to _ H4. apply IH to _ H5. search.
  apply IH to _ H3. search.
  case H4. 
    case H3.
    apply ctx_e2m_member to _ H5. case H6. 
      case H3.
      case H3. search.
      case H3.
      case H3.
      case H3.

intros. case H2 (keep).
  apply IH to _ H3. search.
  apply IH2 to _ H3. apply IH to _ H4. search. 
  case H4. 
    case H3.
    apply ctx_e2m_member to _ H5. case H6. 
      case H3.
      case H3.
      case H3.
      case H3.
      case H3.
 
intros. case H2 (keep).
  search.
  case H4.
    case H3.
    apply ctx_e2m_member to _ H5. case H6.
      case H3.
      case H3.
      case H3. search.
      case H3.
      case H3.
% QED

Split e2m/strengthen_coer_ty as e2m/strengthen_coer_val_ty, e2m/strengthen_coer_comp_ty.


Theorem e2m/member_val_of_term:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m  V_t A_t V_ml,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    member (e2m/val Sig_e V_t A_t V_ml) Ctx_e2m ->
    exists S A', {Ctx_e2m |- e2m/val_ty A_t S A'} /\
    member (ml/of_term Sig_ml V_ml A') Ctx_m.
% PROOF
induction on 2. intros. case H2 (keep).
  case H1. exists S, A'. search.
  case H1.
    apply IH to _ H3. exists S1, A'1. search.
    apply IH to _ H3. exists S1, (A' n2). search.
    apply IH to _ H3. exists S, A'. search.
    apply IH to _ H3. exists S1, A'. search.
    apply IH to _ H3. exists S1, A'. search.
% QED

Theorem ml/of_term_member_entails:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m  V_ml A',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    member (ml/of_term Sig_ml V_ml A') Ctx_m ->
    { Ctx_m |- ml/of_term Sig_ml V_ml A'}.
% PROOF
intros. search.
% QED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main Theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/of :
 (forall Sig_e Sig_ml V_t V_ml A_t Ctx_e2m Ctx_m,
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/val Sig_e V_t A_t V_ml}
     -> exists T S, {Ctx_e2m |- e2m/val_ty A_t S (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml V_ml T})
 /\
 (forall Sig_e Sig_ml C_t C_ml D_t Ctx_e2m Ctx_m,
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/comp Sig_e C_t D_t C_ml}
     -> exists T S, {Ctx_e2m |- e2m/comp_ty D_t S (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml C_ml T})
 /\
 (forall Sig_e Sig_ml Ctx_e2m Ctx_m H A D1 C H',
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/hand Sig_e H A D1 C H'}
     -> exists A' S1 B D2 B' S2, 
         {Ctx_e2m |- e2m/val_ty A S1 A'} /\ 
         C = (exp/bang B D2) /\ {Ctx_e2m |- e2m/val_ty B S2 B'} /\ 
         {Ctx_m |- ml/of_hand Sig_ml H' A' B'}
 )
 .
induction on 2 2 2. split.
% VALUES
intros.
case H2 (keep).
  % UNIT
  search.
  % FUN
  apply IH1 to _ H4.
  exists (ml/fun_ty Aml T), (fun_skel X S).
  split.
    apply ml/strengthen_comp_ty to _ H5. search.
    apply e2m/preserve_wf_val_ty to _ H3. 
      apply ml/strengthen_comp_ty to _ H5.
      apply e2m/preserve_wf_comp_ty to _ H8.
      search.
  % HAND
  case H3 (keep).  apply IH1 to _ H5. 
    exists (ml/fun_ty A1' T), (hand_skel X S). apply ml/strengthen_comp_ty to H1 H6. split.
      search.
      apply e2m/preserve_wf_val_ty to _ H4. apply e2m/preserve_wf_comp_ty to _ H8. search.
      apply ctx_e2m_member to _ H5. case H6.
        case H4.
        case H4.
        case H4.
        case H4.
        case H4.
  apply IH2 to _ H4. exists (ml/hand_ty A' B'), (hand_skel S1 S2). 
    apply e2m/preserve_wf_val_ty to _ H5. apply e2m/preserve_wf_val_ty to _ H6. search.
  % LAM_SKEL
  apply IH to _ H3. exists T, (all_skel S). search.
  % APP_SKEL
  apply IH to _ H3. 
  assert (exists S', S1 = all_skel S'). case H4.
    search.
    apply ctx_e2m_member to _ H7. case H8.
    case H6.
    case H6. case H9.
    case H6.
    case H6.
    case H6.
  case H6. 
  exists T, (S' S). split.
    case H4. 
      inst H7 with n1 = S. search.
      apply ctx_e2m_member to _ H8. case H9.
        case H7. case H7. case H10. case H7. case H7. case H7.
    search.
  % LAM_TY
  apply IH to _ H3.
  apply e2m/preserve_wf_val_ty to _ H4.
  search.
  % APP_TY 
  apply IH to _ H3. case H5.
  exists (A' Am1), S1. split.
    inst H7 with n1 = At1, n2 = Am1. cut H8 with H4. search.
    apply e2m/preserve_wf_val_ty to _ H4.
    apply e2m/preserve_wf_val_ty to _ H7.
    inst H9 with n2 = Am1. cut H10 with H8.
    search.
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H10. case H7. case H7. case H7.
  % LAM_DIRT
  apply IH to _ H3. search.
  % APP_DIRT
  apply IH to _ H4.
  % Where did we get the translation of forall from?
  case H5.
    % interesting case
    apply e2m/from_impure_val to _ H3 with A1 = T, S = S.
    apply H8 to _.
    apply e2m/preserve_wf_val_ty to _ H9.
    search.
    % backchain
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H10. case H7. case H7. case H7.
  % LAM_COER VAL
  apply e2m/preserve_wf_val_ty to _ H4.
  apply e2m/preserve_wf_val_ty to _ H5.
  apply IH to _ H3.
  apply e2m/strengthen_coer_val_ty to _ H8.
  apply e2m/preserve_wf_val_ty to _ H10.
  search.
  % LAM_COER COMP
  apply e2m/preserve_wf_comp_ty to _ H4.
  apply e2m/preserve_wf_comp_ty to _ H5.
  apply IH to _ H3.
  apply e2m/strengthen_coer_val_ty to _ H8.
  apply e2m/preserve_wf_val_ty to _ H10.
  search.
  % LAM_COER DIRT
  apply IH to _ H3.
  apply e2m/preserve_wf_val_ty to _ H5.
  search.
  % APP_COER VAL
  apply IH to _ H3.
  case H5.
    % interesting case
    apply e2m/preserve_val_ty_coer to _ H4.
    apply e2m/preserve_wf_val_ty to _ H9.
    apply e2m/val_ty_unique to _ H7 H10.
    apply e2m/val_ty_unique to _ H8 H11.
    search.
    % backchain
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H10. case H7. case H7. case H7.
  % APP_COER COMP
  apply IH to _ H3.
  case H5.
    % interesting case
    apply e2m/preserve_comp_ty_coer to _ H4.
    apply e2m/preserve_wf_val_ty to _ H9.
    apply e2m/comp_ty_unique to _ H7 H10.
    apply e2m/comp_ty_unique to _ H8 H11.
    search.
    % backchain
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H10. case H7. case H7. case H7.
  % APP_COER DIRT
  apply IH to _ H3.
  case H5.
    % interesting case
    search.
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H10. case H7. case H7. case H7.
  % CAST
  apply IH to _ H3.
  apply e2m/preserve_val_ty_coer to _ H4.
  apply e2m/val_ty_unique to _ H5 H7.
  apply e2m/preserve_wf_val_ty to _ H8. search.
  % backchain
  apply ctx_e2m_member to H1 H4. case H5.
    case H3. exists A', S. split.
      search.
      apply e2m/member_val_of_term to _ H4. 
      apply e2m/val_ty_unique to _ H8 H9. search.
    case H3.
    case H3.
    case H3.
    case H3.

intros.
case H2 (keep).
  % APP
  apply IH to H1 H3. apply IH to H1 H4.
  case H5.
    apply e2m/val_ty_unique to H1 H7 H9. apply e2m/preserve_wf_comp_ty to H1 H10. search.
    apply ctx_e2m_member to H1 H10. case H11.
      case H9.
      case H9. case H12.
      case H9.
      case H9.
      case H9.
  % LET -> LET
  apply IH to _ H3. apply IH1 to _ H4.
  apply ml/strengthen_comp_ty to _ H7.
  apply e2m/preserve_wf_comp_ty to _ H9.
  search.
  % RETURN
  apply IH to _ H3.
  apply e2m/preserve_wf_val_ty to _ H4.
  search.
  % OP
  apply IH to _ H6.
  apply IH1 to _ H7.
  apply ml/strengthen_comp_ty to _ H12.
  apply e2m/preserve_wf_comp_ty to _ H14.
  apply e2m/transport_of_op to H1 H3 H4 H5.  
  apply e2m/transport_is_op to _ H9.
  apply e2m/val_ty_unique to _ H4 H10.
  case H14 (keep).
    % what if the dirt is empty?
    case H8. % this can't be because the operation couldn't appear in it
      apply ctx_e2m_member to _ H20. case H21. case H19. case H19. case H19. case H19. case H19.
    % what if the dirt is full?
    search.
  % backchain
  apply ctx_e2m_member to _ H19. case H20. case H18. case H18. case H18. case H18. case H18.
  % DO -> LET
  apply IH1 to _ H3.
  case H5. % how was the A ! 0 translated?
    % it was A' - interesting case
    apply IH1 to _ H4 with Ctx_m = (ml/of_term Sig_ml n2 T :: Ctx_m).
    apply ml/strengthen_comp_ty to _ H8.
    apply e2m/preserve_wf_comp_ty to _ H10. search.
    % 0 was full
    case H7.
    apply ctx_e2m_member to _ H10. case H11. case H9. case H9. case H9. case H12. case H9. case H9.
    % it came from the context
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H7. case H7. case H7.
  % DO -> DO
  apply IH1 to _ H3.
  case H5. % how was the A ! FullDirt translated?
    % it was comp_ty A' - interesting case
    apply IH1 to _ H4 with Ctx_m = (ml/of_term Sig_ml n2 A' :: Ctx_m), Sig_ml = Sig_ml.
    apply ml/strengthen_comp_ty to _ H9.
    apply e2m/preserve_wf_comp_ty to _ H11.
    case H11. % how was B ! FullDirt translated?
      % comp_ty B' - no surprise
      search.
      % it came from the context
      apply ctx_e2m_member to _ H14. case H15. case H13. case H13. case H13. case H13. case H13.
    % it came from the context
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H7. case H7. case H7.
  % HANDLE -> APP
  apply IH1 to _ H3.
  apply IH to _ H4.
  case H7. % how was the handler type translated?
    % into a function type - as we assumed
    % how was the computation type translated?
    case H5.
      % it was also pure
      apply e2m/preserve_wf_comp_ty to _ H10.
      apply e2m/val_ty_unique to _ H9 H11.
      search.
      % no, the empty dirt was full
      apply e2m/empty_dirt_is_not_full to _ H11.
      % from the context
      apply ctx_e2m_member to _ H12. case H13. case H11. case H11. case H11. case H11. case H11.
    % into a handler type even though we had an empty dirt
    apply e2m/empty_dirt_is_not_full to _ H10.
    % from the context
    apply ctx_e2m_member to _ H10. case H11. case H9. case H9. case H12. case H9. case H9. case H9.
  % HANDLE -> HANDLE & UNSAFE
  apply IH1 to _ H3.
  apply IH to _ H5.
  apply e2m/of_val_refl_coer2 to _ H6.
  exists A', X. split.
    search.
    % how does the handler type translation look like?
    case H9.
    % it's a function - not what we expected as we have a full empty dirt
    apply e2m/empty_dirt_is_not_full to _ H4.
    % it's a proper handler as expected
    % how does the computation type translation look like?
    case H7.
    % again someone thinks empty dirts are full.
    apply e2m/empty_dirt_is_not_full to _ H14.
    % now the interesting case
    apply e2m/val_ty_unique to _ H11 H15.
    apply e2m/val_ty_unique to _ H13 H17.
    apply e2m/preserve_wf_val_ty to _ H11.
    %apply e2m/of_refl_coer to _ H7.
    search.
    apply ctx_e2m_member to _ H17. case H18. case H16. case H16. case H16. case H16. case H16.
    apply ctx_e2m_member to _ H14. case H15. case H13. case H13. case H16. case H13. case H13. case H13. 
  % HANDLE -> HANDLE
  apply IH1 to _ H3.
  apply IH to _ H5.
  case H9. % how was the handler type translated?
    % into a function type - but we assumed the dirt was full
    case H4.
    apply ctx_e2m_member to _ H14. case H15. case H13. case H13. case H13. case H16.  case H13. case H13.
    % into a handler type
    apply e2m/preserve_wf_val_ty to _ H13.
    % how was the computation type translated?
    case H7.
      % maybe the empty dirt is empty? I don't think so.
      case H12.
      apply ctx_e2m_member to _ H17. case H18. case H16. case H16. case H16. case H19. case H16. case H16.
      % it was also a computation type
      apply e2m/val_ty_unique to _ H11 H16.
      search.
      % from the context
      apply ctx_e2m_member to _ H16. case H17. case H15. case H15. case H15. case H15. case H15.
    % from the context
    apply ctx_e2m_member to _ H12. case H13. case H11. case H11. case H14. case H11. case H11. case H11.
  % CAST
  apply IH1 to _ H3.
  apply e2m/preserve_comp_ty_coer to _ H4.
  apply e2m/comp_ty_unique to _ H5 H7.
  apply e2m/preserve_wf_comp_ty to _ H8. search.
  % backchain
  apply ctx_e2m_member to H1 H4. case H5.
    case H3.
    case H3.
    case H3.
    case H3.
    case H3.

intros.
case H2 (keep).
  apply IH1 to _ H4.
    apply ml/strengthen_comp_ty to _ H5.
    case H7.
      exists A1', X, A2, empty, T, S. split.
        search.
        search.
        search.
        apply e2m/preserve_wf_val_ty to _ H3. 
        apply e2m/preserve_wf_val_ty to _ H8. search.
      apply e2m/empty_dirt_is_not_full to _ H8.
      apply e2m/comp_ty_member to _ _ _.
  apply IH1 to _ H5.
    apply ml/strengthen_comp_ty to _ H6.
    case H8.
      apply e2m/empty_dirt_is_not_full to _ H3.
      exists A1', X, A2, D1, A', S. split.
        search.
        search.
        search.
        apply e2m/preserve_wf_val_ty to _ H4.
        apply e2m/preserve_wf_val_ty to _ H10. search.
      apply e2m/comp_ty_member to _ _ _.
  apply IH2 to _ H3.
    exists A', S1, B1, empty, B', S2. split.
      search.
      search.
      search.
      apply e2m/transport_is_op to _ _.
      apply e2m/transport_of_op2 to H1 H4.
      apply e2m/preserve_wf_val_ty to _ H9.
      apply e2m/preserve_wf_val_ty to _ H10.
      apply IH1 to _ H5.
      apply e2m/of_val_refl_coer2 to _ H7.
      apply e2m/of_val_refl_coer2 to _ H8.
      apply e2m/val_ty_unique to _ H14 H20.
      apply e2m/val_ty_unique to _ H10 H22.
      apply e2m/preserve_wf_val_ty to _ H20.
      assert {Ctx_m |- ml/of_coer (ml/fun_coer Y1 (ml/unsafe_coer Y2)) 
               (ml/ty_coer_ty (ml/fun_ty A'2 (ml/comp_ty A'3))
                              (ml/fun_ty A'2 A'3))}.
      assert {Ctx_m,  ml/of_term Sig_ml n5 (ml/fun_ty A'2 (ml/comp_ty A'3)) |- ml/of_term Sig_ml n5 (ml/fun_ty A'2 (ml/comp_ty A'3))}.
      assert {Ctx_m,  ml/of_term Sig_ml n5 (ml/fun_ty A'2 (ml/comp_ty A'3)) |- 
        ml/of_term Sig_ml (ml/cast n5 (ml/fun_coer Y1 (ml/unsafe_coer Y2))) 
          (ml/fun_ty A'2 A'3)}.
      inst H19 with n4 = (ml/cast n5 (ml/fun_coer Y1 (ml/unsafe_coer Y2))).
      cut H28 with H27.
      case H18.
        apply ml/strengthen_val_ty to _ H30.
          assert {Ctx_e2m, e2m/val Sig_e n3 (exp/fun_ty A2 (exp/bang B1 empty)) n4 |-
                   e2m/val_ty B1 X1 A'3}.
          apply e2m/val_ty_unique to _ H31 H32.
          search.
        apply e2m/empty_dirt_is_not_full to _ H30.
        apply e2m/comp_ty_member to _ H30 _.
  apply IH2 to _ H4.
      apply e2m/transport_is_op to _ _.
      apply e2m/transport_of_op2 to H1 H5.
      apply IH1 to _ H6.
      exists A', S1, B1, D2, B', S2. split.
        search.
        search.
        search.
        apply e2m/preserve_wf_val_ty to _ H8.
        apply e2m/preserve_wf_val_ty to _ H9.
        apply e2m/preserve_wf_val_ty to _ H12.
        apply e2m/preserve_wf_val_ty to _ H13.
        case H15.
          apply e2m/empty_dirt_is_not_full to _ H3.
          assert {Ctx_e2m, e2m/val Sig_e n1 A1 n2, e2m/val Sig_e n3 (exp/fun_ty A2 (exp/bang B1 D2)) n4 |-
            e2m/val_ty B1 S2 B'}.
            apply e2m/val_ty_unique to _ H22 H23.
            search.
          apply e2m/comp_ty_member to _ H21 _.
  apply ctx_e2m_member to _ H4. case H5.
    case H3.
    case H3.
    case H3.
    case H3.
    case H3.

Split e2m/of as e2m/of_val, e2m/of_comp, e2m/of_hand.
