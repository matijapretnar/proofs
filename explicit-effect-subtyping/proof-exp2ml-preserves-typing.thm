Specification "exp2ml".
Import "common".
Import "proof-exp2ml-lemmas".

Set subgoals off.

Theorem from_impure :
  (
    forall A D Y D' A1 A2,
      {from_impure/val A D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/val_ty (A D') A1} ->
      {e2m/val_ty (A D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall C D Y D' A1 A2,
      {from_impure/comp C D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/comp_ty (C D') A1} ->
      {e2m/comp_ty (C D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall A D Y D' A1 A2,
      {to_impure/val A D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/val_ty (A D') A1} ->
      {e2m/val_ty (A D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ) /\
  (
    forall C D Y D' A1 A2,
      {to_impure/comp C D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/comp_ty (C D') A1} ->
      {e2m/comp_ty (C D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ).
skip.
% induction on 1 1 1 1. split.
% % from_impure/val
% intros. case H1.
%   % unit_ty
%   case H3. case H4. search.
%   % fun_ty
%   case H3. case H4.
%   apply IH2 to H5 H2 H7 H9.
%   apply IH1 to H6 H2 H8 H10.
%   search.
% % from_impure/comp
% intros. case H1.
%   % empty
%   case H3. % see what the full dirt D' is
%     % trivial case
%     case H2.
%     % interesting case
%     case H4.
%       % interesting case
%       apply IH to H5 H2 H7 H8. search.
%       case H8.
%   % non-empty case
%   case H3.
%     case H2.
%     case H4.
%       case H6.
%       apply IH to H5 H2 H8 H10. search.
% % to_impure/val
% skip.
% % to_impure/comp
% skip.
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% dirt_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_dirt_coer:
  forall D1 D2 Y1' Y2' A1 A2 A1' A2',
    {e2m/dirt_coer D1 D2 Y1' Y2'} ->
    {ml/of_coer Y1' (ml/ty_coer_ty A1' A2')} ->
    {e2m/val_ty A1 A1'} ->
    {e2m/val_ty A2 A2'} ->
    (exists A3' A4',
       {ml/of_coer Y2' (ml/ty_coer_ty A3' A4')} /\
       {e2m/comp_ty (exp/bang A1 D1) A3'} /\ 
       {e2m/comp_ty (exp/bang A2 D2) A4'}).
% PROOF
intros. case H1 (keep).
  exists (ml/comp_ty A1'), (ml/comp_ty A2'). case H2 (keep). case H7. search.
  exists A1', (ml/comp_ty A2'). case H2 (keep). case H6. search.
  exists A1', A2'. search. 
% QED
   
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% of_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_ty_coer:
  (forall Y A B Y',
    {e2m/coer Y (exp/val_ty_coer_ty A B) Y'} ->
      (exists A' B',
         {e2m/val_ty A A'} /\ 
         {e2m/val_ty B B'} /\   
         {ml/of_coer Y' (ml/ty_coer_ty A' B')}))
  /\
  (forall Y A B Y',
    {e2m/coer Y (exp/comp_ty_coer_ty A B) Y'} ->
      (exists A' B',
         {e2m/comp_ty A A'} /\ 
         {e2m/comp_ty B B'} /\   
         {ml/of_coer Y' (ml/ty_coer_ty A' B')})).
% PROOF
induction on 1 1. split.

  intros. case H1 (keep).
    search.
    apply IH to H2. apply IH1 to H3.
      exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1). split.
        search.
        search.
        case H6 (keep). case H9 (keep). case H10. case H12. search.
    apply IH1 to H2. apply IH1 to H3. 
      exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1). split. 
        case H4. 
          case H5. 
            search.
            case H11. 
          case H10.
        case H4. 
          case H5. 
            search.
            case H11. 
          case H10.
        case H6 (keep). case H9 (keep). case H10. case H12. search.
    apply IH1 to H2. apply IH to H5. 
      case H6. case H4. case H7. case H3.
        exists (ml/hand_ty A'3 A'1), (ml/hand_ty A'2 B'1). split.
          search.
          search.
          case H8 (keep). case H11 (keep). case H16. case H18. case H20. case H21. search.
    apply IH to H2. apply IH1 to H4. case H8.
      exists (ml/hand_ty B' A'1), (ml/fun_ty A' B'1). split.
        search.
        search.
        case H10 (keep). case H12. case H7 (keep). case H16. search.
      case H11.
    apply IH to H2. apply IH1 to H5.
      case H8 (keep). case H11 (keep). case H12. case H14.
      case H9.
        case H4.
        exists (ml/hand_ty B' A'2), (ml/fun_ty A' B'1). split.
          search.
          search.
          case H18. search.
    apply IH to H2. search.
    skip. % TODO
    skip. % TODO
    apply IH to H2. case H7 (keep). case H8. skip. % TODO
    skip. % TODO
    apply IH to H2. search.
        
  intros. case H1 (keep).
    apply IH to H2. 
      apply e2m/preserve_dirt_coer to H4 H7 H5 H6.
      search.

% QED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main Theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/of_val :
 (forall Sig_e Sig_ml V_t V_ml A_t Ctx_e2m Ctx_m,
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/val Sig_e V_t A_t V_ml}
     -> exists T, {Ctx_e2m |- e2m/val_ty A_t (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml V_ml T})
 /\
 (forall Sig_e Sig_ml C_t C_ml D_t Ctx_e2m Ctx_m,
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/comp Sig_e C_t D_t C_ml}
     -> exists T, {Ctx_e2m |- e2m/comp_ty D_t (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml C_ml T})
 .
induction on 2 2. split.
% VALUES
intros.
case H2 (keep).
  % UNIT
  search.
  % FUN
  apply IH1 to _ H4.
  exists (ml/fun_ty Aml T).
  split.
    apply ml/strengthen_comp_ty to _ H5. search.
    apply e2m/preserve_wf_val_ty to _ H3. 
      apply ml/strengthen_comp_ty to _ H5.
      apply e2m/preserve_wf_comp_ty to _ H8.
      search.
  % HAND
  case H3 (keep).  apply IH1 to _ H5. skip.
  skip.
  skip.
  % LAM_SKEL
  apply IH to _ H3. exists T. search.
  % APP_SKEL
  apply IH to _ H3. exists T. split.
    case H4. 
      inst H6 with n1 = S. search.
      skip. % backchain
    search.
  % LAM_TY
  skip. % TODO: handle exp/skel_val_ty n1 S in context
  % APP_TY 
  apply IH to _ H3. case H6. exists (A' Am1). split.
    inst H8 with n1 = At1, n2 = Am1. cut H9 with H4. search.
    apply e2m/preserve_wf_val_ty to _ H4. case H7.
      case H10. inst H12 with n1 = Am1. cut H13 with H9. search.
    skip. % backchain
    skip. % backchain
    skip. % backchain
  % LAM_DIRT
  apply IH to _ H3. exists T. split.
    search.
    search.
  % APP_DIRT
  apply IH to _ H4.
  skip.
  % LAM_COER VAL
  skip.
  % LAM_COER COMP
  skip.
  % LAM_COER DIRT
  skip.
  % APP_COER VAL
  skip.
  % APP_COER COMP
  skip.
  % APP_COER DIRT
  skip.
  % CAST
  skip.
  % backchain
  skip.

intros.
case H2 (keep).
  
  ...

exists (ml/fun_ty A1' 
    ...
  ...
% SKELETON LAMBDA
apply IH to _ H3.
exists T.
split.
search.
search.
% SKELETON APPLY
apply IH to _ H3.
exists T.
split..
case H4.
inst H6 with n1 = S.
search.
%
