Specification "exp2ml".
Import "common".
Import "proof-exp2ml-lemmas".

Set subgoals off.

Theorem from_impure :
  (
    forall A D Y D' A1 A2,
      {from_impure/val A D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/val_ty (A D') A1} ->
      {e2m/val_ty (A D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall C D Y D' A1 A2,
      {from_impure/comp C D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/comp_ty (C D') A1} ->
      {e2m/comp_ty (C D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A1 A2)}
  ) /\ (
    forall A D Y D' A1 A2,
      {to_impure/val A D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/val_ty (A D') A1} ->
      {e2m/val_ty (A D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ) /\
  (
    forall C D Y D' A1 A2,
      {to_impure/comp C D Y} ->
      {e2m/full_dirt D'} ->
      {e2m/comp_ty (C D') A1} ->
      {e2m/comp_ty (C D) A2} ->
      {ml/of_coer Y (ml/ty_coer_ty A2 A1)}
  ).
skip.
% induction on 1 1 1 1. split.
% % from_impure/val
% intros. case H1.
%   % unit_ty
%   case H3. case H4. search.
%   % fun_ty
%   case H3. case H4.
%   apply IH2 to H5 H2 H7 H9.
%   apply IH1 to H6 H2 H8 H10.
%   search.
% % from_impure/comp
% intros. case H1.
%   % empty
%   case H3. % see what the full dirt D' is
%     % trivial case
%     case H2.
%     % interesting case
%     case H4.
%       % interesting case
%       apply IH to H5 H2 H7 H8. search.
%       case H8.
%   % non-empty case
%   case H3.
%     case H2.
%     case H4.
%       case H6.
%       apply IH to H5 H2 H8 H10. search.
% % to_impure/val
% skip.
% % to_impure/comp
% skip.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% dirt_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_dirt_coer:
  forall D1 D2 Y1' Y2' A1 A2 A1' A2',
    {e2m/dirt_coer D1 D2 Y1' Y2'} ->
    {ml/of_coer Y1' (ml/ty_coer_ty A1' A2')} ->
    {e2m/val_ty A1 A1'} ->
    {e2m/val_ty A2 A2'} ->
    (exists A3' A4',
       {ml/of_coer Y2' (ml/ty_coer_ty A3' A4')} /\
       {e2m/comp_ty (exp/bang A1 D1) A3'} /\ 
       {e2m/comp_ty (exp/bang A2 D2) A4'}).
% PROOF
intros. case H1 (keep).
  exists (ml/comp_ty A1'), (ml/comp_ty A2'). case H2 (keep). case H7. search.
  exists A1', (ml/comp_ty A2'). case H2 (keep). case H6. search.
  exists A1', A2'. search. 
% QED
   
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% of_coer preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_ty_coer:
  (forall Sig_e Sig_ml Ctx_e2m Ctx_m Y A B Y',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->  
    {Ctx_e2m |- e2m/coer Y (exp/val_ty_coer_ty A B) Y'} ->
      (exists A' B',
         {Ctx_e2m |- e2m/val_ty A A'} /\ 
         {Ctx_e2m |- e2m/val_ty B B'} /\   
         {Ctx_m |- ml/of_coer Y' (ml/ty_coer_ty A' B')}))
  /\
  (forall Sig_e Sig_ml Ctx_e2m Ctx_m Y A B Y',
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- e2m/coer Y (exp/comp_ty_coer_ty A B) Y'} ->
      (exists A' B',
         {Ctx_e2m |- e2m/comp_ty A A'} /\ 
         {Ctx_e2m |- e2m/comp_ty B B'} /\   
         {Ctx_m |- ml/of_coer Y' (ml/ty_coer_ty A' B')})).
% PROOF
% induction on 2 2. split.

%   intros Hctx. case H1 (keep).
%     search.
%     apply IH to _ H2. apply IH1 to _ H3.
%       exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1). split.
%         search.
%         search.
%         case H6 (keep).
%           case H9 (keep).
%             case H10.
%               case H12.
%                 search.
%                 apply ctx_m_member to _ H17. case H18. case H16. case H16.
%               apply ctx_m_member to _ H15. case H16. case H14. case H14.
%             apply ctx_m_member to _ H13. case H14. case H12. case H12.
%           apply ctx_m_member to _ H11. case H12. case H10. case H10.
%           .
%     apply IH1 to _ H2. apply IH1 to _ H3.
%       exists (ml/fun_ty B' A'1), (ml/fun_ty A' B'1). split. 
%         case H4. 
%           case H5. 
%             search.
%             case H11. 
%           case H10.
%         case H4. 
%           case H5. 
%             search.
%             case H11. 
%           case H10.
%         case H6 (keep). case H9 (keep). case H10. case H12. search.
%     apply IH1 to _ H2. apply IH to _ H5. 
%       case H6. case H4. case H7. case H3.
%         exists (ml/hand_ty A'3 A'1), (ml/hand_ty A'2 B'1). split.
%           search.
%           search.
%           case H8 (keep). case H11 (keep). case H16. case H18. case H20. case H21. search.
%     apply IH to _ H2. apply IH1 to _ H4. case H8.
%       exists (ml/hand_ty B' A'1), (ml/fun_ty A' B'1). split.
%         search.
%         search.
%         case H10 (keep). case H12. case H7 (keep). case H16. search.
%       case H11.
%     apply IH to _ H2. apply IH1 to _ H5.
%       case H8 (keep). case H11 (keep). case H12. case H14.
%       case H9.
%         case H4.
%         exists (ml/hand_ty B' A'2), (ml/fun_ty A' B'1). split.
%           search.
%           search.
%           case H18. search.
%     apply IH to H2. search.
%     apply IH to H2.
%     .
%     skip. % TODO
%     skip. % TODO
%     apply IH to H2. case H7 (keep). case H8. skip. % TODO
%     skip. % TODO
%     apply IH to H2. search.
        
%   intros. case H1 (keep).
%     apply IH to H2. 
%       apply e2m/preserve_dirt_coer to H4 H7 H5 H6.
%       search.
skip.
% QED

Split e2m/preserve_ty_coer as e2m/preserve_val_ty_coer, e2m/preserve_comp_ty_coer.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main Theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/of_val :
 (forall Sig_e Sig_ml V_t V_ml A_t Ctx_e2m Ctx_m,
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/val Sig_e V_t A_t V_ml}
     -> exists T, {Ctx_e2m |- e2m/val_ty A_t (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml V_ml T})
 /\
 (forall Sig_e Sig_ml C_t C_ml D_t Ctx_e2m Ctx_m,
        e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
     -> {Ctx_e2m |- e2m/comp Sig_e C_t D_t C_ml}
     -> exists T, {Ctx_e2m |- e2m/comp_ty D_t (T:ml/ty)} /\ {Ctx_m |- ml/of_term Sig_ml C_ml T})
 .
induction on 2 2. split.
% VALUES
intros.
case H2 (keep).
  % UNIT
  search.
  % FUN
  apply IH1 to _ H4.
  exists (ml/fun_ty Aml T).
  split.
    apply ml/strengthen_comp_ty to _ H5. search.
    apply e2m/preserve_wf_val_ty to _ H3. 
      apply ml/strengthen_comp_ty to _ H5.
      apply e2m/preserve_wf_comp_ty to _ H8.
      search.
  % HAND
  case H3 (keep).  apply IH1 to _ H5. skip.
  skip.
  skip.
  % LAM_SKEL
  apply IH to _ H3. exists T. search.
  % APP_SKEL
  apply IH to _ H3. exists T. split.
    case H4. 
      inst H6 with n1 = S. search.
      apply ctx_e2m_member to _ H7. case H8.
        case H6. case H6. case H9. case H6. case H6. case H6.
    search.
  % LAM_TY
  skip. % TODO: handle exp/skel_val_ty n1 S in context
  % APP_TY 
  apply IH to _ H3. case H6. exists (A' Am1). split.
    inst H8 with n1 = At1, n2 = Am1. cut H9 with H4. search.
    apply e2m/preserve_wf_val_ty to _ H4. case H7.
      case H10. inst H12 with n1 = Am1. cut H13 with H9. search.
    apply ctx_m_member to _ H13. case H14. case H12. case H12. case H15.
    apply ctx_m_member to _ H11. case H12.
      case H10.
        skip. % interesting case for all_ty
      case H10.
    apply ctx_e2m_member to _ H9. case H10. case H8. case H8. case H11. case H8. case H8. case H8.
  % LAM_DIRT
  apply IH to _ H3. exists T. split.
    search.
    search.
  % APP_DIRT
  apply IH to _ H4.
  skip. % from_impure!
  % LAM_COER VAL
  skip. % e2m/coer ... in Ctx_e2m
  % LAM_COER COMP
  skip. % e2m/coer ... in Ctx_e2m
  % LAM_COER DIRT
  skip. % e2m/coer ... in Ctx_e2m
  % APP_COER VAL
  skip.
  % APP_COER COMP
  skip.
  % APP_COER DIRT
  skip.
  % CAST
  apply IH to _ H3.
  apply e2m/preserve_val_ty_coer to _ H4.
  apply e2m/val_ty_unique to _ H5 H7.
  apply e2m/preserve_wf_val_ty to _ H8. search.
  % backchain
  apply ctx_e2m_member to H1 H4. case H5.
    case H3. skip. % interesting backchain case
    case H3.
    case H3.
    case H3.
    case H3.
intros.
case H2 (keep).
  % APP
  apply IH to H1 H3. apply IH to H1 H4.
  case H5.
    apply e2m/val_ty_unique to H1 H7 H9. apply e2m/preserve_wf_comp_ty to H1 H10. search.
    apply ctx_e2m_member to H1 H10. case H11.
      case H9.
      case H9. case H12.
      case H9.
      case H9.
      case H9.
  % LET -> LET
  apply IH to _ H3. apply IH1 to _ H4.
  apply ml/strengthen_comp_ty to _ H7.
  apply e2m/preserve_wf_comp_ty to _ H9.
  search.
  % RETURN
  apply IH to _ H3.
  apply e2m/preserve_wf_val_ty to _ H4.
  search.
  % OP
  apply IH to _ H6.
  apply IH1 to _ H7.
  apply ml/strengthen_comp_ty to _ H12.
  apply e2m/preserve_wf_comp_ty to _ H14.
  assert {Ctx_m |- ml/of_op Sig_ml O Am1 Am2}. skip.
  assert {Ctx_m |- is_op O}. skip.
  apply e2m/val_ty_unique to _ H4 H10.
  case H14 (keep).
    % what if the dirt is empty?
    case H8. % this can't be because the operation couldn't appear in it
      apply ctx_e2m_member to _ H20. case H21. case H19. case H19. case H19. case H19. case H19.
    % what if the dirt is full?
    search.
  % backchain
  apply ctx_e2m_member to _ H19. case H20. case H18. case H18. case H18. case H18. case H18.
  % DO -> LET
  apply IH1 to _ H3.
  case H5. % how was the A ! 0 translated?
    % it was A' - interesting case
    apply IH1 to _ H4 with Ctx_m = (ml/of_term Sig_ml n2 T :: Ctx_m).
    apply ml/strengthen_comp_ty to _ H8.
    apply e2m/preserve_wf_comp_ty to _ H10. search.
    % 0 was full
    case H7.
    apply ctx_e2m_member to _ H10. case H11. case H9. case H9. case H9. case H12. case H9. case H9.
    % it came from the context
    apply ctx_e2m_member to _ H8. case H9. case H7. case H7. case H7. case H7. case H7.
  % DO -> DO
  apply IH1 to _ H3.
  case H5. % how was the A ! FullDirt translated?
    % it was comp_ty A' - interesting case
    apply IH1 to _ H4 with Ctx_m = (ml/of_term Sig_ml n2 T :: Ctx_m), Sig_ml = Sig_ml.
    .
  case H5.

%   .
% % SKELETON LAMBDA
% apply IH to _ H3.
% exists T.
% split.
% search.
% search.
% % SKELETON APPLY
% apply IH to _ H3.
% exists T.
% split..
% case H4.
% inst H6 with n1 = S.
% search.
% %
