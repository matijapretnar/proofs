Specification "exp2ml".
Import "common".
Import "proof-exp2ml-lemmas".
Import "proof-exp2ml-preserves-typing".
Set subgoals off.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem step_normal :
  forall Sig_m Ctx_m V V' A,
  m/ctx Sig_m Ctx_m ->
  {Ctx_m |- ml/step V V'} -> {Ctx_m |- ml/normal V' A} -> {Ctx_m |- ml/normal V A}.
induction on 3. intros Hctx. case H2.
  search.
  search.
  search.
  search.
  assert {Ctx_m |- ml/converges V}.
  assert {Ctx_m, ml/wf_ty n1 |- ml/step (ml/app_ty V n1) (ml/app_ty V' n1)}.
  apply IH to _ H6 H4. search.
  assert {Ctx_m |- ml/converges V}.
  assert {Ctx_m, ml/of_coer n1 (ml/ty_coer_ty A3 A2) |- ml/step (ml/app_coer V n1) (ml/app_coer V' n1)}.
  apply IH to _ H8 H6. search.
  apply m_ctx_m_member to Hctx H4. case H5. case H3. case H3. case H3.

Theorem normal_converges : forall V A,
  {ml/normal V A} -> {ml/converges V}.
intros. case H1.
  search.
  search.
  search.
  search.
  search.
  search.

Theorem e2m/val_normal : 
    forall Sig_e Sig_m Ctx_e2m Ctx_m V A V' A',
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    {Ctx_e2m |- e2m/val Sig_e V A V'} ->
    {Ctx_m |- ml/of_term Sig_m V' A'} ->
    {Ctx_m |- ml/normal V' A'}.
induction on 2. intros Hctx.
    % A small lemma before we proceed.
    member_lemma :
        assert forall F T' A', {Ctx_m, [F] |- ml/of_term' Sig_m T' A'} -> member F Ctx_m -> false.
        intros. apply ctx_m_member to Hctx H4. case H5.
        case H3. case H3. case H3.
    % QED
    case H2 (keep).
    case H1.
    % UNIT
    case H4. search. apply member_lemma to H5 H6.
    % FUN
    case H4. search. apply member_lemma to H7 H8.
    % HANDLER
    case H5.
        case H4. search. apply member_lemma to H8 H9.
        apply ctx_e2m_member to Hctx H7. case H8. case H6. case H6. case H6. case H6. case H6.
        case H4. search. apply member_lemma to H7 H8.
    % SKELETON LAMBDA
    apply IH to Hctx H5 H2. search.
    % SKELETON APPLY
    apply IH to Hctx H5 H2. search.
    % VALUE TY LAMBDA
    case H4.
        inst H6 with n1 = n2.
        apply IH to _ H5 H7.
        assert {Ctx_m, ml/wf_ty n2 |- ml/step (ml/app_ty (ml/lam_ty Vm) n2) (Vm n2)}.
        apply e2m_to_m_context to Hctx.
        apply step_normal to _ H9 H8.
        search.
    apply member_lemma to H6 H7.
    % VALUE TY APPLY
    case H4.
        apply IH to _ H5 H7.
        case H9.
        inst H11 with n1 = Am1.
        cut H12.
        search.
    apply ctx_m_member to _ H11. case H12.
        case H10. case H10. case H10.
    apply member_lemma to H7 H8.
    % DIRT LAMBDA
    apply IH to _ H5 H2. search.
    % DIRT APPLY
    skip. % from_impure.
    % COERCION LAMBDA
        % val
        case H4.
        inst H8 with n1 = n2.
        apply IH to _ H5 H9.
        assert {Ctx_m, ml/of_coer n2 (ml/ty_coer_ty A1' A2') |- ml/step (ml/app_coer (ml/lam_coer (ml/ty_coer_ty A1' A2') Vm) n2) (Vm n2)}.
        apply e2m_to_m_context to Hctx.
        apply e2m/preserve_wf_val_ty to _ H6.
        apply e2m/preserve_wf_val_ty to _ H7.
        apply step_normal to _ H11 H10.
        search.
        apply member_lemma to H8 H9.
        % comp
        case H4.
        inst H8 with n1 = n2.
        apply IH to _ H5 H9.
        assert {Ctx_m, ml/of_coer n2 (ml/ty_coer_ty C1' C2') |- ml/step (ml/app_coer (ml/lam_coer (ml/ty_coer_ty C1' C2') Vm) n2) (Vm n2)}.
        apply e2m_to_m_context to Hctx.
        apply e2m/preserve_wf_comp_ty to _ H6.
        apply e2m/preserve_wf_comp_ty to _ H7.
        apply step_normal to _ H11 H10.
        search.
        apply member_lemma to H8 H9.
        % dirt
        apply IH to _ H5 H2. search.
    % COERCION APPLY
    % val
    case H4.
        apply IH to Hctx H5 H7.
        case H9. inst H13 with n1 = Y'.
        cut H14.
        search.
        % bakchain
        apply ctx_m_member to _ H11. case H12. case H10. case H10. case H10.
    apply member_lemma to H7 H8.
    % comp
    case H4.
        apply IH to Hctx H5 H7.
        case H9. inst H13 with n1 = Y'.
        cut H14.
        search.
        % bakchain
        apply ctx_m_member to _ H11. case H12. case H10. case H10. case H10.
    apply member_lemma to H7 H8.
    % dirt
    apply IH to Hctx H5 H2. search.
    % VALUE COERCION
    case H4.
        skip. % if V is normal, so is cast V
        apply member_lemma to H7 H8.
    % VARIABLE CASE
    apply ctx_e2m_member to Hctx H6. case H7.
        case H5. case H9. case H4. apply member_lemma to H11 H12.
        case H5.
        case H5.
        case H5.
        case H5.
    skip. % variables are normal

Define ml/cong : ml/term -> ml/term -> prop by
    % 1
    ml/cong T1 T2 := {ml/step T1 T2};
    % 2
    ml/cong T T;
    % 3
    ml/cong T1 T2 := ml/cong T2 T1;
    % 4
    ml/cong T1 T3 := exists T2, ml/cong T1 T2 /\ ml/cong T2 T3;
    % 5
    ml/cong T1 T2 := exists T T1' T2', T1 = T T1' /\ T2 = T T2' /\ ml/cong T1' T2'.

Theorem converges_cong_result :
  forall V, {ml/converges V} -> exists V', {ml/val V'} /\ ml/cong V V'.
induction on 1. intros. case H1.
  search.
  apply IH to H3. search.

Theorem val_cong_result :
  forall Sig_e Sig_m V A V' A',
    {e2m/sig Sig_e Sig_m} ->
    {e2m/val Sig_e V A V'} ->
    {ml/of_term Sig_m V' A'} ->
    exists V'', {ml/val V''} /\ ml/cong V' V''.
intros.
  apply e2m/val_normal to _ H2 H3.
  apply normal_converges to H4.
  apply converges_cong_result to H5.
  search.

Theorem result_val_val :
  forall Sig_e Sig_m V A T, {e2m/sig Sig_e Sig_m} -> {exp/result_val V} -> {e2m/val Sig_e V A T} -> exists T', {ml/val T'} /\ ml/cong T T'.
intros.
apply e2m/of_val to _ H3.
apply val_cong_result to _ H3 H5.
search.

% Theorem e2m/get_ret_case :
%   forall Ht Ct Vt He Ce Vm,
%     {exp/get_ret_case Ht Ct} -> {e2m/hand Ht He} -> {e2m/comp (Ct Vt) Ce} -> {e2m/val Vt Vm} ->
%     exists Ce', {ml/get_ret_case He Ce'} /\ Ce = Ce' Vm.
% induction on 1. intros. case H1.
%   case H2.
%     exists Ce1. inst H5 with n1 = Vt, n2 = Vm. cut H7 with H4.
%     apply unique_e2m/comp to _ H3 H8. search.
%   case H2.
%     apply IH to H5 H6 H3 H4.
%     search.

% Theorem e2m/get_op_case :
%   forall Ht O At Ct Vt Kt He Ae Ce Vm Ke,
%     {exp/get_op_case Ht O At Ct} -> {e2m/hand Ht He} -> {e2m/comp (Ct Vt Kt) Ce} -> {e2m/val Vt Vm} ->
%     {exp/skel_val_ty At Ae} -> {e2m/val Kt Ke} ->
%     exists Ce', {ml/get_op_case He O Ae Ce'} /\ Ce = Ce' Vm Ke.
% induction on 1. intros. case H1.
%   case H2.
%     case H3.
%     exists (x\ k\ ml/op O x Ae (y\ ml/app k y)).
%     apply unique_e2m/val to _ H4 H9.
%     apply unique_skel_val_ty to _ H5 H10.
%     case H11.
%     monotone H6 with e2m/val n1 n2 :: nil.
%     apply unique_e2m/val to _ H12 H14.
%     assert {e2m/val n1 n2 |- e2m/val n1 n2}.
%     apply unique_e2m/val to _ H13 H15. search.
%     case H13. case H12. case H14.
%   case H2.
%     inst H9 with n1 = Vt, n2 = Vm, n3 = Kt, n4 = Ke.
%     cut H10 with H4. cut H11 with H6.
%     apply unique_e2m/comp to _ H3 H12. search.
%   case H2.
%     apply IH to H8 H9 H3 H4 H5 H6. search.

Theorem big_lemma_1 : (
    forall Sig_e Ctx_e2m Ctx_t V A T1 D Y,
    e2m/ty_ctx Sig_e Ctx_e2m Ctx_t ->
    {Ctx_t |- from_impure/val A D Y} ->
    nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/val Sig_e (V d) (A d) T1} ->
    exists T2, {Ctx_e2m |- e2m/val Sig_e (V D) (A D) T2} /\ ml/cong (ml/cast T1 Y) T2
) /\ (
    forall Sig_e Ctx_e2m Ctx_t V A T1 D Y,
    e2m/ty_ctx Sig_e Ctx_e2m Ctx_t ->
    {Ctx_t |- to_impure/val A D Y} ->
    nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/val Sig_e (V d) (A d) T1} ->
    exists T2, {Ctx_e2m |- e2m/val Sig_e (V D) (A D) T2} /\ ml/cong (ml/cast T2 Y) T1
) /\ (
    forall Sig_e Ctx_e2m Ctx_t C A T1 D Y,
    e2m/ty_ctx Sig_e Ctx_e2m Ctx_t ->
    {Ctx_t |- from_impure/comp A D Y} ->
    nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/comp Sig_e (C d) (A d) T1} ->
    exists T2, {Ctx_e2m |- e2m/comp Sig_e (C D) (A D) T2} /\ ml/cong (ml/cast T1 Y) T2
) /\ (
    forall Sig_e Ctx_e2m Ctx_t C A T1 D Y,
    e2m/ty_ctx Sig_e Ctx_e2m Ctx_t ->
    {Ctx_t |- to_impure/comp A D Y} ->
    nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/comp Sig_e (C d) (A d) T1} ->
    exists T2, {Ctx_e2m |- e2m/comp Sig_e (C D) (A D) T2} /\ ml/cong (ml/cast T2 Y) T1
).
% induction on 3 3 3 3. split.

% % from_impure/val
% intros Hctx. case H2.
%   % unit
%   skip.
%   % functions
%   case H1.
%   monotone H4 with e2m/full_dirt n1 :: e2m/val Sig_e n2 (A1 n1) n3 :: Ctx_e2m.
%     skip.
%     apply IH2 to _ H6.
%   .case H3.. case H4. case H2.
%         intros. case H10. search. case H11. search. search.
%     apply IH2 to _ H10 H9 with A = (z\ A3 n1 z), C = (z\ V2 z n1 n2).
%       skip. % ctx
%       exists (ml/fun ())
%       split.
%         search.

      
%     .
%   case H3. case H4. case H2.
%     % interesting case
%     assert (e2m/ty_ctx (Sig_e n1) (e2m/full_dirt n1 :: e2m/val (Sig_e n1) n2 (A2 n1 n1) n3 :: Ctx_e2m n1) (Ctx_t n1)). skip.
%     apply IH2 to H11 H10 H9.
% skip.
% induction on 2. intros. case H2.
%   % unit
%   case H4. case H5. case H3. case H1. case H6.
%     search.
%     case H8. case H7. case H9.
%   % fun
%   case H4. case H5. case H3. case H1. case H11.
%     apply IH
    skip.
Split big_lemma_1 as big_lemma_1a, big_lemma_1b, big_lemma_1c, big_lemma_1d.

Theorem big_lemma_2 : (
    forall Sig_e Ctx_e2m Ctx_t V V' A1 A2 D Y Yi1 Yi2 YF,
    e2m/ty_ctx Sig_e Ctx_e2m Ctx_t ->
    {Ctx_e2m |- e2m/val Sig_e V (exp/all_dirt A1) V'} ->
    {Ctx_t |- from_impure/val A1 D Yi1} ->
    {Ctx_t |- from_impure/val A2 D Yi2} ->
    nabla d, {Ctx_e2m, e2m/full_dirt d |- e2m/coer (Y d) (exp/val_ty_coer_ty (A1 d) (A2 d)) YF} ->
    exists YD, {Ctx_e2m |- e2m/coer (Y D) (exp/val_ty_coer_ty (A1 D) (A2 D)) YD} /\
    ml/cong (ml/cast (ml/cast V' YF) Yi2) (ml/cast (ml/cast V' Yi1) YD)
).
skip.


Theorem still_congruence :
  forall T1 T2 T,
  ml/cong T1 T2 ->
  ml/cong (T T1) (T T2).
% PROOF
intros.
unfold 5. exists T. search.
% QED

Theorem step_congruence :
  forall T1 T2 T T',
  ml/cong T1 T2 ->
  {ml/step (T T2) (T' T2)} ->
  ml/cong (T T1) (T' T1).
% PROOF
intros.
unfold 4. exists T T2. split.
unfold 5. exists T. search.
unfold 4. exists T' T2. split.
unfold 1. search.
unfold 5. exists T'. search.
% QED


Theorem e2m/val_preservation :
  forall Sig_e Sig_m V1 V2 A T1,
    {e2m/sig Sig_e Sig_m} -> 
    {exp/step_val V1 V2} -> {e2m/val Sig_e V1 A T1} ->
    exists T2, {e2m/val Sig_e V2 A T2} /\ ml/cong T1 T2.
induction on 2. intros Hsig. case H1 (keep).
% COERCE
case H2. apply IH to Hsig H3 H4.
apply still_congruence to _ with T = (t\ ml/cast t Ym). search.
% CAST UNIT_REFL_COER
case H2. case H5. apply result_val_val to _ H3 H4.
    apply step_congruence to H7 _ with
        T = (t\ ml/cast t ml/unit_refl_coer),
        T' = (t\ t).
    search.
% APP_SKEL
case H2. apply IH to Hsig H3 H4. search.
% APP_TY
case H2. apply IH to Hsig H3 H4.
apply still_congruence to _ with T = (t\ ml/app_ty t Am1). search.
% APP_DIRT
case H2.
apply IH to Hsig H3 H5.
apply still_congruence to _ with T = (t\ ml/cast t Y). search.
% APP_COER
case H2.
    % val coer
    apply IH to Hsig H3 H4.
    apply still_congruence to _ with T =  (t\ ml/app_coer t Y').
    search.
    % comp coer
    apply IH to Hsig H3 H4.
    apply still_congruence to _ with T =  (t\ ml/app_coer t Y').
    search.
    % dirt coer
    apply IH to Hsig H3 H4. search.
% coerced APP_SKEL
case H2. case H4.
case H6.
inst H7 with n1 = S. search.
% coerced APP_TY
case H2. case H4. case H7.
apply result_val_val to _ H3 H6.
apply step_congruence to H10 _ with
    T = (t\ ml/app_ty (ml/cast t (ml/lam_ty_coer Y')) Am1),
    T' = (t\ ml/cast (ml/app_ty t Am1) (Y' Am1)).
inst H8 with n1 = A1, n2 = Am1.
cut H12.
exists (ml/cast (ml/app_ty Vm1 Am1) (Y' Am1)).
search.
% coerced APP_DIRT
case H2. case H5. case H7.
assert exists Y, {from_impure/val A1 D Y}.
  skip.
case H9.
apply big_lemma_2 to _ H6 H10 H4 with Sig_e = Sig_e, Ctx_e2m = nil, Ctx_t = nil, V = V, V' = Vm1, A1 = A1, A2 = At, D = D, Y = Y, Yi1 = Y2, Yi2 = Y1, YF = Ym.
apply H11 to H8.
search.
% coerced APP_COER
case H2.
% val
case H4.
apply result_val_val to _ H3 H6.
case H7.
apply step_congruence to H9 _ with
    T = (t\ ml/app_coer (ml/cast t (ml/lam_coer_coer (ml/ty_coer_ty A3' A4') Y'1)) Y'),
    T' = (t\ ml/cast (ml/app_coer t Y') Y'1).
    search.
% comp
case H4.
apply result_val_val to _ H3 H6.
case H7.
apply step_congruence to H9 _ with
    T = (t\ ml/app_coer (ml/cast t (ml/lam_coer_coer (ml/ty_coer_ty C1' C2') Y'1)) Y'),
    T' = (t\ ml/cast (ml/app_coer t Y') Y'1).
    search.
% dirt
case H4.
case H7.
search.
% APP_SKEL reduce
case H2. case H3. inst H4 with n1 = S. search.
% APP_TY reduce
case H2. case H4. inst H6 with n1 = A1, n2 = Am1. cut H7. search.
% APP_DIRT reduce
case H2. case H4.
apply big_lemma_1a to _ H3 with Sig_e = Sig_e, Ctx_e2m = nil, Ctx_t = nil, V = M, A = At, T1 = Vm, D = A1.
apply H6 to H5.
search.
% APP_COER reduce
case H2.
    % val coer
    case H3. inst H5 with n1 = A1, n2 = Y'. cut H8. search.
    % comp coer
    case H3. inst H5 with n1 = A1, n2 = Y'. cut H8. search.
    % dirt coer
    case H3. inst H5 with n1 = A1. search.

% Theorem e2m/extract_value : forall Ce Cs Vm, {exp/extract_value Ce Vm} -> {e2m/comp Ce Cs} -> exists Vs, Cs = ml/ret Vs /\ {e2m/val Vm Vs}.
% induction on 1. intros. case H1.
%   case H2. apply IH to H3 H4. search.
%   case H2. search.

Theorem in_less_dirt :
  forall O Y D1 D2, {in_dirt O D1} -> {exp/of_coer Y (exp/dirt_coer_ty D1 D2)} -> {in_dirt O D2}.
induction on 1. intros. case H1.
 case H2. search. search.
 case H2. search. apply IH to H3 H4. search.

Theorem e2m/extract_value :
    forall Sig_e C V A T,
    {exp/extract_value C V} ->
    {e2m/comp Sig_e C (exp/bang A empty) T} ->
    {e2m/val Sig_e V A T}.
% PROOF
induction on 1. intros. case H1.
    case H2. case H5. case H8. case H10. case H9. apply IH to H3 H4. search.
    case H2. search.
% QED

Theorem e2m/extract_impure_value :
    forall Sig_e C V A D T,
    {exp/extract_value C V} ->
    {e2m/comp Sig_e C (exp/bang A D) T} ->
    {e2m/full_dirt D} ->
    exists V', {e2m/val Sig_e V A V'} /\ ml/cong T (ml/ret V').
% PROOF
induction on 1. intros. case H1.
  case H2. case H6. case H9.
    % full -> full
    apply IH to H4 H5 H10.
    exists (ml/cast V' Y1'). split.
        search.
        unfold 4. exists (ml/cast (ml/ret V') (ml/comp_ty_coer Y1')). split.
        unfold 5. exists (t\ ml/cast t (ml/comp_ty_coer Y1')). search.
        assert {ml/val V'}. skip.
        unfold 1. search.
    % empty -> full
    apply e2m/extract_value to H4 H5.
    exists (ml/cast Cm Y1'). split.
        search.
        assert {ml/val Cm}. skip.
        unfold 1. search.
    % empty -> empty
    case H3.
  case H2. case H3.
% QED

Theorem e2m/comp_preservation :
  forall Sig_e Sig_m C1 C2 B T1,
    {e2m/sig Sig_e Sig_m} ->
    {exp/step_comp C1 C2} -> {e2m/comp Sig_e C1 B T1} ->
    exists T2, {e2m/comp Sig_e C2 B T2} /\ ml/cong T1 T2.
induction on 2. intros Hsig. case H1.
% COERCE
case H2. apply IH to _ H3 H4.
apply still_congruence to _ with T =  (t\ ml/cast t Ym).
search.
% APP V1-step
case H2. apply e2m/val_preservation to Hsig H3 H4.
apply still_congruence to _ with T =  (t\ ml/app t Vm2).
search.
% APP V1-exp/coer
case H2. case H4. case H7.
apply result_val_val to _ H3 H6.
apply step_congruence to H11 _ with
    T = (t\ ml/app (ml/cast t (ml/fun_coer Y1' Y2')) Vm2),
    T' = (t\ ml/cast (ml/app t (ml/cast Vm2 Y1')) Y2').
search.
% APP V2-step
case H2. apply e2m/val_preservation to Hsig H4 H6.
apply still_congruence to _ with T =  (t\ ml/app Vm1 t). search.
% APP beta
case H2.
case H4.
apply result_val_val to _ H3 H5.
inst H7 with n1 = V, n2 = Vm2.
cut H10.
apply step_congruence to _ _ with
    T = (t\ ml/app (ml/fun Aml Cml) t),
    T' = Cml.
search.
% LET V-step
case H2.
apply e2m/val_preservation to Hsig H3 H4.
apply still_congruence to _ with T = (t\ ml/let t Cm). search.
% LET beta
case H2.
apply result_val_val to _ H3 H4.
inst H5 with n1 = V, n2 = Vm. cut H8.
apply step_congruence to _ _ with
    T = (t\ ml/let t Cm),
    T' = Cm.
search.
% RETURN V-step
case H2. apply e2m/val_preservation to Hsig H3 H4. search.
% OP V-step
case H2. apply e2m/val_preservation to Hsig H3 H7.
apply still_congruence to _ with T = (t\ ml/op O t Am2 Cm). search.
% OP-coerce
case H2. case H4. case H5.
case H15. % what does the dirt coercion look like?
    % it works on computations as expected.
    apply result_val_val to _ H3 H9.
    apply in_less_dirt to H11 H14.
    apply step_congruence to _ _ with
        T = (t\ ml/cast (ml/op O t Am2 Cm1) (ml/comp_ty_coer Y1')),
        T' = (t\ ml/op O t Am2 (y\ml/cast (Cm1 y) (ml/comp_ty_coer Y1'))).
    search.
    % it is between pure and full dirt - wrong because we have an operation in here
    case H11.
    % it is between pure and pure dirt - wrong because we have an operation in here
    case H11.
% DO C1-step
case H2.
    % DO ~> LET
    apply IH to _ H3 H4.
    apply still_congruence to _ with T = (t\ ml/let t Cm2). search.
    % DO ~> DO
    apply IH to _ H3 H4.
    apply still_congruence to _ with T = (t\ ml/do t Cm2). search.
% DO ret
case H2.
    % DO ~> LET
    apply e2m/extract_value to H3 H5. inst H6 with n1 = V, n2 = Cm1.
    cut H8.
    apply result_val_val to _ H4 H7.
    apply step_congruence to _ _ with
        T = (t\ ml/let t Cm2),
        T' = Cm2.
    search.
    % DO ~> DO
    apply e2m/extract_impure_value to H3 H5 _.
    inst H6 with n1 = V, n2 = V'.
    cut H9.
    apply result_val_val to _ H4 H7.
    exists (Cm2 V'). split.
        search.
    apply step_congruence to _ _ with
        T = (t\ ml/do (ml/ret t) Cm2),
        T' = Cm2.
    unfold 4. exists (ml/do (ml/ret V') Cm2). split.
    unfold 5. exists (t\ ml/do t Cm2). search.
    search.
% DO op
case H2.
    % DO ~> LET (not possible because we have an operation)
    case H4. case H11.
    % DO ~> DO
    case H4.
    apply result_val_val to _ H3 H9.
    apply step_congruence to _ _ with
        T = (t\ ml/do (ml/op O t Am2 Cm) Cm2),
        T' = (t\ ml/op O t Am2 (y\ml/do (Cm y) Cm2)).
    search.
% WITH val-step
case H2.
    % WITH ~> APP
    skip.
    % WITH ~> UNSAFE WITH
    skip.
    % WITH ~> WITH
    skip.
% WITH handler cast
case H2.
    % WITH ~> APP
    skip.
    % WITH ~> UNSAFE WITH
    skip.
    % WITH ~> WITH
    skip.
% WITH C step
case H2.
    % WITH ~> APP
    apply IH to _ H4 H5.
    apply still_congruence to _ with T = (t\ ml/app V' t).
    search.
    % WITH ~> UNSAFE WITH
    apply IH to _ H4 H5.
    apply still_congruence to _ with T = (t\ ml/cast (ml/with t V') (ml/unsafe_coer Y)).
    search.
    % WITH ~> WITH
    apply IH to _ H4 H5.
    apply still_congruence to _ with T = (t\ ml/with t V').
    search.
% WITH return
case H2.
    % WITH ~> APP
    skip.
    % WITH ~> UNSAFE WITH
    skip.
    % WITH ~> WITH
    skip.
% WITH op
case H2.
    % WITH ~> APP
    skip.
    % WITH ~> UNSAFE WITH
    skip.
    % WITH ~> WITH
    skip.
