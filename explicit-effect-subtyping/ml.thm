Specification "ml".
Import "common".

Close ml/ty, ml/coer_ty.

Set subgoals off.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem ml/of_op_unique : forall Sig O A A' B B',
  {ml/of_op Sig O A B} -> {ml/of_op Sig O A' B'} -> A = A' /\ B = B'.
induction on 1. intros. case H1.
  case H2. search. apply apart_not_reflexive to H4.
  case H2.
    apply apart_not_reflexive to H4.
    apply IH to H3 H5. search.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem ml/less_ty_reflexive:
  forall A, {ml/wf_ty A} -> {ml/less_ty A A}.
induction on 1. intros. case H1.
  search.
  apply IH to H2. apply IH to H3. search.
  apply IH to H2. search.
  apply IH to H2. apply IH to H3. search.
  apply IH to H3. search.
  apply IH to H2. search.

Theorem ml/less_ty_transitive' :
  (forall A B C, {ml/less_ty A B} -> {ml/less_ty B C} -> {ml/less_ty A C}) /\
  (forall A B C, {ml/less_ty B C} -> {ml/less_ty A B} -> {ml/less_ty A C}).
induction on 1 1. induction on 2 2. split.
intros. case H1 (keep).
  search.
  case H2 (keep). 
    apply IH1 to H3 H5. apply IH to H4 H6. search. 
    apply IH2 to H1 H5. search.
  case H2 (keep). 
    apply IH1 to H3 H5. apply IH to H4 H6. search. 
    apply IH1 to H3 H5. apply IH to H4 H6. search. 
    apply IH2 to H1 H5. search.
  case H2 (keep).
    apply IH1 to H3 H5. apply IH to H4 H6. search. 
    apply IH2 to H1 H5. search.
  case H2 (keep).
    apply IH to H3 H4. search.
    apply IH2 to H1 H4. search.
  case H2 (keep).
    apply IH to H3 H4. search.
    apply IH2 to H1 H4. search.
  case H2 (keep).
    apply IH to H3 H4. search.
    apply IH2 to H1 H4. search.
    apply IH to H3 H4. search.
  case H2 (keep).
    apply IH to H3 H4. search.
    apply IH2 to H1 H4. search.
    apply IH to H3 H4. search.
  apply IH to H3 H2. search.

intros. case H1 (keep).
  search.
  case H2 (keep). 
    apply IH to H3 H5. apply IH1 to H4 H6. search. 
    apply IH to H3 H5. apply IH1 to H4 H6. search.
    apply IH3 to H1 H5. search.
  case H2 (keep). 
    apply IH to H3 H5. apply IH1 to H4 H6. search. 
    apply IH3 to H1 H5. search.
  case H2 (keep).
    apply IH to H3 H5. apply IH1 to H4 H6. search. 
    apply IH3 to H1 H5. search.
  case H2 (keep).
   apply IH1 to H3 H4. search.
   apply IH3 to H1 H4. search.
  case H2 (keep).
   apply IH1 to H3 H4. search.
   apply IH3 to H1 H4. search.
  case H2 (keep).
   apply IH1 to H3 H4. search.
   apply IH1 to H3 H4. search.
   apply IH3 to H1 H4. search.
   apply IH1 to H3 H2. search.
  case H2 (keep).
   apply IH1 to H3 H4. search.
   apply IH1 to H3 H4. search.
   apply IH3 to H1 H4. search.

Split ml/less_ty_transitive' as ml/less_ty_transitive, forget.

Theorem ml/less_comp_ty :
  forall A B, {ml/less_ty (ml/comp_ty A) B} -> {ml/less_ty A B}.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.
  search.

Theorem ml/comp_ty_less :
  forall A B, {ml/less_ty A (ml/comp_ty B)} -> {ml/less_ty A B}.
induction on 1. intros. case H1.
  search.
  search.
  apply IH to H2. search.

Theorem ml/coer_less_ty :
  forall Y A B, {ml/of_coer Y (ml/ty_coer_ty A B)} -> {ml/less_ty A B}.
induction on 1.
intros. case H1. case H3.
  apply IH to H4. apply IH to H5. apply ml/less_ty_transitive to H6 H7. search.
  case H2. apply ml/less_ty_reflexive to H4. search.
  apply IH to H4. apply IH to H5. search.
  apply IH to H4. apply IH to H5. search.
  apply IH to H4. apply IH to H5. search. 
  apply IH to H4. case H5. search.
  apply IH to H4. case H5. search.
  apply IH to H4. case H5. search.
  apply IH to H4. case H5. search.
  apply IH to H4. case H5. inst H6 with n1 = A3. search.
  apply IH to H4. case H6. search.
  apply IH to H4. search. 
  apply IH to H4. search. 
  apply IH to H4. search. 
  apply IH to H4. case H5.
    search.
    apply ml/less_comp_ty to H6.  search.
    apply ml/comp_ty_less to H6. search.
    apply IH to H4. apply ml/comp_ty_less to H5. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem of/valcase : forall Sig H A C M,
    {ml/of_hand Sig H A C} -> {ml/get_ret_case H M} -> nabla x, {ml/of_term Sig x A |- ml/of_term Sig (M x) C}.

induction on 2. intros. case H2.
  case H1. search.
  case H1. apply IH to H4 H3. search.

Theorem of/ml/op_case : forall Sig O A1 A2 H A B M,
     {ml/of_hand Sig H A (ml/comp_ty B)} ->
     {ml/get_op_case H O A2 M} ->
     {ml/of_op Sig O A1 A2} ->
     {is_op O} ->
     nabla x, nabla k, {ml/of_term Sig x A1, ml/of_term Sig k (ml/fun_ty A2 (ml/comp_ty B)) |- ml/of_term Sig (M x k) (ml/comp_ty B)}.
induction on 2. intros. case H2.
  case H1. search.
  case H1. apply ml/of_op_unique to H3 H7. search.
  case H1.  apply IH to H7 H6 H3 H4.search.

Theorem ml/preservation : forall Sig V V' A, {ml/step V V'} -> {ml/of_term Sig V A} -> {ml/of_term Sig V' A}.
induction on 1. intros. case H1.
% CAST
case H2. apply IH to H3 H4. search.
% COMPOSE
case H2. case H4. search.
% APP_TY
case H2. apply IH to H3 H4. search.
% APP_COER
case H2. apply IH to H3 H4. search.
% coerced APP_TY
case H2. case H4. % apply exp/coer_less_val_ty to H7. case H8. search.
