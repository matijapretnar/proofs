Specification "exp2ml".
Import "common".

Close exp/sig, exp/comp_ty, exp/coer_ty, exp/val_ty.
Close ml/sig, ml/ty, ml/term, ml/coer_ty, ml/hand, ml/coer, op.
Close dirt.

Set subgoals off.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contexts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define e2m/ctx : exp/sig -> ml/sig -> olist -> olist -> prop by

  e2m/ctx Sig_e Sig_m nil nil
    := {e2m/sig Sig_e Sig_m};

  nabla x x', e2m/ctx Sig_e Sig_m
    (e2m/val Sig_e x A x' :: Ctx_e2m)
    (ml/of_term Sig_m x' A' :: Ctx_m)
    := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ exists S, {Ctx_e2m |- e2m/val_ty A S A'};

   nabla t t', e2m/ctx Sig_e Sig_m
     (e2m/val_ty t S t' :: Ctx_e2m)
     (ml/wf_ty t' :: Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m;

   nabla d, e2m/ctx Sig_e Sig_m
     (e2m/full_dirt d :: Ctx_e2m)
     (Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m;

   nabla w w', e2m/ctx Sig_e Sig_m
     (e2m/coer w (exp/val_ty_coer_ty A1 A2) w' :: Ctx_e2m)
     (ml/of_coer w' (ml/ty_coer_ty A1' A2') :: Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ exists S, {Ctx_e2m |- e2m/val_ty A1 S A1'} /\ {Ctx_e2m |- e2m/val_ty A2 S A2'};

   nabla w w', e2m/ctx Sig_e Sig_m
     (e2m/coer w (exp/comp_ty_coer_ty C1 C2) w' :: Ctx_e2m)
     (ml/of_coer w' (ml/ty_coer_ty C1' C2') :: Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ exists S, {Ctx_e2m |- e2m/comp_ty C1 S C1'} /\ {Ctx_e2m |- e2m/comp_ty C2 S C2'}.

Define m/ctx : ml/sig -> olist -> prop by

  m/ctx Sig_m nil;

  nabla x, m/ctx Sig_m (ml/of_term Sig_m x A :: Ctx_m)
    := m/ctx Sig_m Ctx_m /\ {Ctx_m |- ml/wf_ty A};

   nabla t, m/ctx Sig_m (ml/wf_ty t :: Ctx_m)
     := m/ctx Sig_m Ctx_m;

   nabla w, m/ctx Sig_m (ml/of_coer w (ml/ty_coer_ty A1 A2) :: Ctx_m)
     := m/ctx Sig_m Ctx_m /\ {Ctx_m |- ml/wf_ty A1} /\ {Ctx_m |- ml/wf_ty A2};

   nabla w, m/ctx Sig_m
     (ml/of_coer w (ml/ty_coer_ty C1 C2) :: Ctx_m)
     := m/ctx Sig_m Ctx_m /\ {Ctx_m |- ml/wf_ty C1} /\ {Ctx_m |- ml/wf_ty C2}.

Define e2m/ty_ctx : exp/sig -> olist -> olist -> prop by

  e2m/ty_ctx Sig_e nil nil;

  nabla x x', e2m/ty_ctx Sig_e
    (e2m/val Sig_e x (A Df) x' :: Ctx_e2m)
    Ctx_t
    := e2m/ty_ctx Sig_e Ctx_e2m Ctx_t /\ {Ctx_e2m |- e2m/full_dirt Df}.

Theorem ctx_e2m_member: 
  forall Sig_e Sig_m Ctx_e2m Ctx_m F,
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    member F Ctx_e2m ->
      (exists X A X' A' S,
         fresh X /\ fresh X' /\ (F = e2m/val Sig_e X A X') /\ {Ctx_e2m |- e2m/val_ty A S A'})
      \/
      (exists T T' S,
         fresh T /\ fresh T' /\ (F = e2m/val_ty T S T') /\ member (ml/wf_ty T') Ctx_m)
      \/
      (exists D,
         fresh D /\ (F = e2m/full_dirt D))
      \/
      (exists W W' A1 A2,
         fresh W /\ fresh W' /\ (F = e2m/coer W (exp/val_ty_coer_ty A1 A2) W'))
      \/
      (exists W W' C1 C2,
         fresh W /\ fresh W' /\ (F = e2m/coer W (exp/comp_ty_coer_ty C1 C2) W')).
% PROOF
induction on 1. intros. case H1 (keep).
  case H2.
  case H2.
    search.
    apply IH to H3 H5. case H6.
      search.
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H4. case H5. 
      search. 
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H4. case H5. 
      search. 
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H6. case H7.
      search. 
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H6. case H7. 
      search. 
      search.
      search.
      search.
      search.
% QED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wf_ty preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_wf_ty :
  (forall A A' Sig_e Sig_m Ctx_e2m Ctx_m S, 
     e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m -> {Ctx_e2m |- e2m/val_ty A S A'} -> {Ctx_m |- ml/wf_ty A'}) /\
  (forall C C' Sig_e Sig_m Ctx_e2m Ctx_m S, 
     e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m -> {Ctx_e2m |- e2m/comp_ty C S C'} -> {Ctx_m |- ml/wf_ty C'}).
induction on 2 2. split.

  intros. case H2 (keep).
    search.
    apply IH to _ H3. apply IH1 to _ H4. search.
    apply IH to _ H3. apply IH1 to _ H4. search.
    apply IH to _ H3. apply IH to _ H5. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. apply IH to _ H4. apply IH to _ H5. search.
    apply IH1 to _ H3. apply IH1 to _ H4. apply IH to _ H5. search.
    apply IH to _ H3. search.
    % backchain
    apply ctx_e2m_member to H1 H4. case H5.
      case H3.
      case H3. search.
      case H3.
      case H3.
      case H3.

  intros. case H2 (keep).
    apply IH to _ H3. search.
    apply IH to _ H4. search.
     % backchain
    apply ctx_e2m_member to H1 H4. case H5.
      case H3.
      case H3.
      case H3.
      case H3.
      case H3.
% QED?

Split e2m/preserve_wf_ty as e2m/preserve_wf_val_ty, e2m/preserve_wf_comp_ty.

Theorem e2m_to_m_context :
  forall Sig_e Sig_m Ctx_e2m Ctx_m,
  e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
  m/ctx Sig_m Ctx_m.
induction on 1. intros. case H1.
  search.
  apply IH to H2. apply e2m/preserve_wf_val_ty to _ H3. search.
  apply IH to H2. search.
  apply IH to H2. search.
  apply IH to H2. apply e2m/preserve_wf_val_ty to _ H3. apply e2m/preserve_wf_val_ty to _ H4. search.
  apply IH to H2. apply e2m/preserve_wf_comp_ty to _ H3. apply e2m/preserve_wf_comp_ty to _ H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CTX_M_MEMBER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem m_ctx_m_member: 
  forall Sig_m Ctx_m F,
    m/ctx Sig_m Ctx_m ->
    member F Ctx_m ->
    (exists X' A',
       fresh X' /\ (F = ml/of_term Sig_m X' A'))
    \/
    (exists T',
       fresh T' /\ (F = ml/wf_ty T'))
    \/
    (exists W T T',
      fresh W /\ (F = ml/of_coer W (ml/ty_coer_ty T T')) /\ {Ctx_m |- ml/wf_ty T} /\ {Ctx_m |- ml/wf_ty T'}).
% PROOF
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H5. case H6. search. search. search.
  case H2.
    search.
    apply IH to H3 H4. case H5. search. search. search.
  case H2.
    search.
    apply IH to H3 H6. case H7. search. search. search.
  case H2.
    search.
    apply IH to H3 H6. case H7. search. search. search.
% QED

Theorem ctx_m_member: 
  forall  Sig_e Sig_m Ctx_e2m Ctx_m F,
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    member F Ctx_m ->
    (exists X' A',
       fresh X' /\ (F = ml/of_term Sig_m X' A'))
    \/
    (exists T',
       fresh T' /\ (F = ml/wf_ty T'))
    \/
    (exists W T T',
      fresh W /\ (F = ml/of_coer W (ml/ty_coer_ty T T')) /\ {Ctx_m |- ml/wf_ty T} /\ {Ctx_m |- ml/wf_ty T'}).
% PROOF
intros. apply e2m_to_m_context to H1.
apply m_ctx_m_member to H3 H2. search.
% QED
      
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Strenghtening Lemma
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem ml/full_dirt_strengthen :
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A D, 
         e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
      -> {Ctx_e2m, e2m/val Sig_e n1 A n2 |- e2m/full_dirt D} 
      -> {Ctx_e2m |- e2m/full_dirt D}.
% PROOF
intros. case H2 (keep).
  search.
  case H4.
    case H3.
    apply ctx_e2m_member to H1 H5. case H6. 
      case H3.
      case H3.
      case H3. search.
      case H3.
      case H3.
% QED

Theorem ml/ty_strengthen :
  (
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A B T S, 
         e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
      -> {Ctx_e2m, e2m/val Sig_e n1 A n2 |- e2m/val_ty B S T} 
      -> {Ctx_e2m |- e2m/val_ty B S T}
  ) /\ (
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A C T S,  
         e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m 
      -> {Ctx_e2m, e2m/val Sig_e n1 A n2 |- e2m/comp_ty C S T} 
      -> {Ctx_e2m |- e2m/comp_ty C S T}
  ).
% PROOF
induction on 2 2. split.
  intros. case H2 (keep).
    search.
    apply IH to H1 H3. apply IH1 to H1 H4. search.
    apply IH to H1 H3. apply IH1 to H1 H4. search.
    apply IH to H1 H3. apply IH to H1 H5. apply ml/full_dirt_strengthen to H1 H4. search.
    apply IH to H1 H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. apply IH to _ H4. apply IH to _ H5. search.
    apply IH1 to _ H3. apply IH1 to _ H4. apply IH to _ H5. search.
    apply IH to _ H3. search.
    case H4.
      case H3.
      apply ctx_e2m_member to H1 H5. case H6.
        case H3.
        case H3. search.
        case H3.
        case H3.
        case H3.
  intros. case H2 (keep).
    apply IH to H1 H3. search.
    apply IH to H1 H4. apply ml/full_dirt_strengthen to H1 H3. search.
    case H4.
      case H3.
      apply ctx_e2m_member to H1 H5. case H6.
        case H3.
        case H3.
        case H3.
        case H3.
        case H3.
% QED

Split ml/ty_strengthen as ml/strengthen_val_ty, ml/strengthen_comp_ty.

Theorem member_meaning:
  forall Ctx F,
    member F Ctx -> {Ctx |- F}.
% PROOF
induction on 1. intros. case H1 (keep).
  search.
  apply IH to H2. search.
% QED



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem ml/of_coer_unique:
  forall Y A1 B1 A2 B2,
    {ml/of_coer Y (ml/ty_coer_ty A1 B1)} ->
    {ml/of_coer Y (ml/ty_coer_ty A2 B2)} ->
    A1 = A2 /\ B1 = B2.
% PROOF
induction on 1. intros. case H1. case H2. case H4 (keep).
  case H6. apply IH to H7 H8. search.
  case H6. apply IH to H7 H8. search.
  case H6. apply IH to H7 H8. search.
  case H6. search.
  case H6. apply IH to H7 H9. apply IH to H8 H10. search.
  case H6. apply IH to H7 H9. apply IH to H8 H10. search.
  case H6. apply IH to H7 H9. apply IH to H8 H10. search.
  case H6. skip. % TODO add context % pply IH to H7 H8. search.
  case H6. apply IH to H7 H8. search.
% QED

Theorem e2m/comp_ty_member:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F A A' S, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_e2m, [F] |- e2m/comp_ty A S A'} ->
    member F Ctx_e2m ->
    false.
% PROOF
intros. apply ctx_e2m_member to H1 H3. case H4.
  case H2.
  case H2.
  case H2.
  case H2.
  case H2.
% QED

Theorem e2m/from_impure_val_member:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F A D Y, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_e2m, [F] |- from_impure/val A D Y} ->
    member F Ctx_e2m ->
    false.
% PROOF
intros. apply ctx_e2m_member to H1 H3. case H4.
  case H2.
  case H2.
  case H2.
  case H2.
  case H2.
% QED

Theorem e2m/to_impure_val_member:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F A D Y, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_e2m, [F] |- to_impure/val A D Y} ->
    member F Ctx_e2m ->
    false.
% PROOF
intros. apply ctx_e2m_member to H1 H3. case H4.
  case H2.
  case H2.
  case H2.
  case H2.
  case H2.
% QED

Theorem e2m/from_impure_comp_member:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F C D Y, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_e2m, [F] |- from_impure/comp C D Y} ->
    member F Ctx_e2m ->
    false.
% PROOF
intros. apply ctx_e2m_member to H1 H3. case H4.
  case H2.
  case H2.
  case H2.
  case H2.
  case H2.
% QED

Theorem e2m/to_impure_comp_member:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F C D Y, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_e2m, [F] |- to_impure/comp C D Y} ->
    member F Ctx_e2m ->
    false.
% PROOF
intros. apply ctx_e2m_member to H1 H3. case H4.
  case H2.
  case H2.
  case H2.
  case H2.
  case H2.
% QED

Theorem e2m/full_dirt_empty_member:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_e2m, [F] |- e2m/full_dirt empty} ->
    member F Ctx_e2m ->
    false.
% PROOF
intros. apply ctx_e2m_member to H1 H3. case H4.
  case H2.
  case H2.
  case H2. case H5.
  case H2.
  case H2.
% QED

% Theorem e2m/comp_ty_if_full_member:
%   forall Sig_e Sig_ml Ctx_e2m Ctx_m F C S A, 
%     e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
%     {Ctx_e2m, [F] |- e2m/comp_ty_if_full C S A} ->
%     member F Ctx_e2m ->
%     false.

% intros. apply ctx_e2m_member to H1 H3. case H4.
%   case H2.
%   case H2.
%   case H2. case H5.
%   case H2.
%   case H2.
% % QED

Theorem absurdity[A]:
  forall L E, nabla (x:A), member (E x) L -> exists F, x\ F = E.
% PROOF
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.
% QED

Theorem ml/coer_nominal_absurd: 
  forall L Pi, nabla x,
  member (ml/of_coer x Pi) L -> false.
% PROOF
induction on 1. intros. case H1. apply IH to H2.
% QED

Theorem e2m/val_nominal_absurd: 
  forall B L S, nabla x,
  member (e2m/val_ty x S B) L -> false.
% PROOF
induction on 1. intros. case H1. apply IH to H2.
% QED

Theorem e2m/wf_ty_nominal_absurd: 
  forall L, nabla x,
  member (ml/wf_ty x) L -> false.
% PROOF
induction on 1. intros. case H1. apply IH to H2.
% QED

Theorem e2m/unique_ctx_of_val:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m A B1 B2 S1 S2,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    member (e2m/val_ty A S1 B1) Ctx_e2m ->
    member (e2m/val_ty A S2 B2) Ctx_e2m ->
    B1 = B2 /\ S1 = S2.
% PROOF
induction on 2. intros. case H2 (keep).
  case H3.
    search.
    case H1. apply e2m/val_nominal_absurd to H4.
  case H3.
    case H1. apply e2m/val_nominal_absurd to H4.
    case H1.
      apply IH to _ H4 H5. search.
      apply IH to _ H4 H5. search.
      apply IH to _ H4 H5. search.
      apply IH to _ H4 H5. search.
      apply IH to _ H4 H5. search.
% QED

Theorem e2m/empty_dirt_is_not_full:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m,
  e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
  {Ctx_e2m |- e2m/full_dirt empty} -> false.
intros. case H2. apply e2m/full_dirt_empty_member to _ _ _.

Theorem e2m/empty_dirt_is_not_full_2:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m F,
  e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
  member F Ctx_e2m ->
  {Ctx_e2m, [F] |- e2m/full_dirt empty} -> false.
intros. 
  apply ctx_e2m_member to _ H2. case H4.
    case H3.
    case H3.
    case H3. case H5.
    case H3.
    case H3.

Theorem e2m/wf_of_coer:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m Y A1 A2, 
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m -> 
    {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A1 A2)} ->
    {Ctx_m |- ml/wf_ty A1} /\ {Ctx_m |- ml/wf_ty A2}.
% PROOF
intros. case H2. case H3. search.
apply ctx_m_member to H1 H6. case H7. case H5. case H5. case H5.
apply ctx_m_member to H1 H4. case H5. case H3. case H3. case H3.
search.
% QED

Theorem e2m/of_refl_coer:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m A Y,
  e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
  {Ctx_e2m |- e2m/refl_coer A Y} ->
  {Ctx_m |- ml/of_coer Y (ml/ty_coer_ty A A)}.
induction on 2. intros. case H2.
  search.
  apply IH to _ H3. apply IH to _ H4. apply e2m/wf_of_coer to _ H5. apply e2m/wf_of_coer to _ H6. search.
  apply IH to _ H3. apply e2m/wf_of_coer to _ H4. search.
  apply IH to _ H3. apply IH to _ H4. apply e2m/wf_of_coer to _ H5. apply e2m/wf_of_coer to _ H6. search.
  apply IH to _ H3. apply e2m/wf_of_coer to _ H5. skip.
  skip.
  skip.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem e2m/ty_unique:
  (
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A A1 A2 S1 S2,
      e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
      {Ctx_e2m |- e2m/val_ty A S1 A1} ->
      {Ctx_e2m |- e2m/val_ty A S2 A2} ->
      A1 = A2 /\ S1 = S2
  ) /\
  (
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A A1 A2 S1 S2,
      e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
      {Ctx_e2m |- e2m/comp_ty A S1 A1} ->
      {Ctx_e2m |- e2m/comp_ty A S2 A2} ->
      A1 = A2 /\ S1 = S2
  ).
% PROOF
induction on 2 2. split.
  intros. case H2 (keep).
    case H3. 
      search.
      apply ctx_e2m_member to H1 H5. case H6.
        case H4.
        case H4. case H7.
        case H4.
        case H4.
        case H4.
    case H3.
      apply IH to _ H4 H6. apply IH1 to _ H5 H7. search.
      apply ctx_e2m_member to H1 H7. case H8.
        case H6.
        case H6. case H9.
        case H6.
        case H6.
        case H6.
    case H3.
      apply IH to _ H4 H6. apply IH1 to _ H5 H7. search.
      case H7.
      apply ctx_e2m_member to H1 H10. case H11.
        case H9.
        case H9.
        case H9. case H12.
        case H9.
        case H9.
      apply ctx_e2m_member to H1 H7. case H8.
        case H6.
        case H6. case H9.
        case H6.
        case H6.
        case H6.
    case H3.
      case H5.
      apply ctx_e2m_member to H1 H10. case H11.
        case H9.
        case H9.
        case H9. case H12.
        case H9.
        case H9.
      apply IH to _ H4 H7. apply IH to _ H6 H9. search.
      apply ctx_e2m_member to H1 H8. case H9.
        case H7.
        case H7. case H10.
        case H7.
        case H7.
        case H7.
    case H3.
      apply IH to _ H4 H5. search.
      apply ctx_e2m_member to H1 H6. case H7.
        case H5. 
        case H5. case H8.
        case H5. 
        case H5. 
        case H5. 
    case H3.
      apply IH to _ H4 H5. search.
      apply ctx_e2m_member to H1 H6. case H7.
        case H5. 
        case H5. case H8.
        case H5. 
        case H5. 
        case H5. 
    case H3.
      apply IH to _ H4 H5. search.
      apply ctx_e2m_member to H1 H6. case H7.
        case H5. 
        case H5. case H8.
        case H5. 
        case H5. 
        case H5. 
    case H3.
      apply IH to _ H4 H7. apply IH to _ H5 H8. apply IH to _ H6 H9. search.
      apply ctx_e2m_member to H1 H8. case H9.
        case H7.
        case H7. case H10.
        case H7.
        case H7.
        case H7.
    case H3.
      apply IH1 to _ H4 H7. apply IH1 to _ H5 H8. apply IH to _ H6 H9. search.
      apply ctx_e2m_member to H1 H8. case H9.
        case H7.
        case H7. case H10.
        case H7.
        case H7.
        case H7.
    case H3.
      apply IH to _ H4 H5. search.
      apply ctx_e2m_member to H1 H6. case H7.
        case H5. 
        case H5. case H8.
        case H5. 
        case H5. 
        case H5. 
    apply ctx_e2m_member to H1 H5. case H6.
      case H4.
      case H4. case H7. case H8. case H3.
        apply ctx_e2m_member to H1 H11. case H12. 
        case H10.
        case H10. apply e2m/unique_ctx_of_val to _ H5 H11. search.
        case H10.
        case H10.
        case H10.
      case H4.
      case H4.
      case H4.

  intros. case H2 (keep).
    case H3.
      apply IH to _ H4 H5. search.
      case H5.
        apply e2m/full_dirt_empty_member to H1 H7 H8.
        apply e2m/comp_ty_member to H1 H5 H6.
    case H3.
      case H4.
      apply e2m/full_dirt_empty_member to H1 H7 H8.
      apply IH to _ H5 H7. search.
      apply e2m/comp_ty_member to H1 H6 H7. 
      apply e2m/comp_ty_member to H1 H4 H5.
% QED

Split e2m/ty_unique as e2m/val_ty_unique, e2m/comp_ty_unique.

Theorem ml/ctx_wf_ty_comp:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m A,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_m |- ml/wf_ty (ml/comp_ty A)} ->
    {Ctx_m |- ml/wf_ty A}.
% PROOF
intros. case H2.
  search.
  apply ctx_m_member to _ _. case H5.
    case H3.
    case H3. case H6.
    case H3.
% QED.
