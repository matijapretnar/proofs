Specification "exp2ml".
Import "common".

Close exp/sig, exp/comp_ty, exp/coer_ty, exp/val_ty.
Close ml/sig, ml/ty, ml/term, ml/coer_ty, ml/hand, ml/coer, op.
Close dirt.

Set subgoals off.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contexts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define e2m/ctx : exp/sig -> ml/sig -> olist -> olist -> prop by

  e2m/ctx Sig_e Sig_m nil nil
    := {e2m/sig Sig_e Sig_m};

  nabla x x', e2m/ctx Sig_e Sig_m
    (e2m/val Sig_e x A x' :: Ctx_e2m)
    (ml/of_term Sig_m x' A' :: Ctx_m)
    := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ {Ctx_e2m |- e2m/val_ty A A'};

   nabla t t', e2m/ctx Sig_e Sig_m
     (e2m/val_ty t t' :: Ctx_e2m)
     (ml/wf_ty t' :: Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m;

   nabla d, e2m/ctx Sig_e Sig_m
     (e2m/full_dirt d :: Ctx_e2m)
     (Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m;

   nabla w w', e2m/ctx Sig_e Sig_m
     (e2m/coer w (exp/val_ty_coer_ty A1 A2) w' :: Ctx_e2m)
     (ml/of_coer w' (ml/ty_coer_ty A1' A2') :: Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ {Ctx_e2m |- e2m/val_ty A1 A1'} /\ {Ctx_e2m |- e2m/val_ty A2 A2'};

   nabla w w', e2m/ctx Sig_e Sig_m
     (e2m/coer w (exp/comp_ty_coer_ty C1 C2) w' :: Ctx_e2m)
     (ml/of_coer w' (ml/ty_coer_ty C1' C2') :: Ctx_m)
     := e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m /\ {Ctx_e2m |- e2m/comp_ty C1 C1'} /\ {Ctx_e2m |- e2m/comp_ty C2 C2'}.

Theorem ctx_m_member: 
  forall  Sig_e Sig_m Ctx_e2m Ctx_m F,
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    member F Ctx_m ->
    (exists X' A',
       fresh X' /\ (F = ml/of_term Sig_m X' A'))
    \/
    (exists T',
       fresh T' /\ (F = ml/wf_ty T'))
    \/
    (exists W T T',
      fresh W /\ (F = ml/of_coer W (ml/ty_coer_ty T T'))).
% PROOF
induction on 1. intros. case H1 (keep).
  case H2.
  case H2. 
    search.
    apply IH to H3 H5. search.
  case H2.
    search.
    apply IH to H3 H4. search.
  apply IH to H3 H2. search.
  case H2.
    search.
    apply IH to H3 H6. search.
  case H2.
    search.
    apply IH to H3 H6. search.
% QED

Theorem ctx_e2m_member: 
  forall Sig_e Sig_m Ctx_e2m Ctx_m F,
    e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m ->
    member F Ctx_e2m ->
      (exists X A X' A',
         fresh X /\ fresh X' /\ (F = e2m/val Sig_e X A X') /\ {Ctx_e2m |- e2m/val_ty A A'})
      \/
      (exists T T',
         fresh T /\ fresh T' /\ (F = e2m/val_ty T T') /\ member (ml/wf_ty T') Ctx_m)
      \/
      (exists D,
         fresh D /\ (F = e2m/full_dirt D))
      \/
      (exists W W' A1 A2,
         fresh W /\ fresh W' /\ (F = e2m/coer W (exp/val_ty_coer_ty A1 A2) W'))
      \/
      (exists W W' C1 C2,
         fresh W /\ fresh W' /\ (F = e2m/coer W (exp/comp_ty_coer_ty C1 C2) W')).
% PROOF
induction on 1. intros. case H1 (keep).
  case H2.
  case H2.
    search.
    apply IH to H3 H5. case H6.
      search.
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H4. case H5. 
      search. 
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H4. case H5. 
      search. 
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H6. case H7.
      search. 
      search.
      search.
      search.
      search.
  case H2.
    search.
    apply IH to H3 H6. case H7. 
      search. 
      search.
      search.
      search.
      search.
% QED
      
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Strenghtening Lemma
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem ml/full_dirt_strengthen :
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A D, 
         e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
      -> {Ctx_e2m, e2m/val Sig_e n1 A n2 |- e2m/full_dirt D} 
      -> {Ctx_e2m |- e2m/full_dirt D}.
% PROOF
intros. case H2 (keep).
  search.
  case H4.
    case H3.
    apply ctx_e2m_member to H1 H5. case H6. 
      case H3.
      case H3.
      case H3. search.
      case H3.
      case H3.
% QED

Theorem ml/ty_strengthen :
  (
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A B T, 
         e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m
      -> {Ctx_e2m, e2m/val Sig_e n1 A n2 |- e2m/val_ty B T} 
      -> {Ctx_e2m |- e2m/val_ty B T}
  ) /\ (
    forall Sig_e Sig_ml Ctx_e2m Ctx_m A C T, 
         e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m 
      -> {Ctx_e2m, e2m/val Sig_e n1 A n2 |- e2m/comp_ty C T} 
      -> {Ctx_e2m |- e2m/comp_ty C T}
  ).
% PROOF
induction on 2 2. split.
  intros. case H2 (keep).
    search.
    apply IH to H1 H3. apply IH1 to H1 H4. search.
    apply IH to H1 H3. apply IH1 to H1 H4. search.
    apply IH to H1 H3. apply IH to H1 H5. apply ml/full_dirt_strengthen to H1 H4. search.
    apply IH to H1 H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. apply IH to _ H4. apply IH to _ H5. search.
    apply IH1 to _ H3. apply IH1 to _ H4. apply IH to _ H5. search.
    apply IH to _ H3. search.
    case H4.
      case H3.
      apply ctx_e2m_member to H1 H5. case H6.
        case H3.
        case H3. search.
        case H3.
        case H3.
        case H3.
  intros. case H2 (keep).
    apply IH to H1 H3. search.
    apply IH to H1 H4. apply ml/full_dirt_strengthen to H1 H3. search.
    case H4.
      case H3.
      apply ctx_e2m_member to H1 H5. case H6.
        case H3.
        case H3.
        case H3.
        case H3.
        case H3.
% QED

Split ml/ty_strengthen as ml/strengthen_val_ty, ml/strengthen_comp_ty.

Theorem member_meaning:
  forall Ctx F,
    member F Ctx -> {Ctx |- F}.
% PROOF
induction on 1. intros. case H1 (keep).
  search.
  apply IH to H2. search.
% QED


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wf_ty preservation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem e2m/preserve_wf_ty :
  (forall A A' Sig_e Sig_m Ctx_e2m Ctx_m, 
     e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m -> {Ctx_e2m |- e2m/val_ty A A'} -> {Ctx_m |- ml/wf_ty A'}) /\
  (forall C C' Sig_e Sig_m Ctx_e2m Ctx_m, 
     e2m/ctx Sig_e Sig_m Ctx_e2m Ctx_m -> {Ctx_e2m |- e2m/comp_ty C C'} -> {Ctx_m |- ml/wf_ty C'}).
induction on 2 2. split.

  intros. case H2 (keep).
    search.
    apply IH to _ H3. apply IH1 to _ H4. search.
    apply IH to _ H3. apply IH1 to _ H4. search.
    apply IH to _ H3. apply IH to _ H5. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. search.
    apply IH to _ H3. apply IH to _ H4. apply IH to _ H5. search.
    apply IH1 to _ H3. apply IH1 to _ H4. apply IH to _ H5. search.
    apply IH to _ H3. search.
    % backchain
    apply ctx_e2m_member to H1 H4. case H5.
      case H3.
      case H3. search.
      case H3.
      case H3.
      case H3.

  intros. case H2 (keep).
    apply IH to _ H3. search.
    apply IH to _ H4. search.
     % backchain
    apply ctx_e2m_member to H1 H4. case H5.
      case H3.
      case H3.
      case H3.
      case H3.
      case H3.
% QED?

Split e2m/preserve_wf_ty as e2m/preserve_wf_val_ty, e2m/preserve_wf_comp_ty.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem ml/of_coer_unique:
  forall Y A1 B1 A2 B2,
    {ml/of_coer Y (ml/ty_coer_ty A1 B1)} ->
    {ml/of_coer Y (ml/ty_coer_ty A2 B2)} ->
    A1 = A2 /\ B1 = B2.
% PROOF
induction on 1. intros. case H1. case H2. case H4 (keep).
  case H6. apply IH to H7 H8. search.
  case H6. apply IH to H7 H8. search.
  case H6. apply IH to H7 H8. search.
  case H6. search.
  case H6. apply IH to H7 H9. apply IH to H8 H10. search.
  case H6. apply IH to H7 H9. apply IH to H8 H10. search.
  case H6. apply IH to H7 H9. apply IH to H8 H10. search.
  case H6. apply IH to H7 H8. search.
  case H6. apply IH to H7 H8. search.
% QED


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem e2m/val_ty_unique:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m A A1 A2,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- e2m/val_ty A A1} ->
    {Ctx_e2m |- e2m/val_ty A A2} ->
    A1 = A2.
% PROOF
skip.

Theorem e2m/comp_ty_unique:
  forall Sig_e Sig_ml Ctx_e2m Ctx_m A A1 A2,
    e2m/ctx Sig_e Sig_ml Ctx_e2m Ctx_m ->
    {Ctx_e2m |- e2m/comp_ty A A1} ->
    {Ctx_e2m |- e2m/comp_ty A A2} ->
    A1 = A2.
% PROOF
skip.
% QED
