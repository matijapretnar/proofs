Specification "erasure".
Import "common".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contexts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define ctx3 : t/sig -> e/sig -> olist -> olist -> olist -> prop by
  ctx3 Sig_t Sig_e nil nil nil := {ers_sig Sig_t Sig_e};
  nabla x x', ctx3 Sig_t Sig_e
    (t/of_val Sig_t x A :: Ctx_t)
    (ers_val x x' :: Ctx_t2e)
    (e/of_val Sig_e x' T :: Ctx_e)
    := ctx3 Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e /\ {Ctx_t2e |- t/skel_val_ty A T};
  nabla t, ctx3 Sig_t Sig_e
    (t/skel_val_ty t Te :: Ctx_t)
    (t/skel_val_ty t Te :: Ctx_t2e)
    Ctx_e
    := ctx3 Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e.

Theorem ctx_t_member : forall Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e F,
  ctx3 Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e -> member F Ctx_t -> exists X A X' T,
    fresh X /\ fresh X' /\ (F = t/of_val Sig_t X A) /\ {Ctx_t2e |- t/skel_val_ty A T} /\ member (ers_val X X') Ctx_t2e /\ member (e/of_val Sig_e X' T) Ctx_e.
skip. % by definition of what a ctx_t can be

Theorem ctx_ers_member : forall Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e F,
  ctx3 Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e -> member F Ctx_t2e ->
    (exists X A X' T,
      fresh X /\ fresh X' /\
      (F = ers_val X X') /\
      {Ctx_t2e |- t/skel_val_ty A T} /\ member (t/of_val Sig_t X A) Ctx_t /\ member (e/of_val Sig_e X' T) Ctx_e)
    \/
    (exists A T,
      fresh A /\ (F = t/skel_val_ty A T)).
induction on 1. intros. case H1.
% empty
case H2.
% ers_val
case H2.
  % here
  search.
  % there
  apply IH to H3 H5. case H6.
    left. exists (X n2 n1), (A1 n2 n1). search.
    right. search.
% t/skel_val_ty
case H2.
  % here
  search.
  % there
  apply IH to H3 H4. case H5.
    search.
    search.

Theorem t/skel_ty_strengthen :
  (
    forall Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e A T, ctx3 Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e ->
    {Ctx_t2e, ers_val n1 n2 |- t/skel_val_ty A T} -> {Ctx_t2e |- t/skel_val_ty A T}
  ) /\ (
    forall Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e B T, ctx3 Sig_t Sig_e Ctx_t Ctx_t2e Ctx_e ->
    {Ctx_t2e, ers_val n1 n2 |- t/skel_comp_ty B T} -> {Ctx_t2e |- t/skel_comp_ty B T}
  ).
induction on 2 2. split.
intros. case H2.
  search.
  apply IH to H1 H3. apply IH1 to H1 H4. search.
  apply IH1 to H1 H3. apply IH1 to H1 H4. search.
  apply IH to _ H3. search.
  apply IH to _ H3. search.
  apply IH to _ H3. search.
  apply IH to _ H3. search.
  case H4.
    case H3.
    apply ctx_ers_member to H1 H5. case H6. case H3. case H3. search.
intros. case H2.
  apply IH to H1 H3. search.
  case H4.
    case H3.
    apply ctx_ers_member to H1 H5. case H6. case H3. case H3.
Split t/skel_ty_strengthen as t/skel_val_ty_strengthen, t/skel_comp_ty_strengthen.

Theorem ers_unique :
  (forall L Vt Ve1 Ve2, {L |- ers_val Vt Ve1} -> {L |- ers_val Vt Ve2} -> Ve1 = Ve2)
  /\
  (forall L Ct Ce1 Ce2, {L |- ers_comp Ct Ce1} -> {L |- ers_comp Ct Ce2} -> Ce1 = Ce2).
skip. % ers_val and ers_comp are unique by definition
Split ers_unique as unique_ers_val, unique_ers_comp.

Theorem ers_term_val :
  forall Vt Ve,
    {t/term_val Vt} -> {ers_val Vt Ve} -> {e/result_val Ve}.
skip.

Theorem ers_result_val :
  forall Vt Ve,
    {t/result_val Vt} -> {ers_val Vt Ve} -> {e/result_val Ve}.
intros. case H1.
  backchain ers_term_val.
  case H2. backchain ers_term_val.

Theorem unique_skel_ty :
  (forall Vt S1 S2, {t/skel_val_ty Vt S1} -> {t/skel_val_ty Vt S2} -> S1 = S2)
  /\
  (forall Ct S1 S2, {t/skel_comp_ty Ct S1} -> {t/skel_comp_ty Ct S2} -> S1 = S2).
induction on 1 1. split.
intros. case H1.
  case H2. search.
  case H2. apply IH to H3 H5. apply IH1 to H4 H6. search.
  case H2. apply IH1 to H3 H5. apply IH1 to H4 H6. search.
  case H2. apply IH to H3 H4. search.
  case H2. skip. % assumption t/skel_val_ty n1 S does not influence uniqueness of t/skel_val_ty
  case H2. apply IH to H3 H4. search.
  case H2. apply IH to H3 H4. search.
intros. case H1.
  case H2. apply IH to H3 H4. search.
Split unique_skel_ty as unique_skel_val_ty, unique_skel_comp_ty.
