Specification "exp2ml".
Import "common".
Import "proof-exp2ml-lemmas".
Import "proof-exp2ml-preserves-typing".

Theorem e2m/val_preservation :
  forall Sig_e Sig_m V1 V2 A T1 S A',
    {e2m/sig Sig_e Sig_m} ->
    {exp/step_val V1 V2} ->
    {e2m/val Sig_e V1 A T1} ->
    {e2m/val_ty A S A'} ->
    exists T2, {e2m/val Sig_e V2 A T2} /\ {ml/lr_exp Sig_m A' T1 T2}.
% PROOF
induction on 2. intros Hsig Hstep Hval Hty. case Hstep (keep).
    % {exp/step_val (exp/val_cast V C) (exp/val_cast V' C)}
    skip.
    % {exp/step_val (exp/val_cast V2 exp/unit_refl_coer) V2}
    skip.
    % {exp/step_val (exp/val_cast V C) (exp/val_cast V' C)}
    skip.
    % {exp/step_val (exp/val_cast V2 exp/unit_refl_coer) V2}
    skip.
    % {exp/step_val (exp/app_skel V A1) (exp/app_skel V' A1)}
    skip.
    % {exp/step_val (exp/app_ty V A1) (exp/app_ty V' A1)}
    skip.
    % {exp/step_val (exp/app_dirt V A1) (exp/app_dirt V' A1)}
    skip.
    % {exp/step_val (exp/app_coer V A1) (exp/app_coer V' A1)}
    skip.
    % {exp/step_val (exp/app_ty (exp/val_cast V (exp/lam_ty_coer Y)) A1) (exp/val_cast (exp/app_ty V A1) (Y A1))}
    skip.
    % {exp/step_val (exp/app_dirt (exp/val_cast V (exp/lam_dirt_coer Y)) D) (exp/val_cast (exp/app_dirt V D) (Y D))}
    skip.
    % {exp/step_val (exp/app_skel (exp/lam_skel M) S1) (M S1)}
    skip.
    % {exp/step_val (exp/app_ty (exp/lam_ty S1 M) A1) (M A1)}
    skip.
    % {exp/step_val (exp/app_dirt (exp/lam_dirt M) A1) (M A1)}
    skip.
    % {exp/step_val (exp/app_coer (exp/lam_coer Pi M) A1) (M A1)}
    skip.
% QED

Theorem e2m/comp_preservation :
  forall Sig_e Sig_m C1 C2 B T1 S B',
    {e2m/sig Sig_e Sig_m} ->
    {exp/step_comp C1 C2} ->
    {e2m/comp Sig_e C1 B T1} ->
    {e2m/comp_ty B S B'} ->
    exists T2, {e2m/comp Sig_e C2 B T2} /\ {ml/lr_exp Sig_m B' T1 T2}.
% PROOF
induction on 2. intros Hsig Hstep Hval Hty. case Hstep (keep).
    % {exp/step_comp (exp/comp_cast C Y) (exp/comp_cast C' Y)}
    skip.
    % {exp/step_comp (exp/app V1 V2) (exp/app V1' V2)}
    skip.
    % {exp/step_comp (exp/app (exp/val_cast V1 (exp/fun_coer Vc1 Vc2)) V2) (exp/comp_cast (exp/app V1 (exp/val_cast V2 Vc1)) Vc2)}
    skip.
    % {exp/step_comp (exp/app V1 V2) (exp/app V1 V2')}
    skip.
    % {exp/step_comp (exp/app (exp/fun A M) V) (M V)}
    skip.
    % {exp/step_comp (exp/let V C) (exp/let V' C)}
    skip.
    % {exp/step_comp (exp/let V C) (C V)}
    skip.
    % {exp/step_comp (exp/ret V) (exp/ret V')}
    skip.
    % {exp/step_comp (exp/op O V B1 C) (exp/op O V' B1 C)}
    skip.
    % {exp/step_comp (exp/comp_cast (exp/op O V B1 C) Y) (exp/op O V B1 (y\exp/comp_cast (C y) Y))}
    skip.
    % {exp/step_comp (exp/do C4 C3) (exp/do C1' C3)}
    skip.
    % {exp/step_comp (exp/do C4 C3) (C3 V)}
    skip.
    % {exp/step_comp (exp/do (exp/op O V B1 C4) C3) (exp/op O V B1 (y\exp/do (C4 y) C3))}
    skip.
    % {exp/step_comp (exp/with C V) (exp/with C V')}
    skip.
    % {exp/step_comp (exp/with C (exp/val_cast V (exp/hand_coer Y1 Y2))) (exp/comp_cast (exp/with (exp/comp_cast C Y1) V) Y2)}
    skip.
    % {exp/step_comp (exp/with C V) (exp/with C' V)}
    skip.
    % {exp/step_comp (exp/with C (exp/hand H)) (Cr V)}
    skip.
    % {exp/step_comp (exp/with (exp/op O V B1 C) (exp/hand H))} (Cop V (exp/fun B1 (y\exp/with (C y) (exp/hand H))))}
    skip.
% QED