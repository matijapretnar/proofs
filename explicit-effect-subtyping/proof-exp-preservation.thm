Specification "exp".
Import "proof-exp-lemmas".

Theorem of/valcase : forall Sig H A D C M,
    {exp/of_hand Sig H A D C} -> {exp/get_ret_case H M} -> nabla x, {exp/of_val Sig x A |- exp/of_comp Sig (M x) C}.
induction on 2. intros. case H2.
    case H1. search.
    case H1. apply IH to H4 H3. search.

Theorem of/exp/op_case : forall Sig O A1 A2 H A D C M,
     {exp/of_hand Sig H A D C} ->
     {exp/get_op_case H O A2 M} ->
     {exp/of_op Sig O A1 A2} ->
     {in_dirt O D} ->
     {is_op O} ->
     nabla x, nabla k, {exp/of_val Sig x A1, exp/of_val Sig k (exp/fun_ty A2 C) |- exp/of_comp Sig (M x k) C}.
induction on 2. intros. case H2.
  case H1. search.
  case H1. apply exp/of_op_unique to H3 H8. search.
  case H1. case H4. apply apart_not_reflexive to H6. apply IH to H8 H7 H3 H12 H5. search.

Theorem in_less_dirt :
  forall O Y D1 D2, {in_dirt O D1} -> {exp/of_coer Y (exp/dirt_coer_ty D1 D2)} -> {in_dirt O D2}.
induction on 1. intros. case H1.
 case H2. search. search.
 case H2. search. apply IH to H3 H4. search.

Set subgoals off.

Theorem exp/val_preservation : forall Sig V V' A, {exp/step_val V V'} -> {exp/of_val Sig V A} -> {exp/of_val Sig V' A}.
induction on 1. intros. case H1.
% COERCE
case H2. apply IH to H3 H4. search.
% COERCE UNIT_REFL_COERCE
case H2. case H5. search.
% APP_SKEL
case H2. apply IH to H3 H4. search.
% APP_TY
case H2. apply IH to H3 H4. search.
% APP_DIRT
case H2. apply IH to H3 H4. search.
% APP_COER
case H2. apply IH to H3 H4. search.
% coerced APP_SKEL
case H2. case H4. case H6. inst H7 with n1 = S. search.
% coerced APP_TY
case H2. case H4. case H7. inst H8 with n1 = A1. cut H9. search.
% coerced APP_DIRT
case H2. case H4. case H6. inst H7 with n1 = D. search.
% coerced APP_COER
case H2. case H4. case H7. search.
% APP_SKEL reduce
case H2. case H3. inst H4 with n1 = S. search.
% APP_TY reduce
case H2. case H4. inst H6 with n1 = A1. cut H7. search.
% APP_DIRT reduce
case H2. case H3. inst H4 with n1 = A1. search.
% APP_COER reduce
case H2. case H3. inst H5 with n1 = A1. cut H7. search.

Theorem exp/extract_value_preservation : forall Sig C A D V, {exp/of_comp Sig C (exp/bang A D)} -> {exp/extract_value C V} -> {exp/of_val Sig V A}.
induction on 2. intros. case H2.
  case H1. case H5. apply IH to H4 H3. search.
  case H1. search.

Theorem exp/comp_preservation : forall Sig C C' A, {exp/step_comp C C'} -> {exp/of_comp Sig C A} -> {exp/of_comp Sig C' A}.
induction on 1. intros. case H1.
% COERCE
case H2. apply IH to H3 H4. search.
% APP V1-step
case H2. apply exp/val_preservation to H3 H4. search.
% APP V1-exp/coer
case H2. case H4. case H7. search.
% APP V2-step
case H2. apply exp/val_preservation to H4 H6. search.
% APP beta
case H2. case H4. inst H6 with n1 = V. cut H7. search.
% LET V-step
case H2. apply exp/val_preservation to H3 H4. search.
% LET beta
case H2. inst H5 with n1 = V. cut H6. search.
% RETURN V-step
case H2. apply exp/val_preservation to H3 H4. search.
% OP V-step
case H2. apply exp/val_preservation to H3 H5. search.
% OP-coerce
case H2. case H4. case H5. apply in_less_dirt to H9 H12.
search.
% DO C1-step
case H2. apply IH to H3 H4. search.
% DO value
case H2. apply exp/extract_value_preservation to H4 H3. inst H5 with n1 = V. cut H7. search.
% DO op
case H2. case H4. search.
% HANDLE V-step
case H2. apply exp/val_preservation to H3 H5. search.
% HANDLE V-cast
case H2. case H5. case H7. search.
% HANDLE C-step
case H2. apply IH to H4 H5. search.
% HANDLE value
case H2. case H6. apply exp/extract_value_preservation to H5 H3. apply of/valcase to H7 H4. inst H9 with n1 = V. cut H10. search.
% HANDLE op
case H2. case H6. case H5. apply of/exp/op_case to H7 H4 H8 H11 H12.
assert {exp/of_val Sig (exp/fun B (y\exp/with (C1 y) (exp/hand H))) (exp/fun_ty B A)}.
inst H13 with n1 = V, n2 = (exp/fun B (y\exp/with (C1 y) (exp/hand H))).
cut H15. search.
