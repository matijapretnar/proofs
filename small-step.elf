%%% Small step operational semantics

% "get-op-case" finds the handler case which applies to a given operation,
% or gives the default handler if none applies.

get-op-case : operation Eff -> op-cases -> op-case -> type.
%mode get-op-case +IO +OCs -OC.

get-op-case/nil   : get-op-case (I # O) op-cases/nil ([x] [k] op (ins I) O x ([y] app k y)).
get-op-case/here  : get-op-case (I # O) (op-cases/cons (ins I) O OC _) OC.
get-op-case/there : get-op-case IO (op-cases/cons (ins I') O' _ OCs) OC
                     <- apart IO (I' # O')
                     <- get-op-case IO OCs OC.

% The big step semantics relation.

result : type.

result/val : expr -> result.
result/op  : operation Eff -> expr -> (expr -> comp) -> result.


% The small step semantics relation.

~> : comp -> comp -> type.
%mode ~> +C -C'.
%infix none 40 ~>.

~>/cond-tru  : cond tru C1 _ ~> C1.
~>/cond-fls  : cond fls _ C2 ~> C2.
~>/zro?-zro  : zro? zro ~> val tru.
~>/zro?-suc  : zro? (suc _) ~> val fls.
~>/pred-zro  : pred zro ~> val zro.
~>/pred-suc  : pred (suc E) ~> val E.
~>/app       : app (fun E1) E2 ~> E1 E2.
~>/let-val   : let (val E) C2 ~> C2 E.
~>/let-op    : let (op (ins I) O Ep K) C2 ~> op (ins I) O Ep ([x] let (K x) C2).
~>/let-step  : let C1 C2 ~> let C1' C2
                <- C1 ~> C1'.
~>/letr      : letr C1 C2 ~> C2 (fun ([x] letr C1 ([f] C1 f x))).
~>/letv      : letv E C ~> C E.
~>/with-val  : with (hnd Cv _) (val E) ~> Cv E.
~>/with-op   : with (hnd Cv OCs) (op (ins I) O Ep K) ~> OC Ep (fun ([y] with (hnd Cv OCs) (K y)))
                <- get-op-case (I # O) OCs OC.
~>/with-step : with E C ~> with E C'
                <- C ~> C'.


~>* : comp -> result -> type.
%infix none 40 ~>*.

~>*/val  : val E ~>* result/val E.
~>*/op   : op (ins I) O E K ~>* result/op (I # O) E K.
~>*/step : C ~>* R
            <- C' ~>* R
            <- C ~> C'.
