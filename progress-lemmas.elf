% If an operation call is well-typed, the operation appears in the signature.

cof-op/sig : cof Sig (op _ O _ _) _ -> sig Sig O _ _ -> type.
%mode cof-op/sig +C -O.

- : cof-op/sig (cof/op _ O _ _) O.

- : cof-op/sig (cof/sub C _) O
     <- cof-op/sig C O.

%worlds (topen) (cof-op/sig _ _).
%total {C} (cof-op/sig C _).


%%% Effectiveness of "get-op-case" %%%

% The main result here is "get-op-case-total", which says that for well-typed
% operation cases OCs, "get-op-case IO OCs OC" always delivers an answer "OC"

decide-op-case : comparable IO (I' # O') -> {OC} get-op-case IO OCs OC'
                  -> get-op-case IO (op-cases/cons (ins I') O' OC OCs) OC'' -> type.
%mode decide-op-case +Dec +OC +OC' -OC''.

- : decide-op-case comparable/equal _ _ get-op-case/here.
- : decide-op-case (comparable/apart A) _ OC (get-op-case/there OC A).

%worlds (topen) (decide-op-case _ _ _ _).
%total {} (decide-op-case _ _ _ _).


get-op-case-total : {IO} opcof Sig OCs B -> get-op-case IO OCs OC -> type.
get-op-case-total/cons : {IO} eof Sig E (inst Eff')
                          -> {O' : opsym Eff'} {OC} get-op-case IO OCs OC'
                          -> get-op-case IO (op-cases/cons E O' OC OCs) OC'' -> type.
%mode get-op-case-total +IO +OCs -OC.
%mode get-op-case-total/cons +IO +E +O' +OC +OC' -OC''.

- : get-op-case-total _ opcof/nil get-op-case/nil.

- : get-op-case-total IO (opcof/cons E _ _ OCs) OC''
     <- get-op-case-total IO OCs OC'
     <- get-op-case-total/cons IO E _ _ OC' OC''.


- : get-op-case-total/cons _ eof/ins _ _ OC' OC''
     <- compare _ _ Dec
     <- decide-op-case Dec _ OC' OC''.

- : get-op-case-total/cons IO (eof/sub E _) _ _ OC' OC''
     <- get-op-case-total/cons IO E _ _ OC' OC''.

%worlds (topen) (get-op-case-total _ _ _) (get-op-case-total/cons _ _ _ _ _ _).
%total {(OCs E)} (get-op-case-total _ OCs _) (get-op-case-total/cons _ E _ _ _ _).



%%% Subcases of the progress theorem %%%

% When proving progress, we first do induction on the structure of the term
% being reduced, and then in most cases, due to subtyping, we need to do
% a second induction on the typing derivation. In Twelf, we can do nested
% induction only by first proving a separate lemma for each case, and
% these lemmas follow below.

progress-cond : eof Sig E bool -> {C1} {C2} non-stuck Sig (cond E C1 C2) -> type.
%mode progress-cond +E +C1 +C2 -NS.

- : progress-cond eof/tru _ _ (non-stuck/step step/cond-tru).

- : progress-cond eof/fls _ _ (non-stuck/step step/cond-fls).

- : progress-cond (eof/sub E _) _ _ NS
     <- progress-cond E _ _ NS.

%worlds (topen) (progress-cond _ _ _ _).
%total {E} (progress-cond E _ _ _).


progress-mtch : eof Sig E nat -> {C1} {C2} non-stuck Sig (mtch E C1 C2) -> type.
%mode progress-mtch +E +C1 +C2 -NS.

- : progress-mtch eof/zro _ _ (non-stuck/step step/mtch-zro).

- : progress-mtch (eof/suc _) _ _ (non-stuck/step step/mtch-suc).

- : progress-mtch (eof/sub E _) _ _ NS
     <- progress-mtch E _ _ NS.

%worlds (topen) (progress-mtch _ _ _ _).
%total {E} (progress-mtch E _ _ _).


progress-absd : {A} eof Sig E empty -> non-stuck Sig (absd A E) -> type.
%mode progress-absd +A +E -NS.

- : progress-absd A (eof/sub E _) NS
     <- progress-absd A E NS.

%worlds (topen) (progress-absd _ _ _).
%total {E} (progress-absd _ E _).


progress-app : eof Sig E1 (A --> B) -> {E2} non-stuck Sig (app E1 E2) -> type.
%mode progress-app +E1 +E2 -NS.

- : progress-app (eof/fun _) _ (non-stuck/step step/app).

- : progress-app (eof/sub E1 _) E2 NS
     <- progress-app E1 E2 NS.

%worlds (topen) (progress-app _ _ _).
%total {E1} (progress-app E1 _ _).


progress-op : eof Sig Ei (inst Eff) -> {O : opsym Eff} {Ep} {K} non-stuck Sig (op Ei O Ep K) -> type.
%mode progress-op +Ei +O +Ep +K -NS.

- : progress-op eof/ins _ _ _ non-stuck/op.

- : progress-op (eof/sub Ei _) O Ep K NS
     <- progress-op Ei O Ep K NS.

%worlds (topen) (progress-op _ _ _ _ _).
%total {Ei} (progress-op Ei _ _ _ _).


progress-let : non-stuck Sig C1 -> {C2} non-stuck Sig (let C1 C2) -> type.
%mode progress-let +NS1 +C2 -NS.

- : progress-let non-stuck/val _ (non-stuck/step step/let-val).

- : progress-let non-stuck/op _ (non-stuck/step step/let-op).

- : progress-let (non-stuck/step S1) _ (non-stuck/step (step/let-step S1)).

%worlds (topen) (progress-let _ _ _).
%total {NS1} (progress-let NS1 _ _).


progress-with : eof Sig E (_ ==> _) -> cof Sig C _ -> non-stuck Sig C -> non-stuck Sig (with E C) -> type.
%mode progress-with +E +C +NS1 -NS2.

- : progress-with (eof/hnd _ _) _ non-stuck/val (non-stuck/step step/with-val).

- : progress-with (eof/hnd _ OCs) C non-stuck/op (non-stuck/step (step/with-op OC O))
     <- cof-op/sig C O
     <- get-op-case-total _ OCs OC.

- : progress-with (eof/hnd _ _) _ (non-stuck/step S) (non-stuck/step (step/with-step S)).

- : progress-with (eof/sub E (<t/==> _ _)) C NS1 NS2
     <- progress-with E C NS1 NS2.

%worlds (topen) (progress-with _ _ _ _).
%total {E} (progress-with E _ _ _).
