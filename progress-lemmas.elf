% If an operation call is well-typed, the operation appears in the signature.

cof-op/sig : cof Sig (op O _ _) _ -> sig Sig O _ _ -> type.
%mode cof-op/sig +C -O.

- : cof-op/sig (cof/op O _ _ _) O.

%worlds (topen) (cof-op/sig _ _).
%total {C} (cof-op/sig C _).


%%% Effectiveness of "get-op-case" %%%

% The main result here is "get-op-case-total", which says that for well-typed
% operation cases OCs, "get-op-case IO OCs OC" always delivers an answer "OC"

decide-op-case : comparable O O' -> {OC} get-op-case O OCs OC'
                  -> get-op-case O (op-cases/cons O' OC OCs) OC'' -> type.
%mode decide-op-case +Dec +OC +OC' -OC''.

- : decide-op-case comparable/equal _ _ get-op-case/here.
- : decide-op-case (comparable/apart A) _ OC (get-op-case/there OC A).

%worlds (topen) (decide-op-case _ _ _ _).
%total {} (decide-op-case _ _ _ _).


get-op-case-total : {O} opcof Sig OCs B D -> get-op-case O OCs OC -> type.
%mode get-op-case-total +O +OCs -OC.

- : get-op-case-total _ opcof/nil get-op-case/nil.

- : get-op-case-total O (opcof/cons _ _ OCs) OC''
     <- get-op-case-total O OCs OC'
     <- compare _ _ Dec
     <- decide-op-case Dec _ OC' OC''.

%worlds (topen) (get-op-case-total _ _ _).
%total {OCs} (get-op-case-total _ OCs _).



%%% Subcases of the progress theorem %%%

% When proving progress, we first do induction on the structure of the term
% being reduced, and then in most cases, due to subtyping, we need to do
% a second induction on the typing derivation. In Twelf, we can do nested
% induction only by first proving a separate lemma for each case, and
% these lemmas follow below.

progress-cond : {D} eof Sig E bool -> {C1} {C2} non-stuck Sig (cond E C1 C2) D -> type.
%mode progress-cond +D +E +C1 +C2 -NS.

- : progress-cond _ eof/tru _ _ (non-stuck/step step/cond-tru).

- : progress-cond _ eof/fls _ _ (non-stuck/step step/cond-fls).

%worlds (topen) (progress-cond _ _ _ _ _).
%total {E} (progress-cond _ E _ _ _).


progress-mtch : {D} eof Sig E nat -> {C1} {C2} non-stuck Sig (mtch E C1 C2) D -> type.
%mode progress-mtch +D +E +C1 +C2 -NS.

- : progress-mtch _ eof/zro _ _ (non-stuck/step step/mtch-zro).

- : progress-mtch _ (eof/suc _) _ _ (non-stuck/step step/mtch-suc).

%worlds (topen) (progress-mtch _ _ _ _ _).
%total {E} (progress-mtch _ E _ _ _).


progress-absd : {A} {D} eof Sig E empty -> non-stuck Sig (absd (A ! D) E) D -> type.
%mode progress-absd +A +D +E -NS.


%worlds (topen) (progress-absd _ _ _ _).
%total {E} (progress-absd _ _ E _).


progress-app : {D} eof Sig E1 (A --> B) -> {E2} non-stuck Sig (app E1 E2) D -> type.
%mode progress-app +D +E1 +E2 -NS.

- : progress-app _ (eof/fun _) _ (non-stuck/step step/app).

%worlds (topen) (progress-app _ _ _ _).
%total {E1} (progress-app _ E1 _ _).


progress-let : non-stuck Sig C1 D -> {C2} non-stuck Sig (let C1 C2) D -> type.
%mode progress-let +NS1 +C2 -NS.

- : progress-let non-stuck/val _ (non-stuck/step step/let-val).

- : progress-let (non-stuck/op _) _ (non-stuck/step step/let-op).

- : progress-let (non-stuck/step S1) _ (non-stuck/step (step/let-step S1)).

%worlds (topen) (progress-let _ _ _).
%total {NS1} (progress-let NS1 _ _).


progress-with : eof Sig E (_ ! D1 ==> _ ! D2) -> cof Sig C _ -> non-stuck Sig C D1 -> non-stuck Sig (with E C) D2 -> type.
%mode progress-with +E +C +NS1 -NS2.

- : progress-with (eof/hnd _ _ _) _ non-stuck/val (non-stuck/step step/with-val).

- : progress-with (eof/hnd _ OCs _) C (non-stuck/op _) (non-stuck/step (step/with-op OC O))
     <- cof-op/sig C O
     <- get-op-case-total _ OCs OC.

- : progress-with (eof/hnd _ _ _) _ (non-stuck/step S) (non-stuck/step (step/with-step S)).

%worlds (topen) (progress-with _ _ _ _).
%total {E} (progress-with E _ _ _).
