%%%%% Entity names %%%%%

% We need a way of representing names of effects, operation symbols and instances.
% Furthermore, these names need to be comparable.
% Ideally, we would prefer to *hypothesize* about this fact,
% but there is no legal way of doing this in Twelf.
%
% Instead, we represent names with natural numbers
% and implement the relevant decision procedures.
% We consider this to be a very clumsy solution,
% mainly because it exposes implementation details.

name : type.
%name name X.

name/z : name.
name/s : name -> name.


% We only have to define the apartness relation,
% because two names are equal only if they are identical.

apart-name : name -> name -> type.
%mode apart-name +X +Y.

apart-name/sz : apart-name (name/s _) name/z.
apart-name/zs : apart-name name/z (name/s _).
apart-name/ss : apart-name (name/s X) (name/s Y)
                 <- apart-name X Y.


% Two names are comparable if they are either equal or apart.

comparable-name : name -> name -> type.

comparable-name/equal : comparable-name X X.
comparable-name/apart : comparable-name X Y
                         <- apart-name X Y.


comparable-name/s : comparable-name X Y -> comparable-name (name/s X) (name/s Y) -> type.
%mode comparable-name/s +Dec -Dec'.

- : comparable-name/s comparable-name/equal comparable-name/equal.

- : comparable-name/s (comparable-name/apart A) (comparable-name/apart (apart-name/ss A)).

%worlds () (comparable-name/s _ _).
%total {} (comparable-name/s _ _).


% Any two names are comparable.

compare-name : {X} {Y} comparable-name X Y -> type.
%mode compare-name +X +Y -Dec.

- : compare-name name/z name/z comparable-name/equal.

- : compare-name name/z (name/s _) (comparable-name/apart apart-name/zs).

- : compare-name (name/s _) name/z (comparable-name/apart apart-name/sz).

- : compare-name (name/s X) (name/s Y) Dec'
     <- compare-name X Y Dec
     <- comparable-name/s Dec Dec'.

%worlds () (compare-name _ _ _).
%total {X Y} (compare-name X Y _).


%%%%% Representation of effects %%%%%
 
% Effects, operation symbols and instances are all just labels,
% and we implement each one with a single constructor that wraps a name.
% Note that operation symbols and instances are distinguished by their effect
% and all start counting from zero.
% We also define operations as pairs of instances and operations.

effect : type.
%name effect Eff.
 
effect/ : name -> effect.
 
 
opsym : effect -> type.
%name opsym O.
 
opsym/ : {Eff} name -> opsym Eff.
 
 
instance : effect -> type.
%name instance I.
 
instance/ : {Eff} name -> instance Eff.


operation : effect -> type.
%name operation IO.
 
# : instance Eff -> opsym Eff -> operation Eff.
%infix none 50 #.



%%% Comparison of operations %%%

% The operations have to be comparable
% so we can always select the right handler case.
% This comparability is inherited from the comparability
% of effects, instances and operation symbols.

apart : operation Eff -> operation Eff' -> type.
%mode apart +IO +I'O'.
 
apart/effect   : apart (instance/ (effect/ X) _ # _) (instance/ (effect/ Y) _ # _)
                   <- apart-name X Y.
apart/instance : apart (instance/ _ X # _) (instance/ _ Y # _)
                   <- apart-name X Y.
apart/opsym    : apart (_ # opsym/ _ X) (_ # opsym/ _ Y)
                   <- apart-name X Y.
 
 
comparable : operation Eff -> operation Eff' -> type.
 
comparable/equal : comparable IO IO.
comparable/apart : comparable IO I'O'
                   <- apart IO I'O'.
 


%%% Regions %%%

% For the sake of simplicity, we represent regions with lists.
% This representation is sufficient, because we only need to test for containment,
% which we do by "in-region" for instances and "<r" for regions.

region : effect -> type.
%name region R.
 
region/empty : region Eff.
region/cons  : instance Eff -> region Eff -> region Eff.

in-region : instance Eff -> region Eff -> type.
 
in-region/here      : in-region I (region/cons I R).
in-region/there     : in-region I (region/cons _ R)
                       <- in-region I R.
 

<r : region Eff -> region Eff -> type.
%infix none 30 <r.
 
<r/empty : region/empty <r R.
<r/cons  : region/cons I R <r R'
            <- R <r R'
            <- in-region I R'.
 


%%% Dirt %%%

% Like regions, we represent dirt with lists, and define "in-dirt" and "<d".

dirt : type.
%name dirt D.
 
dirt/empty : dirt.
dirt/cons  : operation Eff -> dirt -> dirt.
 
 
in-dirt : operation Eff -> dirt -> type.
 
in-dirt/here  : in-dirt IO (dirt/cons IO D).
in-dirt/there : in-dirt IO (dirt/cons _ D)
                 <- in-dirt IO D.
 

<d : dirt -> dirt -> type.
%infix none 30 <d.
 
<d/empty : dirt/empty <d D.
<d/cons  : dirt/cons IO D <d D'
            <- D <d D'
            <- in-dirt IO D'.
 

% In the typing rule for handlers, we use "covers D D1 D2",
% which states that the dirt "D" is contained in the union of "D1" and "D2".

covers : dirt -> dirt -> dirt -> type.
 
covers/empty      : covers dirt/empty _ _.
covers/cons-here  : covers (dirt/cons IO D) D1 D2
                     <- covers D D1 D2
                     <- in-dirt IO D1.
covers/cons-there : covers (dirt/cons IO D) D1 D2
                     <- covers D D1 D2
                     <- in-dirt IO D2.
 

% In the typing rule for operation calls, we use "in-dirt-region R O D",
% which states that "I # O" is in "D" for every "I" in "R".

in-dirt-region : region Eff -> opsym Eff -> dirt -> type.
 
in-dirt-region/empty : in-dirt-region region/empty O D.
in-dirt-region/cons  : in-dirt-region (region/cons I R) O D
                        <- in-dirt-region R O D
                        <- in-dirt (I # O) D.
