Specification "mon2del".

Define ctx : olist -> prop by
    ctx nil;
    nabla x x', ctx (mon2del/value x x' :: L) := ctx L.

Define fresh/mon : mon/value -> prop,
       fresh/del : del/value -> prop by
    nabla x, fresh/mon x;
    nabla x, fresh/del x.

Theorem ctx_mem : forall L F,
    ctx L -> member F L ->
    exists X X', (F = mon2del/value X X') /\ fresh/mon X /\ fresh/del X'.
induction on 2. intros. case H2.
    case H1. exists n1, n2. search.
    case H1. apply IH to H4 H3. exists (X n2 n1), (X' n2 n1). search.

Theorem member_prune : forall L E, nabla (x : mon/value) (x' : del/value),
    member (E x x') L -> exists F, E = x\ x'\ F.
induction on 1. intros. case H1.
    search.
    apply IH to H2. search.

Theorem ctx/unique : forall L X X' X'',
    ctx L -> member (mon2del/value X X') L -> member (mon2del/value X X'') L -> X' = X''.
induction on 1. intros. case H1.
    case H2.
    case H2.
        case H3.
            search.
            apply member_prune to H5.
        case H3.
            apply member_prune to H5.
            apply IH to H4 H5 H6. search.

Theorem mon2del/unique :
    (forall L V V' V'', ctx L -> {L |- mon2del/value V V'} -> {L |- mon2del/value V V''} -> V' = V'') /\
    (forall L M M' M'', ctx L -> {L |- mon2del/comp M M'} -> {L |- mon2del/comp M M''} -> M' = M'').
induction on 2 2. split.
% value
intros. case H2.
    % unit
    case H3. search.
    apply ctx_mem to H1 H5. case H4. case H6.
    % pair
    case H3. apply IH to H1 H4 H6. apply IH to H1 H5 H7. search.
    apply ctx_mem to H1 H7. case H6. case H8.
    % inl
    case H3. apply IH to H1 H4 H5. search.
    apply ctx_mem to H1 H6. case H5. case H7.
    % inr
    case H3. apply IH to H1 H4 H5. search.
    apply ctx_mem to H1 H6. case H5. case H7.
    % thunk
    case H3. apply IH1 to H1 H4 H5. search.
    apply ctx_mem to H1 H6. case H5. case H7.
    % backchain
    apply ctx_mem to H1 H5. case H4. case H3.
        case H6. case H6. case H6. case H6. case H6.
        apply ctx_mem to H1 H9. case H8. apply ctx/unique to H1 H5 H9. search.

% comp
intros. case H2.
    % ret
    case H3. apply IH to H1 H4 H5. search.
    apply ctx_mem to H1 H6. case H5.
    % fun
    case H3. apply IH1 to _ H4 H5. search.
    apply ctx_mem to H1 H6. case H5.
    % split
    case H3. apply IH to H1 H4 H6. apply IH1 to _ H5 H7. search.
    apply ctx_mem to H1 H7. case H6.
    % case
    case H3. apply IH to H1 H4 H7. apply IH1 to _ H5 H8. apply IH1 to _ H6 H9. search.
    apply ctx_mem to H1 H8. case H7.
    % force
    case H3. apply IH to H1 H4 H5. search.
    apply ctx_mem to H1 H6. case H5.
    % bind
    case H3. apply IH1 to H1 H4 H6. apply IH1 to _ H5 H7. search.
    apply ctx_mem to H1 H7. case H6.
    % app
    case H3. apply IH1 to H1 H4 H6. apply IH to H1 H5 H7. search.
    apply ctx_mem to H1 H7. case H6.
    % reify
    case H3. apply IH1 to H1 H4 H6. apply IH1 to _ H5 H7. search.
    apply ctx_mem to H1 H7. case H6.
    % reflect
    case H3. apply IH1 to H1 H4 H6. apply IH1 to _ H5 H7. search.
    apply ctx_mem to H1 H7. case H6.
    % backchain
    apply ctx_mem to H1 H5. case H4.

Split mon2del/unique as mon2del/value/unique, mon2del/comp/unique.

Theorem mon2del/evctx/unique : forall E E' E'',
    {mon2del/evctx E E'} -> {mon2del/evctx E E''} -> E' = E''.
induction on 1. intros. case H1.
    case H2. search.
    case H2. apply IH to H3 H5. apply mon2del/value/unique to _ H4 H6. search.
    case H2. apply IH to H3 H5. apply mon2del/comp/unique to _ H4 H6. search.
    case H2. apply IH to H3 H5. apply mon2del/comp/unique to _ H4 H6. search.

Theorem mon2del/unplug : forall E M EM EM',
    {mon/plug E M EM} -> {mon2del/comp EM EM'} ->
    exists E' M', {mon2del/evctx E E'} /\ {mon2del/comp M M'} /\ {del/plug E' M' EM'}.
induction on 1. intros. case H1.
    exists del/hole, EM'. search.
    case H2. apply IH to H3 H4. exists (del/evctx/bind E' N'), M'1. search.
    case H2. apply IH to H3 H4. exists (del/evctx/app E' V'), M'1.  search.
    case H2. apply IH to H3 H4. exists (del/evctx/reset E' Nu'), M'1. search.

Theorem mon2del/plug : forall L E M EM E' M',
    {mon/plug E M EM} -> {mon2del/evctx E E'} -> {L |- mon2del/comp M M'} ->
    exists EM', {L |- mon2del/comp EM EM'} /\ {del/plug E' M' EM'}.
induction on 1. intros. case H1.
    case H2. exists M'. search.
    case H2. apply IH to H4 H5 H3. exists (del/bind EM' N'). search.
    case H2. apply IH to H4 H5 H3. exists (del/app EM' V'). search.
    case H2. apply IH to H4 H5 H3. exists (del/reset EM' Nu'). search.

Define del/teeter : del/comp -> del/comp -> prop by
    del/teeter M1 M2 := {del/step M1 M2};
    del/teeter M1 M2 := {del/step M2 M1};
    del/teeter M1 M3 := exists M2, del/teeter M1 M2 /\ del/teeter M1 M3.

Theorem mon2del/reduce : forall M1 M2 M1' M2',
    {mon2del/comp M1 M1'} -> {mon2del/comp M2 M2'} -> 
    {mon/reduce M1 M2} -> del/teeter M1' M2'.
induction on 3. intros. case H3.
% split (pair V1 V2) M ~> M V1 V2
    case H1. case H4. inst H5 with n1 = V1, n2 = V2, n3 = V1', n4 = V2'.
    assert {mon2del/comp (M V1 V2) (M' V1' V2')}. cut H8. search.
    apply mon2del/comp/unique to _ H2 H9. search.
% case (inl V) M M2 ~> M1 V
    case H1. case H4. inst H5 with n1 = V, n2 = V'1.
    assert {mon2del/comp (M3 V) (M1'1 V'1)}. cut H8. search.
    apply mon2del/comp/unique to _ H2 H9. search.
% case (inr V) M1 M2 ~> M2 V
    case H1. case H4. inst H6 with n1 = V, n2 = V'1.
    assert {mon2del/comp (M3 V) (M2'1 V'1)}. cut H8. search.
    apply mon2del/comp/unique to _ H2 H9. search.
% force (thunk M) ~> M
    case H1. case H4.
    apply mon2del/comp/unique to _ H2 H5. search.
% bind (ret V) N ~> N V
    case H1. case H4. inst H5 with n1 = V, n2 = V'.
    assert {mon2del/comp (M V) (N' V')}. cut H7. search.
    apply mon2del/comp/unique to _ H2 H8. search.
% app (fun M) V ~> M V
    case H1. case H4. inst H6 with n1 = V, n2 = V'.
    assert {mon2del/comp (M V) (M'1 V')}. cut H7. search.
    apply mon2del/comp/unique to _ H2 H8. search.
% reify (ret V) (mon Nu Nb) ~> Nu V
    case H1. case H4. inst H5 with n1 = V, n2 = V'.
    assert {mon2del/comp (Nu V) (Nu' V')}. cut H7. search.
    apply mon2del/comp/unique to _ H2 H8. search.
% reify H[reflect M T] T ~> Nb {M} {\x. reify H[ret x] T}
    skip.

Theorem plug/step : forall E M1 EM1 M2 EM2,
    {del/plug E M1 EM1} -> {del/plug E M2 EM2} -> {del/step M1 M2} -> {del/step EM1 EM2}.
induction on 1. intros. case H1.
    case H2. search.
    case H2. apply IH to H4 H5 H3. case H6. search.
    case H2. apply IH to H4 H5 H3. case H6. search.
    case H2. apply IH to H4 H5 H3. case H6. search.

Theorem plug/teeter : forall E M1 EM1 M2 EM2,
    {del/plug E M1 EM1} -> {del/plug E M2 EM2} -> del/teeter M1 M2 -> del/teeter EM1 EM2.
induction on 3. intros. case H3.
    apply plug/step to H1 H2 H4. search.
    apply plug/step to H2 H1 H4. search.
    apply IH to H1 H2 H5. search.

Theorem mon2del/simulation : forall M1 M2 M1' M2',
    {mon2del/comp M1 M1'} -> {mon2del/comp M2 M2'} -> 
    {mon/step M1 M2} -> del/teeter M1' M2'.
intros. case H3.
    apply mon2del/unplug to H4 H1.
    apply mon2del/unplug to H6 H2.
    apply mon2del/reduce to H8 H11 H5.
    apply mon2del/evctx/unique to H7 H10.
    apply plug/teeter to H9 H12 H13.
    search.
