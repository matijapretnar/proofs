Specification "del2mon".

Close nat, label, mon/monad, mon/value, mon/comp, mon/cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type translation lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem wf_ty_has_translation : (
    forall Eff, {del/wf-eff Eff} -> exists Eff', {del2mon/eff Eff Eff'}
) /\ (
    forall A, {del/wf-valty A} -> exists A', {del2mon/valty A A'}
) /\ (
    forall As, {del/wf-valtys As} -> exists As', {del2mon/valtys As As'}
) /\ (
    forall C, {del/wf-compty C} -> exists C', {del2mon/compty C C'}
).
% Proof
    induction on 1 1 1 1. split.

    % eff
    intros Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH to H1. apply IH3 to H2. search.

    % valty
    intros Hwf. case Hwf.
        % unitty
        search.
        % prod
        apply IH1 to H1. apply IH1 to H2. search.
        % sum
        apply IH2 to H1. search.
        % u
        apply IH3 to H1. search.

    % valtys
    intros Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH2 to H1. apply IH1 to H2. search.

    % eff
    intros Hwf. case Hwf.
        % f
        apply IH to H1. apply IH1 to H2. search.
        % arrow
        apply IH1 to H1. apply IH3 to H2. search.
        % compprod
        apply IH3 to H1. apply IH3 to H2. search.

Split wf_ty_has_translation as
    wf_eff_has_translation,
    wf_valty_has_translation,
    wf_valtys_has_translation,
    wf_compty_has_translation.

Theorem translation_tys_are_wf : (
    forall Eff Eff', {del2mon/eff Eff Eff'} -> {del/wf-eff Eff} /\ {mon/wf-eff Eff'}
) /\ (
    forall A A', {del2mon/valty A A'} -> {del/wf-valty A} /\ {mon/wf-valty A'}
) /\ (
    forall As As', {del2mon/valtys As As'} -> {del/wf-valtys As} /\ {mon/wf-valtys As'}
) /\ (
    forall C C', {del2mon/compty C C'} -> {del/wf-compty C} /\ {mon/wf-compty C'}
).
% Proof
    induction on 1 1 1 1. split.

    % eff
    intros Htrans. case Htrans.
        % nil
        search.
        % cons
        apply IH3 to H1. apply IH to H2. search.

    % valty
    intros Htrans. case Htrans.
        % unitty
        search.
        % prod
        apply IH1 to H1. apply IH1 to H2. search.
        % sum
        apply IH2 to H1. search.
        % u
        apply IH3 to H1. search.

    % valtys
    intros Htrans. case Htrans.
        % nil
        search.
        % cons
        apply IH2 to H1. apply IH1 to H2. search.

    % eff
    intros Htrans. case Htrans.
        % f
        apply IH to H1. apply IH1 to H2. search.
        % arrow
        apply IH1 to H1. apply IH3 to H2. search.
        % compprod
        apply IH3 to H1. apply IH3 to H2. search.

Split translation_tys_are_wf as
    translation_effs_are_wf,
    translation_valtys_are_wf,
    translation_valtyss_are_wf,
    translation_comptys_are_wf.

Theorem ty_translation_is_unique : (
    forall Eff Eff1' Eff2', {del2mon/eff Eff Eff1'} -> {del2mon/eff Eff Eff2'} -> Eff1' = Eff2'
) /\ (
    forall A A1' A2', {del2mon/valty A A1'} -> {del2mon/valty A A2'} -> A1' = A2'
) /\ (
    forall As As1' As2', {del2mon/valtys As As1'} -> {del2mon/valtys As As2'} -> As1' = As2'
) /\ (
    forall C C1' C2', {del2mon/compty C C1'} -> {del2mon/compty C C2'} -> C1' = C2'
).
% Proof
    induction on 1 1 1 1. split.

    % eff
    intros Htrans1 Htrans2. case Htrans1.
        % nil
        case Htrans2. search.
        % cons
        case Htrans2. apply IH3 to H1 H3. apply IH to H2 H4. search.

    % valty
    intros Htrans1 Htrans2. case Htrans1.
        % unitty
        case Htrans2. search.
        % prod
        case Htrans2. apply IH1 to H1 H3. apply IH1 to H2 H4. search.
        % sum
        case Htrans2. apply IH2 to H1 H2. search.
        % u
        case Htrans2. apply IH3 to H1 H2. search.

    % valtys
    intros Htrans1 Htrans2. case Htrans1.
        % nil
        case Htrans2. search.
        % cons
        case Htrans2. apply IH2 to H1 H3. apply IH1 to H2 H4. search.

    % eff
    intros Htrans1 Htrans2. case Htrans1.
        % f
        case Htrans2. apply IH to H1 H3. apply IH1 to H2 H4. search.
        % arrow
        case Htrans2. apply IH1 to H1 H3. apply IH3 to H2 H4. search.
        % compprod
        case Htrans2. apply IH3 to H1 H3. apply IH3 to H2 H4. search.

Split ty_translation_is_unique as
    eff_translation_is_unique,
    valty_translation_is_unique,
    valtys_translation_is_unique,
    compty_translation_is_unique.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Context lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define fresh : A -> prop by
    nabla x, fresh x.

Define ctx : olist -> olist -> olist -> prop by
    ctx nil nil nil;
    nabla x x', ctx
        (del/of-value x A :: Gs)
        (del2mon/value x x' :: Gdel2mon)
        (mon/of-value x' A' :: Gt)
        := ctx Gs Gdel2mon Gt
        /\ {del2mon/valty A A'}.

Theorem ctx_member :
    forall Gs Gdel2mon Gt F, ctx Gs Gdel2mon Gt -> member F Gs ->
    exists X A X' A', fresh X /\ F = del/of-value X A /\ member (del2mon/value X X') Gdel2mon /\ member (mon/of-value X' A') Gt /\ {del2mon/valty A A'}.
% Proof
    induction on 1. intros Hctx Hmem. case Hctx.
        % nil
        case Hmem.
        % cons
        case Hmem.
            % here
            search.
            % there
            apply IH to H1 H3. search.

Theorem strengthen_wf : (
    forall Gs Gdel2mon Gt Eff, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-eff Eff} -> {del/wf-eff Eff}
) /\ (
    forall Gs Gdel2mon Gt A, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-valty A} -> {del/wf-valty A}
) /\ (
    forall Gs Gdel2mon Gt As, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-valtys As} -> {del/wf-valtys As}
) /\ (
    forall Gs Gdel2mon Gt C, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-compty C} -> {del/wf-compty C}
).
% Proof
    induction on 2 2 2 2. split.

    % eff
    intros Hctx Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH to _ H1. apply IH3 to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

    % valty
    intros Hctx Hwf. case Hwf.
        % unitty
        search.
        % prod
        apply IH1 to _ H1. apply IH1 to _ H2. search.
        % sum
        apply IH2 to _ H1. search.
        % u
        apply IH3 to _ H1. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

    % valtys
    intros Hctx Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH2 to _ H1. apply IH1 to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

    % eff
    intros Hctx Hwf. case Hwf.
        % f
        apply IH to _ H1. apply IH1 to _ H2. search.
        % arrow
        apply IH1 to _ H1. apply IH3 to _ H2. search.
        % compprod
        apply IH3 to _ H1. apply IH3 to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

Split strengthen_wf as
    strengthen_eff_wf,
    strengthen_valty_wf,
    strengthen_valtys_wf,
    strengthen_compty_wf.

Theorem typing_is_wf : (
    forall Gs Gdel2mon Gt V A, ctx Gs Gdel2mon Gt -> {Gs |- del/of-value V A} -> {del/wf-valty A}
) /\ (
    forall Gs Gdel2mon Gt Ms As C, ctx Gs Gdel2mon Gt -> {Gs |- del/of-cases Ms As C} -> {del/wf-valtys As} /\ {del/wf-compty C}
) /\ (
    forall Gs Gdel2mon Gt M C, ctx Gs Gdel2mon Gt -> {Gs |- del/of-comp M C} -> {del/wf-compty C}
).
% Proof
    split.

    % value
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_valty_wf to Hctx H2. search.
        % context
        apply ctx_member to Hctx H2. case H1. apply translation_valtys_are_wf to H6. search.

    % cases
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_valtys_wf to Hctx H2.
        apply strengthen_compty_wf to Hctx H3. search.
        % context
        apply ctx_member to Hctx H2. case H1.

    % comp
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_compty_wf to Hctx H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.

Split typing_is_wf as
    value_typing_is_wf,
    cases_typing_is_wf,
    comp_typing_is_wf.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The hard work
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem preservation_lemma : (
    forall Gs Gdel2mon Gt V A A', ctx Gs Gdel2mon Gt -> {Gs |- del/of-value V A} -> {del2mon/valty A A'} ->
    exists V', {Gdel2mon |- del2mon/value V V'} /\ {Gt |- mon/of-value V' A'}
) /\ (
    forall Gs Gdel2mon Gt V A A', ctx Gs Gdel2mon Gt -> {Gs |- del/of-value' V A} -> {del2mon/valty A A'} ->
    exists V', {Gdel2mon |- del2mon/value V V'} /\ {Gt |- mon/of-value' V' A'}
) /\ (
    forall Gs Gdel2mon Gt Ms As C As' C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-cases Ms As C} -> {del2mon/valtys As As'} -> {del2mon/compty C C'} ->
    exists Ms', {Gdel2mon |- del2mon/cases Ms Ms'} /\ {Gt |- mon/of-cases Ms' As' C'}
) /\ (
    forall Gs Gdel2mon Gt Ms As C As' C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-cases' Ms As C} -> {del2mon/valtys As As'} -> {del2mon/compty C C'} ->
    exists Ms', {Gdel2mon |- del2mon/cases Ms Ms'} /\ {Gt |- mon/of-cases' Ms' As' C'}
) /\ (
    forall Gs Gdel2mon Gt M C C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-comp M C} -> {del2mon/compty C C'} ->
    exists M', {Gdel2mon |- del2mon/comp M M'} /\ {Gt |- mon/of-comp M' C'}
) /\ (
    forall Gs Gdel2mon Gt M C C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-comp' M C} -> {del2mon/compty C C'} ->
    exists M', {Gdel2mon |- del2mon/comp M M'} /\ {Gt |- mon/of-comp' M' C'}
).
skip.
% Proof
%    induction on 2 2. split.
%
%    % del/of
%    intros. case H2.
%        % constructor
%        apply IH1 to H1 H4 H3.
%        apply translation_tys_are_wf to H3.
%        search.
%        % context
%        apply ctx_member to H1 H5. case H4.
%        apply ty_translation_is_unique to H3 H9. search.
%
%    % del/of'
%    intros. case H2.
%        % unit
%        case H3. search.
%        % lambda
%        case H3. apply IH to _ H4 H6 with Gdel2mon = (del2mon/tm n1 n2 :: Gdel2mon). search.
%        % application
%        apply typing_is_wf to _ H4. apply wf_ty_has_translation to H6. case H7. apply ty_translation_is_unique to H3 H9.
%        apply IH to _ H4 _. apply IH to _ H5 _. search.
%        % context
%        apply ctx_member to H1 H5. case H4.

Split preservation_lemma as
    value_preservation_lemma,
    cases_preservation_lemma,
    comp_preservation_lemma.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Wrapping up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define del_ctx : olist -> prop by
    del_ctx nil;
    nabla x, del_ctx
        (del/of-value x A :: Gs)
        := del_ctx Gs
        /\ {del/wf-valty A}.

Theorem del_ctx_has_translation :
    forall Gs, del_ctx Gs -> exists Gdel2mon Gt, ctx Gs Gdel2mon Gt.
% Proof
    induction on 1. intros Hdel_ctx.
    Hdel_ctx: case Hdel_ctx.
        % nil
        search.
        % cons
        apply IH to Hdel_ctx. apply wf_valty_has_translation to Hdel_ctx1.
        exists (del2mon/value n1 n2 :: Gdel2mon). search.

Theorem preservation : (
    forall Gs V A, del_ctx Gs -> {Gs |- del/of-value V A} ->
    exists Gdel2mon Gt V' A', {Gdel2mon |- del2mon/value V V'} /\ {del2mon/valty A A'} /\ {Gt |- mon/of-value V' A'}
) /\ (
    forall Gs M C, del_ctx Gs -> {Gs |- del/of-comp M C} ->
    exists Gdel2mon Gt M' C', {Gdel2mon |- del2mon/comp M M'} /\ {del2mon/compty C C'} /\ {Gt |- mon/of-comp M' C'}
).
% Proof
    split.

    % value
    intros Hdel_ctx Hof.
    Hctx: apply del_ctx_has_translation to Hdel_ctx.
    Hwf: apply value_typing_is_wf to _ Hof.
    Hty: apply wf_valty_has_translation to Hwf.
    preservation_lemma_part : apply preservation_lemma.
    apply preservation_lemma_part to Hctx Hof Hty.
    search.

    % comp
    intros Hdel_ctx Hof.
    Hctx: apply del_ctx_has_translation to Hdel_ctx.
    Hwf: apply comp_typing_is_wf to _ Hof.
    Hty: apply wf_compty_has_translation to Hwf.
    preservation_lemma_part : apply preservation_lemma.
    apply preservation_lemma_part4 to Hctx Hof Hty.
    search.
