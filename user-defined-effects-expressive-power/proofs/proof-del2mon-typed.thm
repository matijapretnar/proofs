Specification "del2mon".

Close nat, label, mon/monad, mon/value, mon/comp, mon/cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type translation lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Theorem wf_ty_has_translation : (
    forall Eff, {del/wf-eff Eff} -> exists Eff', {del2mon/eff Eff Eff'}
) /\ (
    forall A, {del/wf-valty A} -> exists A', {del2mon/valty A A'}
) /\ (
    forall As, {del/wf-valtys As} -> exists As', {del2mon/valtys As As'}
) /\ (
    forall C, {del/wf-compty C} -> exists C', {del2mon/compty C C'}
).
% Proof
    induction on 1 1 1 1. split.

    % eff
    intros Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH to H1. apply IH3 to H2. search.

    % valty
    intros Hwf. case Hwf.
        % unitty
        search.
        % prod
        apply IH1 to H1. apply IH1 to H2. search.
        % sum
        apply IH2 to H1. search.
        % u
        apply IH3 to H1. search.

    % valtys
    intros Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH2 to H1. apply IH1 to H2. search.

    % eff
    intros Hwf. case Hwf.
        % f
        apply IH to H1. apply IH1 to H2. search.
        % arrow
        apply IH1 to H1. apply IH3 to H2. search.
        % compprod
        apply IH3 to H1. apply IH3 to H2. search.

Split wf_ty_has_translation as
    wf_eff_has_translation,
    wf_valty_has_translation,
    wf_valtys_has_translation,
    wf_compty_has_translation.

Theorem translation_tys_are_wf : (
    forall Eff Eff', {del2mon/eff Eff Eff'} -> {del/wf-eff Eff} /\ {mon/wf-eff Eff'}
) /\ (
    forall A A', {del2mon/valty A A'} -> {del/wf-valty A} /\ {mon/wf-valty A'}
) /\ (
    forall As As', {del2mon/valtys As As'} -> {del/wf-valtys As} /\ {mon/wf-valtys As'}
) /\ (
    forall C C', {del2mon/compty C C'} -> {del/wf-compty C} /\ {mon/wf-compty C'}
).
% Proof
    induction on 1 1 1 1. split.

    % eff
    intros Htrans. case Htrans.
        % nil
        search.
        % cons
        apply IH3 to H1. apply IH to H2. search.

    % valty
    intros Htrans. case Htrans.
        % unitty
        search.
        % prod
        apply IH1 to H1. apply IH1 to H2. search.
        % sum
        apply IH2 to H1. search.
        % u
        apply IH3 to H1. search.

    % valtys
    intros Htrans. case Htrans.
        % nil
        search.
        % cons
        apply IH2 to H1. apply IH1 to H2. search.

    % eff
    intros Htrans. case Htrans.
        % f
        apply IH to H1. apply IH1 to H2. search.
        % arrow
        apply IH1 to H1. apply IH3 to H2. search.
        % compprod
        apply IH3 to H1. apply IH3 to H2. search.

Split translation_tys_are_wf as
    translation_effs_are_wf,
    translation_valtys_are_wf,
    translation_valtyss_are_wf,
    translation_comptys_are_wf.

Theorem ty_translation_is_unique : (
    forall Eff Eff1' Eff2', {del2mon/eff Eff Eff1'} -> {del2mon/eff Eff Eff2'} -> Eff1' = Eff2'
) /\ (
    forall A A1' A2', {del2mon/valty A A1'} -> {del2mon/valty A A2'} -> A1' = A2'
) /\ (
    forall As As1' As2', {del2mon/valtys As As1'} -> {del2mon/valtys As As2'} -> As1' = As2'
) /\ (
    forall C C1' C2', {del2mon/compty C C1'} -> {del2mon/compty C C2'} -> C1' = C2'
).
% Proof
    induction on 1 1 1 1. split.

    % eff
    intros Htrans1 Htrans2. case Htrans1.
        % nil
        case Htrans2. search.
        % cons
        case Htrans2. apply IH3 to H1 H3. apply IH to H2 H4. search.

    % valty
    intros Htrans1 Htrans2. case Htrans1.
        % unitty
        case Htrans2. search.
        % prod
        case Htrans2. apply IH1 to H1 H3. apply IH1 to H2 H4. search.
        % sum
        case Htrans2. apply IH2 to H1 H2. search.
        % u
        case Htrans2. apply IH3 to H1 H2. search.

    % valtys
    intros Htrans1 Htrans2. case Htrans1.
        % nil
        case Htrans2. search.
        % cons
        case Htrans2. apply IH2 to H1 H3. apply IH1 to H2 H4. search.

    % eff
    intros Htrans1 Htrans2. case Htrans1.
        % f
        case Htrans2. apply IH to H1 H3. apply IH1 to H2 H4. search.
        % arrow
        case Htrans2. apply IH1 to H1 H3. apply IH3 to H2 H4. search.
        % compprod
        case Htrans2. apply IH3 to H1 H3. apply IH3 to H2 H4. search.

Split ty_translation_is_unique as
    eff_translation_is_unique,
    valty_translation_is_unique,
    valtys_translation_is_unique,
    compty_translation_is_unique.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Context lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define fresh : A -> prop by
    nabla x, fresh x.

Define ctx : olist -> olist -> olist -> prop by
    ctx nil nil nil;
    nabla x x', ctx
        (del/of-value x A :: Gs)
        (del2mon/value x x' :: Gdel2mon)
        (mon/of-value x' A' :: Gt)
        := ctx Gs Gdel2mon Gt
        /\ {del2mon/valty A A'}.

Theorem ctx_member :
    forall Gs Gdel2mon Gt F, ctx Gs Gdel2mon Gt -> member F Gs ->
    exists X A X' A', fresh X /\ F = del/of-value X A /\ member (del2mon/value X X') Gdel2mon /\ member (mon/of-value X' A') Gt /\ {del2mon/valty A A'}.
% Proof
    induction on 1. intros Hctx Hmem. case Hctx.
        % nil
        case Hmem.
        % cons
        case Hmem.
            % here
            search.
            % there
            apply IH to H1 H3. search.

Theorem strengthen_apart :
    forall Gs Gdel2mon Gt N N', ctx Gs Gdel2mon Gt -> {Gs |- apart N N'} -> {apart N N'}.
% Proof
    induction on 2. intros. case H2.
        % z s
        search.
        % s z
        search.
        % s s
        apply IH to _ H3. search.
        % context
        apply ctx_member to H1 H4. case H3.

Theorem strengthen_wf : (
    forall Gs Gdel2mon Gt Eff, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-eff Eff} -> {del/wf-eff Eff}
) /\ (
    forall Gs Gdel2mon Gt A, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-valty A} -> {del/wf-valty A}
) /\ (
    forall Gs Gdel2mon Gt As, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-valtys As} -> {del/wf-valtys As}
) /\ (
    forall Gs Gdel2mon Gt C, ctx Gs Gdel2mon Gt -> {Gs |- del/wf-compty C} -> {del/wf-compty C}
).
% Proof
    induction on 2 2 2 2. split.

    % eff
    intros Hctx Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH to _ H1. apply IH3 to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

    % valty
    intros Hctx Hwf. case Hwf.
        % unitty
        search.
        % prod
        apply IH1 to _ H1. apply IH1 to _ H2. search.
        % sum
        apply IH2 to _ H1. search.
        % u
        apply IH3 to _ H1. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

    % valtys
    intros Hctx Hwf. case Hwf.
        % nil
        search.
        % cons
        apply IH2 to _ H1. apply IH1 to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

    % eff
    intros Hctx Hwf. case Hwf.
        % f
        apply IH to _ H1. apply IH1 to _ H2. search.
        % arrow
        apply IH1 to _ H1. apply IH3 to _ H2. search.
        % compprod
        apply IH3 to _ H1. apply IH3 to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.        

Split strengthen_wf as
    strengthen_eff_wf,
    strengthen_valty_wf,
    strengthen_valtys_wf,
    strengthen_compty_wf.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Small lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem typing_is_wf : (
    forall Gs Gdel2mon Gt V A, ctx Gs Gdel2mon Gt -> {Gs |- del/of-value V A} -> {del/wf-valty A}
) /\ (
    forall Gs Gdel2mon Gt Ms As C, ctx Gs Gdel2mon Gt -> {Gs |- del/of-cases Ms As C} -> {del/wf-valtys As} /\ {del/wf-compty C}
) /\ (
    forall Gs Gdel2mon Gt M C, ctx Gs Gdel2mon Gt -> {Gs |- del/of-comp M C} -> {del/wf-compty C}
).
% Proof
    split.

    % value
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_valty_wf to Hctx H2. search.
        % context
        apply ctx_member to Hctx H2. case H1. apply translation_valtys_are_wf to H6. search.

    % cases
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_valtys_wf to Hctx H2.
        apply strengthen_compty_wf to Hctx H3. search.
        % context
        apply ctx_member to Hctx H2. case H1.

    % comp
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_compty_wf to Hctx H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.

Split typing_is_wf as
    value_typing_is_wf,
    cases_typing_is_wf,
    comp_typing_is_wf.

Theorem translate_eff-kind :
    forall Gs Gdel2mon Gt Eff Eff' C C', ctx Gs Gdel2mon Gt ->
    {Gs |- del/eff-kind C Eff} -> {del2mon/compty C C'} -> {del2mon/eff Eff Eff'} ->
    {Gt |- mon/eff-kind C' Eff'}.
% Proof
    induction on 2. intros Hctx. case H1.
        case H2. apply eff_translation_is_unique to H3 H5. apply translation_effs_are_wf to H5. search.
        case H2. apply IH to _ H4 H6 H3. search.
        case H2. apply IH to _ H4 H6 H3. apply IH to _ H5 H7 H3. search.
        apply ctx_member to Hctx H5. case H4.

Theorem eff-kind_is_wf :
    forall Gs Gdel2mon Gt C Eff, ctx Gs Gdel2mon Gt ->
    {Gs |- del/eff-kind C Eff} -> {del/wf-eff Eff}.
% Proof
    induction on 2. intros Hctx. case H1.
        apply strengthen_eff_wf to Hctx H2. search.
        apply IH to Hctx H2. search.
        apply IH to Hctx H2. search.
        apply ctx_member to Hctx H3. case H2.

Theorem translate_valtys/get :
    forall Gs Gdel2mon Gt As L A As', ctx Gs Gdel2mon Gt ->
    {Gs |- del/valtys/get As L A} -> {del2mon/valtys As As'} ->
    exists A', {Gt |- mon/valtys/get As' L A'} /\ {del2mon/valty A A'}.
% Proof
induction on 2. intros. case H2.
    % here
    case H3.
        % cons
        search.
    case H3. apply IH to H1 H5 H6.
        case H4. apply strengthen_apart to _ H10. search.
        apply ctx_member to H1 H11. case H10.
    apply ctx_member to H1 H5. case H4.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The hard work
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem preservation_lemma : (
    forall Gs Gdel2mon Gt V A A', ctx Gs Gdel2mon Gt -> {Gs |- del/of-value V A} -> {del2mon/valty A A'} ->
    exists V', {Gdel2mon |- del2mon/value V V'} /\ {Gt |- mon/of-value V' A'}
) /\ (
    forall Gs Gdel2mon Gt V A A', ctx Gs Gdel2mon Gt -> {Gs |- del/of-value' V A} -> {del2mon/valty A A'} ->
    exists V', {Gdel2mon |- del2mon/value V V'} /\ {Gt |- mon/of-value' V' A'}
) /\ (
    forall Gs Gdel2mon Gt Ms As C As' C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-cases Ms As C} -> {del2mon/valtys As As'} -> {del2mon/compty C C'} ->
    exists Ms', {Gdel2mon |- del2mon/cases Ms Ms'} /\ {Gt |- mon/of-cases Ms' As' C'}
) /\ (
    forall Gs Gdel2mon Gt Ms As C As' C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-cases' Ms As C} -> {del2mon/valtys As As'} -> {del2mon/compty C C'} ->
    exists Ms', {Gdel2mon |- del2mon/cases Ms Ms'} /\ {Gt |- mon/of-cases' Ms' As' C'}
) /\ (
    forall Gs Gdel2mon Gt M C C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-comp M C} -> {del2mon/compty C C'} ->
    exists M', {Gdel2mon |- del2mon/comp M M'} /\ {Gt |- mon/of-comp M' C'}
) /\ (
    forall Gs Gdel2mon Gt M C C', ctx Gs Gdel2mon Gt -> {Gs |- del/of-comp' M C} -> {del2mon/compty C C'} ->
    exists M', {Gdel2mon |- del2mon/comp M M'} /\ {Gt |- mon/of-comp' M' C'}
).
% Proof
    induction on 2 2 2 2 2 2. split.
 
    % del/value-of
    intros. case H2.
        % constructor
        apply IH1 to H1 H4 H3.
        apply translation_valtys_are_wf to H3.
        search.
        % context
        apply ctx_member to H1 H5. case H4.
        apply valty_translation_is_unique to H3 H9. search.
 
    % del/value-of'
    intros. case H2.
        % unit
        case H3. search.
        % prod
        case H3. apply IH to _ H4 H6. apply IH to _ H5 H7. search.
        % inj
        case H3.
        apply translate_valtys/get to H1 H5 H6.
        apply IH to _ H4 _. search.
        % thunk
        case H3. apply IH4 to _ H4 H5. search.
        % context
        apply ctx_member to H1 H5. case H4.

    % del/cases-of
    intros. case H2.
        % constructor
        apply IH3 to H1 H5 H3 H4.
        apply translation_valtyss_are_wf to H3.
        apply translation_comptys_are_wf to H4.
        search.
        % context
        apply ctx_member to H1 H6. case H5.

    % del/cases-of'
    intros. case H2.
        % nil
        case H3. search.
        % cons
        case H3. apply IH2 to _ H5 H7 H4. apply IH4 to _ H6 H4 with Gdel2mon = (del2mon/value n1 n2 :: Gdel2mon). search.
        % context
        apply ctx_member to H1 H6. case H5.

    % del/comp-of
    intros. case H2.
        % constructor
        apply IH5 to H1 H4 H3.
        apply translation_comptys_are_wf to H3.
        search.
        % context
        apply ctx_member to H1 H5. case H4.
 
    % del/comp-of'
    intros.
    case H2.
        % ret
        case H3. apply IH to _ H4 H6. search.
        % lambda
        case H3. apply IH4 to _ H4 H6 with Gdel2mon = (del2mon/value n1 n2 :: Gdel2mon). search.
        % split
        apply value_typing_is_wf to _ H4.
        apply wf_valty_has_translation to H6.
        case H7.
        apply IH to _ H4 _.
        apply IH4 to _ H5 H3 with Gdel2mon = (del2mon/value n2 n4 :: del2mon/value n1 n3 :: Gdel2mon).
        search.
        % case
        apply value_typing_is_wf to _ H4.
        apply wf_valty_has_translation to H6.
        case H7.
        apply IH to _ H4 _.
        apply IH2 to _ H5 H8 H3.
        search.
        % u
        apply IH to _ H4 _. search.
        % bind
        apply comp_typing_is_wf to _ H5. apply wf_compty_has_translation to H7. case H8.
        apply IH4 to _ H5 _.
        apply IH4 to _ H6 H3 with Gdel2mon = (del2mon/value n1 n2 :: Gdel2mon).
        apply translate_eff-kind to _ H4 H3 H9.
        search.
        % app
        apply comp_typing_is_wf to _ H4. apply wf_compty_has_translation to H6. case H7.
        apply compty_translation_is_unique to H3 H9.
        apply IH4 to _ H4 _. apply IH to _ H5 _. search.
        % comppair
        case H3. apply IH4 to _ H4 _. apply IH4 to _ H5 _. search.
        % prj1
        apply comp_typing_is_wf to _ H6. apply wf_compty_has_translation to H7. case H8.
        apply eff-kind_is_wf to _ H4.
        apply wf_eff_has_translation to H11.
        apply translate_eff-kind to _ H4 H3 H12.
        apply translate_eff-kind to _ H5 H10 H12.
        apply IH4 to _ H6 _. search.
        % prj2
        apply comp_typing_is_wf to _ H6. apply wf_compty_has_translation to H7. case H8.
        apply eff-kind_is_wf to _ H4.
        apply wf_eff_has_translation to H11.
        apply translate_eff-kind to _ H4 H9 H12.
        apply translate_eff-kind to _ H5 H3 H12.
        apply IH4 to _ H6 _. search.
        % reset
        apply comp_typing_is_wf to _ H6. apply wf_compty_has_translation to H7. case H8.
        case H9.
        apply IH4 to _ H6 _.
        apply IH4 to _ H5 _ with Gdel2mon = (del2mon/value n1 n2 :: Gdel2mon).
        exists (mon/app (mon/reify M' (mon/mon (x\ mon/fun c\ mon/app (mon/force c) x) (m\ f\ mon/fun c\ mon/app (mon/force m) (mon/thunk (mon/fun y\ mon/app (mon/app (mon/force f) y) c))))) (mon/thunk (mon/fun M'1))).
        split.
            search.
            skip.
        % shift
        case H3.
        case H6.
        apply IH4 to _ H5 _ with Gdel2mon = (del2mon/value n1 n2 :: Gdel2mon).
        apply translation_valtys_are_wf to H7.
        apply translation_comptys_are_wf to H8.
        search.
        % context
        apply ctx_member to H1 H5. case H4.


Split preservation_lemma as
    value_preservation_lemma,
    cases_preservation_lemma,
    comp_preservation_lemma.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Wrapping up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define del_ctx : olist -> prop by
    del_ctx nil;
    nabla x, del_ctx
        (del/of-value x A :: Gs)
        := del_ctx Gs
        /\ {del/wf-valty A}.

Theorem del_ctx_has_translation :
    forall Gs, del_ctx Gs -> exists Gdel2mon Gt, ctx Gs Gdel2mon Gt.
% Proof
    induction on 1. intros Hdel_ctx.
    Hdel_ctx: case Hdel_ctx.
        % nil
        search.
        % cons
        apply IH to Hdel_ctx. apply wf_valty_has_translation to Hdel_ctx1.
        exists (del2mon/value n1 n2 :: Gdel2mon). search.

Theorem preservation : (
    forall Gs V A, del_ctx Gs -> {Gs |- del/of-value V A} ->
    exists Gdel2mon Gt V' A', {Gdel2mon |- del2mon/value V V'} /\ {del2mon/valty A A'} /\ {Gt |- mon/of-value V' A'}
) /\ (
    forall Gs M C, del_ctx Gs -> {Gs |- del/of-comp M C} ->
    exists Gdel2mon Gt M' C', {Gdel2mon |- del2mon/comp M M'} /\ {del2mon/compty C C'} /\ {Gt |- mon/of-comp M' C'}
).
% Proof
    split.

    % value
    intros Hdel_ctx Hof.
    Hctx: apply del_ctx_has_translation to Hdel_ctx.
    Hwf: apply value_typing_is_wf to _ Hof.
    Hty: apply wf_valty_has_translation to Hwf.
    preservation_lemma_part : apply preservation_lemma.
    apply preservation_lemma_part to Hctx Hof Hty.
    search.

    % comp
    intros Hdel_ctx Hof.
    Hctx: apply del_ctx_has_translation to Hdel_ctx.
    Hwf: apply comp_typing_is_wf to _ Hof.
    Hty: apply wf_compty_has_translation to Hwf.
    preservation_lemma_part : apply preservation_lemma.
    apply preservation_lemma_part4 to Hctx Hof Hty.
    search.
