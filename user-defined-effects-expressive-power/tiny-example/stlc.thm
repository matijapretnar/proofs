Specification "stlc".

Close trg/tm.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type translation lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem wf_ty_has_translation :
    forall A, {src/wf A} -> exists A', {s2t/ty A A'}.
% Proof
    induction on 1. intros Hwf. case Hwf.
        % unitty
        search.
        % arrow
        apply IH to H1. apply IH to H2. search.

Theorem translation_tys_are_wf :
    forall A A', {s2t/ty A A'} -> {src/wf A} /\ {trg/wf A'}.
% Proof
    induction on 1. intros Htrans. case Htrans.
        % unitty
        search.
        % arrow
        apply IH to H1. apply IH to H2. search.

Theorem ty_translation_is_unique :
    forall A A1' A2', {s2t/ty A A1'} -> {s2t/ty A A2'} -> A1' = A2'.
% Proof
    induction on 1. intros Htrans1 Htrans2. case Htrans1.
        % unitty
        case Htrans2. search.
        % arrow
        case Htrans2. apply IH to H1 H3. apply IH to H2 H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Context lemmas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define fresh : A -> prop by
    nabla x, fresh x.

Define ctx : olist -> olist -> olist -> prop by
    ctx nil nil nil;
    nabla x x', ctx
        (src/of x A :: Gs)
        (s2t/tm x x' :: Gs2t)
        (trg/of x' A' :: Gt)
        := ctx Gs Gs2t Gt
        /\ {s2t/ty A A'}.

Theorem ctx_member :
    forall Gs Gs2t Gt F, ctx Gs Gs2t Gt -> member F Gs ->
    exists X A X' A', fresh X /\ F = src/of X A /\ member (s2t/tm X X') Gs2t /\ member (trg/of X' A') Gt /\ {s2t/ty A A'}.
% Proof
    induction on 1. intros Hctx Hmem. case Hctx.
        % nil
        case Hmem.
        % cons
        case Hmem.
            % here
            search.
            % there
            apply IH to H1 H3. search.

Theorem strengthen_wf :
    forall Gs Gs2t Gt A, ctx Gs Gs2t Gt -> {Gs |- src/wf A} -> {src/wf A}.
% Proof
    induction on 2. intros Hctx Hwf. case Hwf.
        % unitty
        search.
        % arrow
        apply IH to _ H1. apply IH to _ H2. search.
        % context
        apply ctx_member to Hctx H2. case H1.

Theorem typing_is_wf :
    forall Gs Gs2t Gt M A, ctx Gs Gs2t Gt -> {Gs |- src/of M A} -> {src/wf A}.
% Proof
    intros Hctx Hof. case Hof.
        % constructor
        apply strengthen_wf to Hctx H2. search.
        % context
        apply ctx_member to Hctx H2. case H1. apply translation_tys_are_wf to H6. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The hard work
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem preservation_lemma : (
    forall Gs Gs2t Gt M A A', ctx Gs Gs2t Gt -> {Gs |- src/of M A} -> {s2t/ty A A'} ->
    exists M', {Gs2t |- s2t/tm M M'} /\ {Gt |- trg/of M' A'}
) /\ (
    forall Gs Gs2t Gt M A A', ctx Gs Gs2t Gt -> {Gs |- src/of' M A} -> {s2t/ty A A'} ->
    exists M', {Gs2t |- s2t/tm M M'} /\ {Gt |- trg/of' M' A'}
).
% Proof
    induction on 2 2. split.

    % src/of
    intros. case H2.
        % constructor
        apply IH1 to H1 H4 H3.
        apply translation_tys_are_wf to H3.
        search.
        % context
        apply ctx_member to H1 H5. case H4.
        apply ty_translation_is_unique to H3 H9. search.

    % src/of'
    intros. case H2.
        % unit
        case H3. search.
        % lambda
        case H3. apply IH to _ H4 H6 with Gs2t = (s2t/tm n1 n2 :: Gs2t). search.
        % application
        apply typing_is_wf to _ H4. apply wf_ty_has_translation to H6. case H7. apply ty_translation_is_unique to H3 H9.
        apply IH to _ H4 _. apply IH to _ H5 _. search.
        % context
        apply ctx_member to H1 H5. case H4.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Wrapping up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define src_ctx : olist -> prop by
    src_ctx nil;
    nabla x, src_ctx
        (src/of x A :: Gs)
        := src_ctx Gs
        /\ {src/wf A}.

Theorem src_ctx_has_translation :
    forall Gs, src_ctx Gs -> exists Gs2t Gt, ctx Gs Gs2t Gt.
% Proof
    induction on 1. intros Hsrc_ctx.
    Hsrc_ctx: case Hsrc_ctx.
        % nil
        search.
        % cons
        apply IH to Hsrc_ctx. apply wf_ty_has_translation to Hsrc_ctx1.
        exists (s2t/tm n1 n2 :: Gs2t). search.

Theorem preservation :
    forall Gs M A, src_ctx Gs -> {Gs |- src/of M A} ->
    exists Gs2t Gt M' A', {Gs2t |- s2t/tm M M'} /\ {s2t/ty A A'} /\ {Gt |- trg/of M' A'}.
% Proof
    intros Hsrc_ctx Hof.
    Hctx: apply src_ctx_has_translation to Hsrc_ctx.
    Hwf: apply typing_is_wf to _ Hof.
    Hty: apply wf_ty_has_translation to Hwf.
    preservation_lemma_part : apply preservation_lemma.
    apply preservation_lemma_part to Hctx Hof Hty.
    search.
