if-then-typd : {E} {K} if-then-op-case D OC OC' OC'' ->
               cof (OC E K) B ->
               cof (OC' E K) B ->
               cof (OC'' E K) B ->
               type.
%mode if-then-typd +E +K +D +OC +OC' -OC''.

- : if-then-typd _ _ if-then-op-case/yes OC _ OC.
- : if-then-typd _ _ if-then-op-case/no _ OC OC.

%worlds (vars) (if-then-typd _ _ _ _ _ _).
%total {} (if-then-typd _ _ _ _ _ _).

%%% Preservation

preservation-pred : {D} eof E nat -> pred E ~> C' -> cof C' (nat ! D) -> type.
%mode preservation-pred +D +E +S -C'.

- : preservation-pred _ eof/zro ~>/pred-zro (cof/val eof/zro).

- : preservation-pred _ (eof/suc E) ~>/pred-suc (cof/val E).

- : preservation-pred D (eof/sub E _) S C'
     <- preservation-pred D E S C'.

%worlds (vars) (preservation-pred _ _ _ _).
%total {E} (preservation-pred _ E _ _).


preservation-app : eof E1 (A --> B) -> eof E2 A -> app E1 E2 ~> C -> cof C B -> type.
%mode preservation-app +E1 +E2 +S -C.

- : preservation-app (eof/fun E1) E2 ~>/app (E1 _ E2).

- : preservation-app (eof/sub E1 (<t/--> A'<A B<B')) E2 S (cof/sub C B<B')
     <- preservation-app E1 (eof/sub E2 A'<A) S C.

%worlds (vars) (preservation-app _ _ _ _).
%total {E1} (preservation-app E1 _ _ _).


preservation-let-val : cof (val E) (A ! D) -> D <d D' -> ({x} eof x A -> cof (C x) (B ! D')) -> cof (C E) (B ! D') -> type.
%mode preservation-let-val +E +D<D' +C -B.

- : preservation-let-val (cof/val E) _ C (C _ E).

- : preservation-let-val (cof/sub E (<dt/! AA' D<D')) D'<D'' C B
     <- <d/trans D<D' D'<D'' D<D''
     <- preservation-let-val E D<D'' ([x] [e] (C x (eof/sub e AA'))) B.

%worlds (vars) (preservation-let-val _ _ _ _).
%total {E} (preservation-let-val E _ _ _).

preservation-let-op : cof (op Ei O Ep K) (A ! D) -> D <d D' -> ({x} eof x A -> cof (C x) (B ! D')) -> cof (op Ei O Ep ([x'] let (K x') C)) (B ! D') -> type.
%mode preservation-let-op +E +D<D' +C -B.

- : preservation-let-op (cof/op Ei O Ep K ROinD) D<D' C (cof/op Ei O Ep ([x'] [e'] (cof/let (cof/sub (K x' e') (<dt/! A<A D<D')) C)) ROinD')
     <- in-dirt/<d ROinD D<D' ROinD'
     <- <t/refl A A<A.

- : preservation-let-op (cof/sub E (<dt/! AA' D<D')) D'<D'' C B
     <- <d/trans D<D' D'<D'' D<D''
     <- preservation-let-op E D<D'' ([x] [e] (C x (eof/sub e AA'))) B.

%worlds (vars) (preservation-let-op _ _ _ _).
%total {E} (preservation-let-op E _ _ _).


preservation-with-val : cof (val E) B -> B <dt B1 -> eof (hnd Cv OCs) (B1 ==> B2) -> cof (Cv E) B2 -> type.
%mode preservation-with-val +C +B<B1 +E -C'.

- : preservation-with-val (cof/val E) (<dt/! A<A' _) (eof/hnd Cv _ _) (Cv _ (eof/sub E A<A')).

- : preservation-with-val (cof/sub C B<B') B'<B1 E B
     <- <dt/trans B<B' B'<B1 B<B1
     <- preservation-with-val C B<B1 E B.

- : preservation-with-val C B<B1' (eof/sub E (<t/==> B1'<B1 B2<B2')) (cof/sub B B2<B2')
     <- <dt/trans B<B1' B1'<B1 B<B1
     <- preservation-with-val C B<B1 E B.

%worlds (vars) (preservation-with-val _ _ _ _).
%total {C E} (preservation-with-val C _ E _).


instance-expr-in-region : eof (ins I) (inst R) -> in-region I R -> type.
%mode instance-expr-in-region +E -IinR.

- : instance-expr-in-region (eof/ins IinR) IinR.

- : instance-expr-in-region (eof/sub E (<t/inst R<R')) IinR'
    <- instance-expr-in-region E IinR
    <- in-region/<r IinR R<R' IinR'.

%worlds (vars) (instance-expr-in-region _ _).
%total {E} (instance-expr-in-region E _).

covers-rest : covers (dirt/cons _ _ D) D1 D2 -> covers D D1 D2 -> type.
%mode covers-rest +Covers -Covers'.

- : covers-rest (covers/cons-here _ Covers') Covers'.
- : covers-rest (covers/cons-there _ Covers') Covers'.

%worlds (vars) (covers-rest _ _).
%total {} (covers-rest _ _).

big-lemma-handled :
            in-dirt-instance I O Dcov ->
            sig O A1 A2 ->
            eof Ep A1 ->
            eof K (A2 --> B) ->
            get-op-case I O OCs OC ->
            opcof OCs B Dcov ->
            cof (OC Ep K) B ->
            type.
%mode big-lemma-handled +IOinD +O +Ep +K +Get +OCs -OC.

- : big-lemma-handled in-dirt-instance/here O Ep K
        (get-op-case/cons eq-inst-op/yes _ if-then-op-case/yes)
        (opcof/cons I O OC OCs add-if-singleton/one)
        (OC _ Ep _ K).

- : big-lemma-handled (in-dirt-instance/there IOinD) O Ep K
        (get-op-case/cons Eq GetRest ITE)
        (opcof/cons I' O' OC' OCs add-if-singleton/one)
        OC
        <- big-lemma-handled IOinD O Ep K GetRest OCs OC''
        <- if-then-typd Epp Kk ITE (OC' Epp Ep Kk K) OC'' OC.

- : big-lemma-handled IOinD O Ep K
        (get-op-case/cons Eq GetRest ITE)
        (opcof/cons I' O' OC' OCs _)
        OC
        <- big-lemma-handled IOinD O Ep K GetRest OCs OC''
        <- if-then-typd Epp Kk ITE (OC' Epp Ep Kk K) OC'' OC.

%worlds (vars) (big-lemma-handled _ _ _ _ _ _ _).
%total {Get} (big-lemma-handled _ _ _ _ Get _ _).

instance-in-itself : {I} in-region I (region/cons I region/empty) -> type.
%mode instance-in-itself +I -IinI.

- : instance-in-itself I in-region/here.

%worlds (vars) (instance-in-itself _ _).
%total {} (instance-in-itself _ _).

singleton-in-dirt : in-dirt-instance I O D -> in-dirt (region/cons I region/empty) O D -> type.
%mode singleton-in-dirt +IOinD -IOinD'.

- : singleton-in-dirt IOinD (in-dirt/cons IOinD in-dirt/empty).

%worlds (vars) (singleton-in-dirt _ _).
%total {} (singleton-in-dirt _ _).

big-lemma-unhandled :
            in-dirt-instance I O D' ->
            sig O A1 A2 ->
            eof Ep A1 ->
            eof K (A2 --> A' ! D') ->
            get-op-case I O OCs OC ->
            opcof OCs (A' ! D') _ ->
            cof (OC Ep K) (A' ! D') ->
            type.
%mode big-lemma-unhandled +IOinD +O +Ep +K +Get +OCs -OC.

- : big-lemma-unhandled IOinD O Ep K
        get-op-case/nil
        opcof/nil
        (cof/op (eof/ins IinI) O Ep ([_] [x] cof/app K x) IOinD')
    <- instance-in-itself I IinI
    <- singleton-in-dirt IOinD IOinD'.

- : big-lemma-unhandled IOinD O Ep K
        (get-op-case/cons _ GetRest ITE)
        (opcof/cons _ _ OC OtherOCs _)
        OC''
    <- big-lemma-unhandled IOinD O Ep K GetRest OtherOCs OC'
    <- if-then-typd Epp Kk ITE (OC Epp Ep Kk K) OC' OC''.

%worlds (vars) (big-lemma-unhandled _ _ _ _ _ _ _).
%total {Get} (big-lemma-unhandled _ _ _ _ Get _ _).

big-lemma : in-dirt-instance I O D ->
            D <d D' ->
            sig O A1 A2 ->
            eof Ep A1 ->
            eof K (A2 --> A' ! D'') ->
            get-op-case I O OCs OC ->
            opcof OCs (A' ! D'') Dcov ->
            covers D Dcov D'' -> 
            covers D' Dcov D'' ->
            cof (OC Ep K) (A' ! D'') ->
            type.
%mode big-lemma +IOinD +DD' +O +Ep +K +Get +OCs +Covers +Covers' -OC.

- : big-lemma in-dirt-instance/here _ O Ep K Get OCs (covers/cons-here IOinD _) _ OC
    <- big-lemma-handled IOinD O Ep K Get OCs OC.

- : big-lemma in-dirt-instance/here DD' O Ep K Get OCs (covers/cons-there IOinD _) _ OC
    <- big-lemma-unhandled IOinD O Ep K Get OCs OC.

- : big-lemma (in-dirt-instance/there IOinD) (<d/cons _ DD') O Ep K Get OCs Cov Cov' OC
    <- covers-rest Cov Cov- 
    <- big-lemma IOinD DD' O Ep K Get OCs Cov- Cov' OC.

%worlds (vars) (big-lemma _ _ _ _ _ _ _ _ _ _).
%total {IOinD} (big-lemma IOinD _ _ _ _ _ _ _ _ _).

preservation-with-op : cof (op (ins I) O Ep K) (A ! D) -> get-op-case I O OCs OC -> A <t A' -> D <d D' -> eof (hnd Cv OCs) (A' ! D' ==> A'' ! D'') -> cof (OC Ep (fun ([y] with (hnd Cv OCs) (K y)))) (A'' ! D'') -> type.
%mode preservation-with-op +E +Get +AA' +DD' +C -C'.

- : preservation-with-op (cof/op Ei O Ep K ROinD) Get A<A' D<D' (eof/hnd Cv OCs Covers) OC
     <- in-dirt/<d ROinD D<D' ROinD'
     <- instance-expr-in-region Ei IinR
     <- instance-in-region-in-dirt IinR ROinD' IOinD'
     <- <d/refl _ D'<D'
     <- big-lemma IOinD' D'<D' O Ep (eof/fun [x] [e] cof/with (eof/hnd Cv OCs Covers) ((cof/sub (K x e) (<dt/! A<A' D<D')))) Get OCs Covers Covers OC.

- : preservation-with-op (cof/sub E (<dt/! A<A' D<D')) Get A'<A'' D'<D'' C B
     <- <d/trans D<D' D'<D'' D<D''
     <- <t/trans A<A' A'<A'' A<A''
     <- preservation-with-op E Get A<A'' D<D'' C B.

- : preservation-with-op E Get A<A' D<D' (eof/sub C (<t/==> (<dt/! A'<A'' D'<D'') L2)) (cof/sub B L2)
     <- <d/trans D<D' D'<D'' D<D''
     <- <t/trans A<A' A'<A'' A<A''
     <- preservation-with-op E Get A<A'' D<D'' C B.

%worlds (vars) (preservation-with-op _ _ _ _ _ _).
%total {E C} (preservation-with-op E _ _ _ C _).


preservation : cof C A -> C ~> C' -> cof C' A -> type.
%mode preservation +C +S -C'.

- : preservation (cof/cond _ C1 _) ~>/cond-tru C1.

- : preservation (cof/cond _ _ C2) ~>/cond-fls C2.

- : preservation (cof/zro? _) ~>/zro?-zro (cof/val eof/tru).

- : preservation (cof/zro? _) ~>/zro?-suc (cof/val eof/fls).

- : preservation (cof/pred E) S C'
     <- preservation-pred _ E S C'.

- : preservation (cof/app E1 E2) S C'
     <- preservation-app E1 E2 S C'.

- : preservation (cof/let C1 C2) ~>/let-val C'
     <- <d/refl _ D<D
     <- preservation-let-val C1 D<D C2 C'.

- : preservation (cof/let C1 C2) ~>/let-op C'
     <- <d/refl _ D<D
     <- preservation-let-op C1 D<D C2 C'.

- : preservation (cof/let C1 C2) (~>/let-step S) (cof/let C1' C2)
     <- preservation C1 S C1'.

- : preservation (cof/letr C1 C2) S
     (C2 _ (eof/fun ([_] [x] (cof/letr C1 ([_] [f] C1 _ _ f x))))).

- : preservation (cof/with E C) ~>/with-val C'
     <- <dt/refl _ B<B
     <- preservation-with-val C B<B E C'.

- : preservation (cof/with E C) (~>/with-op Get) C'
     <- <t/refl _ A<A
     <- <d/refl _ D<D
     <- preservation-with-op C Get A<A D<D E C'.

- : preservation (cof/with E C) (~>/with-step S) (cof/with E C')
     <- preservation C S C'.

- : preservation (cof/sub C CC') S (cof/sub C' CC')
     <- preservation C S C'.

%worlds (vars) (preservation _ _ _).
%total {C S} (preservation C S _).
