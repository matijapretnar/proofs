%%% Big step semantics preserves the small step semantics %%%

~>/=> : C ~> C' -> C' => R -> C => R -> type.
~>/=>-let : C1 ~> C1' -> let C1' C2 => R -> let C1 C2 => R -> type.
~>/=>-with : C2 ~> C2' -> with E C2' => R -> with E C2 => R -> type.
%mode ~>/=> +C~>C' +C'=>R -C=>R.
%mode ~>/=>-let +C1~C1' +C=>R -C'=>R.
%mode ~>/=>-with +C2~C2' +C=>R -C'=>R.

- : ~>/=> ~>/cond-tru C'=>R (=>/cond-tru C'=>R).

- : ~>/=> ~>/cond-fls C'=>R (=>/cond-fls C'=>R).

- : ~>/=> ~>/mtch-zro C'=>R (=>/mtch-zro C'=>R).

- : ~>/=> ~>/mtch-suc C'=>R (=>/mtch-suc C'=>R).

- : ~>/=> ~>/app C'=>R (=>/app C'=>R).

- : ~>/=> ~>/let-val C'=>R (=>/let-val =>/val C'=>R).

- : ~>/=> ~>/let-op _ (=>/let-op =>/op).

- : ~>/=> (~>/let-step C1~>C1') C'=>R C=>R
     <- ~>/=>-let C1~>C1' C'=>R C=>R.

- : ~>/=> ~>/letr C'=>R (=>/letr C'=>R).

- : ~>/=> ~>/letv C'=>R (=>/letv C'=>R).

- : ~>/=> ~>/with-val C'=>R (=>/with-val =>/val C'=>R).

- : ~>/=> (~>/with-op CO) C'=>R (=>/with-op =>/op CO C'=>R).

- : ~>/=> (~>/with-step C1~>C1') C'=>R C=>R
     <- ~>/=>-with C1~>C1' C'=>R C=>R.


- : ~>/=>-let C1~>C1' (=>/let-val C1'=>E C2E=>R) (=>/let-val C1=>E C2E=>R)
     <- ~>/=> C1~>C1' C1'=>E C1=>E.

- : ~>/=>-let C1~>C1' (=>/let-op C1'=>Op) (=>/let-op C1=>Op)
     <- ~>/=> C1~>C1' C1'=>Op C1=>Op.


- : ~>/=>-with C1~>C1' (=>/with-val C1'=>E C2E=>R) (=>/with-val C1=>E C2E=>R)
     <- ~>/=> C1~>C1' C1'=>E C1=>E.

- : ~>/=>-with C1~>C1' (=>/with-op C1'=>Op OC OC=>R) (=>/with-op C1=>Op OC OC=>R)
     <- ~>/=> C1~>C1' C1'=>Op C1=>Op.

%worlds () (~>/=> _ _ _) (~>/=>-let _ _ _) (~>/=>-with _ _ _).
%total {(C~>C' C1~>C1' C2~>C2') (C'=>R C1C2~>R EC~>R)} (~>/=> C~>C' C'=>R _) (~>/=>-let C1~>C1' C1C2~>R _) (~>/=>-with C2~>C2' EC~>R _).



%%% Reductions inside an evaluation context %%%

~>*-let-val : C1 ~>* result/val E -> C2 E ~>* R -> let C1 C2 ~>* R -> type.
%mode ~>*-let-val +C1~>*E +C2E~>*R -C1C2~>*R.

- : ~>*-let-val ~>*/val C2E~>*R (~>*/step ~>/let-val C2E~>*R).

- : ~>*-let-val (~>*/step C1~>C1' C1'~*>E) C2E~>*R (~>*/step (~>/let-step C1~>C1') C1'C2~>*R)
     <- ~>*-let-val C1'~*>E C2E~>*R C1'C2~>*R.

%worlds () (~>*-let-val _ _ _).
%total {C1~>*E} (~>*-let-val C1~>*E _ _).


~>*-let-op : C1 ~>* result/op IO E K -> {C2} let C1 C2 ~>* result/op IO E ([x] let (K x) C2) -> type.
%mode ~>*-let-op +C1~>*Op +C2 -C1C2~>*Op.

- : ~>*-let-op ~>*/op _ (~>*/step ~>/let-op ~>*/op).

- : ~>*-let-op (~>*/step C1~>C1' C1'~*>Op) C2 (~>*/step (~>/let-step C1~>C1') C1'C2~>*Op)
     <- ~>*-let-op C1'~*>Op C2 C1'C2~>*Op.

%worlds () (~>*-let-op _ _ _).
%total {C1~>*Op} (~>*-let-op C1~>*Op _ _).


~>*-with-val : C ~>* result/val E -> Cv E ~>* R -> {OCs} with (hnd Cv OCs) C ~>* R -> type.
%mode ~>*-with-val +C~>*E +CvE~>*R +OCs -HC~>*R.

- : ~>*-with-val ~>*/val CvE~>*R _ (~>*/step ~>/with-val CvE~>*R).

- : ~>*-with-val (~>*/step C~>C' C'~*>E) CvE~>*R OCs (~>*/step (~>/with-step C~>C') HC~>*R)
     <- ~>*-with-val C'~*>E CvE~>*R OCs HC~>*R.

%worlds () (~>*-with-val _ _ _ _).
%total {C~>*E} (~>*-with-val C~>*E _ _ _).


~>*-with-op :
  C ~>* result/op IO E K
  -> get-op-case IO OCs OC
  -> OC E (fun ([y] with (hnd Cv OCs) (K y))) ~>* R
  -> with (hnd Cv OCs) C ~>* R -> type.
%mode ~>*-with-op +C~>*Op +OC +OC~>*R -HC~>*R.

- : ~>*-with-op ~>*/op OC OC~>*R (~>*/step (~>/with-op OC) OC~>*R).

- : ~>*-with-op (~>*/step C~>C' C'~>*Op) OC OC~>*R (~>*/step (~>/with-step C~>C') HC~>*R)
     <- ~>*-with-op C'~>*Op OC OC~>*R HC~>*R.

%worlds () (~>*-with-op _ _ _ _).
%total {C~>*Op} (~>*-with-op C~>*Op _ _ _).
