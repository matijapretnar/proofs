%%%%% Representation of effects %%%%%
 
% Effects, operation symbols and instances are all just labels,
% and we implement each one with a single constructor that wraps a name.
% Note that operation symbols and instances are distinguished by their effect
% and all start counting from zero.
% We also define operations as pairs of instances and operations.

effect : type.
%name effect Eff.
 
effect/ : name -> effect.
 
 
opsym : effect -> type.
%name opsym O.
 
opsym/ : {Eff} name -> opsym Eff.
 
 
instance : effect -> type.
%name instance I.
 
instance/ : {Eff} name -> instance Eff.


operation : effect -> type.
%name operation IO.
 
# : instance Eff -> opsym Eff -> operation Eff.
%infix none 50 #.



%%% Comparison of operations %%%

% The operations have to be comparable
% so we can always select the right handler case.
% This comparability is inherited from the comparability
% of effects, instances and operation symbols.

apart : operation Eff -> operation Eff' -> type.
%mode apart +IO +I'O'.
 
apart/effect   : apart (instance/ (effect/ X) _ # _) (instance/ (effect/ Y) _ # _)
                   <- apart-name X Y.
apart/instance : apart (instance/ _ X # _) (instance/ _ Y # _)
                   <- apart-name X Y.
apart/opsym    : apart (_ # opsym/ _ X) (_ # opsym/ _ Y)
                   <- apart-name X Y.
 
 
comparable : operation Eff -> operation Eff' -> type.
 
comparable/equal : comparable IO IO.
comparable/apart : comparable IO I'O'
                   <- apart IO I'O'.
