%%% Representation of effects
 
% The original algebraic representation of effects assumes that effects are
% represented with operations of a given algebraic theory. We want to make
% things more practical, so we organize effects hierarchically.
%
% For each *effect* such as exception, I&O channel, or mutable references, we have:
% - A set of *instances*, so one may have multiple copies of a given effect,
%   for example multiple exceptions (assertionFault, invalidArg),
%   various channels (std, stdErr, open files), or multiple references.
% - A set of *operation symbols* that represent actions on given instances,
%   such as raise for exceptions, read and write for channels,
%   or lookup and update for references.
%
% These notions are just labels and do not exhibit any effectful behaviour
% (this will be later given through handlers).
% So each type has a single constructor that just wraps a name.

effect : type.
%name effect Eff.
 
effect/ : name -> effect.
 
 
opsym : effect -> type.
%name opsym O.
 
opsym/ : {Eff} name -> opsym Eff.
 
 
instance : effect -> type.
%name instance I.
 
instance/ : {Eff} name -> instance Eff.


% We trigger effects through *operations*, which are pairs of instances and
% operation symbols with matching effects.
% We write operations as I # O like in Eff, though often refer to them as IO for brevity.
 
operation : effect -> type.
%name operation IO.
 
# : instance Eff -> opsym Eff -> operation Eff.
%infix none 50 #.


% We want decidability of operations so we can select the right handler case.
% This decidability is inherited from the decidability of effects, instances
% and operation symbols.

apart : operation Eff -> operation Eff' -> type.
%mode apart +IO +I'O'.
 
apart/effect   : apart (instance/ (effect/ X) _ # _) (instance/ (effect/ Y) _ # _)
                   <- apart-name X Y.
apart/instance : apart (instance/ _ X # _) (instance/ _ Y # _)
                   <- apart-name X Y.
apart/opsym    : apart (_ # opsym/ _ X) (_ # opsym/ _ Y)
                   <- apart-name X Y.
 
 
decidable : operation Eff -> operation Eff' -> type.
 
decidable/equal : decidable IO IO.
decidable/apart : decidable IO I'O'
                   <- apart IO I'O'.
 


% A finite set of instances belonging to the same effect is called a *region*.
% For the sake of simplicity, we represent regions with lists.
% This representation is sufficient, because we only need to test for containment,
% which we do by "in-region" for instances and "<r" for regions.
 
region : effect -> type.
%name region R.
 
region/empty : region Eff.
region/cons  : instance Eff -> region Eff -> region Eff.
 
 
in-region : instance Eff -> region Eff -> type.
 
in-region/here  : in-region I (region/cons I R).
in-region/there : in-region I (region/cons _ R)
                   <- in-region I R.
 

<r : region Eff -> region Eff -> type.
%infix none 30 <r.
 
<r/empty : region/empty <r R.
<r/cons  : region/cons I R <r R'
            <- R <r R'
            <- in-region I R'.
 


% We indicate potential effects in a computation with *dirt*,
% which is a finite set of operations, which we represent with a list.
% Like regions, we represent dirts with lists, and define "in-dirt" and "<d".

dirt : type.
%name dirt D.
 
dirt/empty : dirt.
dirt/cons  : operation Eff -> dirt -> dirt.
 
 
in-dirt : operation Eff -> dirt -> type.
 
in-dirt/here  : in-dirt IO (dirt/cons IO D).
in-dirt/there : in-dirt IO (dirt/cons _ D)
                 <- in-dirt IO D.
 

<d : dirt -> dirt -> type.
%infix none 30 <d.
 
<d/empty : dirt/empty <d D.
<d/cons  : dirt/cons IO D <d D'
            <- D <d D'
            <- in-dirt IO D'.
 

% Sometimes, the instance of an operation can be determined only up to a region.
% In this case, we use "in-dirt-region R O D", which checks that I#O is in D for every I in R.
 
in-dirt-region : region Eff -> opsym Eff -> dirt -> type.
 
in-dirt-region/empty : in-dirt-region region/empty _ _.
in-dirt-region/cons  : in-dirt-region (region/cons I R) O D
                 <- in-dirt-region R O D
                 <- in-dirt (I # O) D.
