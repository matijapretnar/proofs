%%%%% Operational semantics %%%%%

% In defining both small and big step semantics, we use "get-op-case IO OCs OC",
% such that "OC" is the first operation casein "OCs" that matches the
% operation "IO", or the default handler if there are none.

get-op-case : operation Eff -> op-cases -> op-case -> type.

get-op-case/nil   : get-op-case (I # O) op-cases/nil ([x] [k] op (ins I) O x ([y] app k y)).
get-op-case/here  : get-op-case (I # O) (op-cases/cons (ins I) O OC _) OC.
get-op-case/there : get-op-case IO (op-cases/cons (ins I') O' _ OCs) OC
                     <- apart IO (I' # O')
                     <- get-op-case IO OCs OC.


% The type of final results

result : type.

result/val : expr -> result.
result/op  : operation Eff -> expr -> (expr -> comp) -> result.



%%% Small step semantics %%%

~> : comp -> comp -> type.
%infix none 40 ~>.

~>/cond-tru  : cond tru C1 _ ~> C1.
~>/cond-fls  : cond fls _ C2 ~> C2.
~>/mtch-zro  : mtch zro C1 _ ~> C1.
~>/mtch-suc  : mtch (suc E) _ C2 ~> C2 E.
~>/app       : app (fun E1) E2 ~> E1 E2.
~>/let-val   : let (val E) C2 ~> C2 E.
~>/let-op    : let (op (ins I) O Ep K) C2 ~> op (ins I) O Ep ([x] let (K x) C2).
~>/let-step  : let C1 C2 ~> let C1' C2
                <- C1 ~> C1'.
~>/letr      : letr C1 C2 ~> C2 (fun ([x] letr C1 ([f] C1 f x))).
~>/letv      : letv E C ~> C E.
~>/with-val  : with (hnd Cv _) (val E) ~> Cv E.
~>/with-op   : with (hnd Cv OCs) (op (ins I) O Ep K) ~> OC Ep (fun ([y] with (hnd Cv OCs) (K y)))
                <- get-op-case (I # O) OCs OC.
~>/with-step : with E C ~> with E C'
                <- C ~> C'.


% To state the progress theorem, we need to define when a computation is not stuck

non-stuck : comp -> dirt -> type.

non-stuck/val   : non-stuck (val _) _.
non-stuck/op    : non-stuck (op (ins I) O _ _) D
                   <- in-dirt (I # O) D.
non-stuck/step  : non-stuck C _
                   <- C ~> _.


% The "transitive closure" of the small step relation

~>* : comp -> result -> type.
%infix none 40 ~>*.

~>*/val  : val E ~>* result/val E.
~>*/op   : op (ins I) O E K ~>* result/op (I # O) E K.
~>*/step : C ~>* R
            <- C' ~>* R
            <- C ~> C'.



%%% Big step semantics %%%

=> : comp -> result -> type.
%infix none 40 =>.

=>/cond-tru : cond tru C1 _ => R
               <- C1 => R.
=>/cond-fls : cond fls _ C2 => R
               <- C2 => R.
=>/mtch-zro : mtch zro C1 _ => R
               <- C1 => R.
=>/mtch-suc : mtch (suc E) _ C2 => R
               <- C2 E => R.
=>/app      : app (fun E1) E2 => R
               <- E1 E2 => R.
=>/val      : val E => result/val E.
=>/op       : op (ins I) O E K => result/op (I # O) E K.
=>/let-val  : let C1 C2 => R
               <- C2 E => R
               <- C1 => result/val E.
=>/let-op   : let C1 C2 => result/op IO E ([x] let (K x) C2)
               <- C1 => result/op IO E K.
=>/letr     : letr C1 C2 => R
               <- C2 (fun ([x] letr C1 ([f] C1 f x))) => R.
=>/letv     : letv E C => R
               <- C E => R.
=>/with-val : with (hnd Cv _) C => R
               <- Cv E => R
               <- C => result/val E.
=>/with-op  : with (hnd Cv OCs) C => R
               <- OC E (fun ([y] with (hnd Cv OCs) (K y))) => R
               <- get-op-case IO OCs OC
               <- C => result/op IO E K.


%%% Handler-stack semantics %%%

handler-stack : type.

handler-stack/nil  : handler-stack.
handler-stack/cons : val-case -> op-cases -> handler-stack -> handler-stack.


nest : handler-stack -> comp -> comp -> type.

nest/nil  : nest handler-stack/nil C C.
nest/cons : nest (handler-stack/cons Cv OCs Hs) C C'
             <- nest Hs (with (hnd Cv OCs) C) C'.


stack-eval : handler-stack -> comp -> expr -> type.

stack-eval/cond-tru : stack-eval Hs (cond tru C1 _) E
                       <- stack-eval Hs C1 E.
stack-eval/cond-fls : stack-eval Hs (cond fls _ C2) E
                       <- stack-eval Hs C2 E.
stack-eval/mtch-zro : stack-eval Hs (mtch zro C1 _) E
                       <- stack-eval Hs C1 E.
stack-eval/mtch-suc : stack-eval Hs (mtch (suc E) _ C2) E'
                       <- stack-eval Hs (C2 E) E'.
stack-eval/app      : stack-eval Hs (app (fun E1) E2) E
                       <- stack-eval Hs (E1 E2) E.
stack-eval/val-nil  : stack-eval handler-stack/nil (val E) E.
stack-eval/val-cons : stack-eval (handler-stack/cons Cv _ Hs) (val E) E'
                       <- stack-eval Hs (Cv E) E'.
stack-eval/op-cons  : stack-eval (handler-stack/cons _ OCs Hs) (op (ins I) O E K) E'
                       <- get-op-case (I # O) OCs OC
                       <- stack-eval Hs (OC E (fun ([y] with (hnd Cv OCs) (K y)))) E'.
stack-eval/let      : stack-eval Hs (let C1 C2) E
                       <- stack-eval (handler-stack/cons C2 op-cases/nil Hs) C1 E.
stack-eval/letr     : stack-eval Hs (letr C1 C2) E
                       <- stack-eval Hs (C2 (fun ([x] letr C1 ([f] C1 f x)))) E.
stack-eval/letv     : stack-eval Hs (letv E C) E'
                       <- stack-eval Hs (C E) E'.
stack-eval/with     : stack-eval Hs (with (hnd Cv OCs) C) E
                       <- stack-eval (handler-stack/cons Cv OCs Hs) C E.
