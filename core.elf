% The core language of Eff

% Meta-level booleans, not to be confused with bool of Eff.
decide : type. %name decide YesNo.
yes : decide.
no : decide.

conj : decide -> decide -> decide -> type.
%mode conj +D1 +D2 -D3.
- : conj yes D D.
- : conj no _ no.

%worlds () (conj _ _ _).
%total {D1 D2} (conj D1 D2 _).

%%% Operations and instances

operation : type. %name operation Op.
operation/z : operation.
operation/s : operation -> operation.

%worlds () (operation).

eq-operation : operation -> operation -> decide -> type.
- : eq-operation operation/z operation/z yes.
- : eq-operation operation/z (operation/s _) no.
- : eq-operation (operation/s _) operation/z no.
- : eq-operation (operation/s O) (operation/s O') D
     <- eq-operation O O' D.
%mode eq-operation +O +O' -D.

%worlds () (eq-operation _ _ _).
%total {O O'} (eq-operation O O' _).

instance : type. %name instance Iota.
instance/z : instance.
instance/s : instance -> instance.

%worlds () (instance).

eq-instance : instance -> instance -> decide -> type.
- : eq-instance instance/z instance/z yes.
- : eq-instance instance/z (instance/s _) no.
- : eq-instance (instance/s _) instance/z no.
- : eq-instance (instance/s I) (instance/s I') D
     <- eq-instance I I' D.
%mode eq-instance +I +I' -D.

%worlds () (eq-instance _ _ _).
%total {I I'} (eq-instance I I' _).

eq-instance-operation : instance -> operation -> instance -> operation -> decide -> type.
%mode eq-instance-operation +I1 +O1 +I2 +O2 -D.

- : eq-instance-operation I1 O1 I2 O2 D
     <- eq-instance I1 I2 D1
     <- eq-operation O1 O2 D2
     <- conj D1 D2 D.

%worlds () (eq-instance-operation _ _ _ _ _).
%total {I1 O1 I2 O2} (eq-instance-operation I1 O1 I2 O2 _).

%%% Regions

region : type. %name region Rho.

region/empty : region.
region/cons  : instance -> region -> region.

in-region : instance -> region -> type.

in-region/here  : in-region I (region/cons I R).
in-region/there : in-region I (region/cons _ R)
		   <- in-region I R.

%%% Dirt

dirt : type. %name dirt Delta.

dirt/empty : dirt.
dirt/cons  : instance -> operation -> dirt -> dirt.


in-dirt-instance : instance -> operation -> dirt -> type.

in-dirt-instance/here  : in-dirt-instance I O (dirt/cons I O D).
in-dirt-instance/there : in-dirt-instance I O (dirt/cons _ _ D)
			  <- in-dirt-instance I O D.

in-dirt : region -> operation -> dirt -> type.

in-dirt/empty : in-dirt region/empty _ _.
in-dirt/cons  : in-dirt (region/cons I R) O D
		 <- in-dirt R O D
		 <- in-dirt-instance I O D.

%%% Types

ty : type. %name ty A.
effty : type. %name effty E.
dirty : type. %name dirty D.

effty/empty : effty.
effty/cons : operation -> ty -> ty -> effty -> effty.

in-effty : operation -> ty -> ty -> effty -> type.
in-effty/here : in-effty O A B (effty/cons O A B _).
in-effty/there : in-effty O A B (effty/cons _ _ _ E)
                  <- in-effty O A B E.

nat   : ty.
bool  : ty.
unit  : ty.
empty : ty.
eff  : effty -> region -> ty.
--> : ty -> dirty -> ty. %infix right 50 -->.
==> : dirty -> dirty -> ty. %infix right 55 ==>.

! : ty -> dirt -> dirty. %infix none 60 !.

%%%% Expressions and computations

expr : type. %name expr E.
comp : type. %name comp C.

% We make some wrapper types because Twelf complains
% when we try to use continuations directly.

cont : type. %name cont K.
cont/wrap : (expr -> comp) -> cont.
%abbrev cc = cont/wrap.

handler-case : type. %name handler-case HK.
handler-case/wrap : (expr -> (expr -> comp) -> comp) -> handler-case.
%abbrev hc = handler-case/wrap.

handler : type. %name handler H.
handler/val : cont -> handler.
handler/op : expr -> operation -> handler-case -> handler -> handler.

zro : expr.
suc : expr -> expr.
tru : expr.
fls : expr.
unt : expr.
ins : instance -> expr.
fun : (expr -> comp) -> expr.
hnd : handler -> expr.

val  : expr -> comp.
op   : expr -> operation -> expr -> (expr -> comp) -> comp.
let  : comp -> (expr -> comp) -> comp.
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp.
zro? : expr -> comp.
cond : expr -> comp -> comp -> comp.
absd : expr -> comp.
app  : expr -> expr -> comp.
handle : expr -> comp -> comp.

%%%% Typing judgments

% Primitive assignment of types to instances.
iof : instance -> effty -> type.

%block iof-var : some {I : instance} {E : effty} block {i : iof I E}.
%worlds (iof-var) (iof _ _).

eof : expr -> ty -> type.
cof : comp -> dirty -> type.

region-ok : region -> effty -> type.
region-ok/empty : region-ok region/empty _.
region-ok/cons : region-ok (region/cons I R) E
                  <- region-ok R E
                  <- iof I E.

%worlds (iof-var) (region-ok _ _).

eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
	   <- eof E nat.
eof/tru : eof tru bool.
eof/fls : eof fls bool.
eof/unt : eof unt unit.
eof/ins : eof (ins I) (eff E R)
           <- iof I E
	   <- in-region I R
           <- region-ok R E.
eof/fun : eof (fun C) (A --> B)
	   <- ({x} eof x A -> cof (C x) B).

eof/hnd-val : eof (hnd (handler/val (cc C))) ((A ! D) ==> B)
               <- ({x} eof x A -> cof (C x) B).

eof/hnd-op : eof (hnd (handler/op E O (hc HC) H)) (A ==> B)
              <- eof (hnd H) (A ==> B)
              <- ({x} eof x A' -> {k : expr -> comp} ({y} eof y B' -> cof (k y) B) -> cof (HC x k) B)
              <- in-effty O A' B' Eff
              <- region-ok R Eff
              <- eof E (eff Eff R).

cof/val  : cof (val E) (A ! D)
	    <- eof E A.
cof/op   : cof (op Ei O Ep K) (B ! D)
	    <- in-dirt R O D
	    <- ({x} eof x A' -> cof (K x) (B ! D))
	    <- eof Ep A
	    <- in-effty O A A' E
	    <- eof Ei (eff E R).
cof/let  : cof (let C1 C2) (B ! D)
	    <- ({x} eof x A -> cof (C2 x) (B ! D))
	    <- cof C1 (A ! D).
cof/letr : cof (letr C1 C2) B
	    <- ({f} eof f (A --> A') -> cof (C2 f) B)
	    <- ({f} {x} eof f (A --> A') -> eof x A -> cof (C1 f x) A').
cof/zro? : cof (zro? E) (bool ! D)
	    <- eof E nat.
cof/cond : cof (cond E C1 C2) A
	    <- cof C2 A
	    <- cof C1 A
	    <- eof E bool.
cof/absd : cof (absd E) A
	    <- eof E empty.
cof/app  : cof (app E1 E2) B
	    <- eof E2 A
	    <- eof E1 (A --> B).
cof/handle : cof (handle E C) B
              <- cof C A
              <- eof E (A ==> B).

%worlds () (eof _ _) (cof _ _).

%%%% Operational semantics

% Get the "val x" case of a handler
handler-get-val : handler -> cont -> type.
%mode handler-get-val +Handler -Kont.

handler-get-val/val : handler-get-val (handler/val Kont) Kont.
handler-get-val/op : handler-get-val (handler/op _ _ _ Handler') Kont
                      <- handler-get-val Handler' Kont.

%worlds () (handler-get-val _ _).
% We could prove totality, but that's more of an accident. We really need
% effectiveness lemmas
% %total {Handler} (handler-get-val Handler _).

% Auxiliary function
if-then-handler-case : decide -> handler-case -> handler-case -> handler-case -> type.
%mode if-then-handler-case +D +HK1 +HK2 -HK3.

- : if-then-handler-case yes HK _  HK.
- : if-then-handler-case no  _  HK HK.

%worlds () (if-then-handler-case _ _ _ _).
%total {D} (if-then-handler-case D _ _ _).

handler-get-op : handler -> instance -> operation -> handler-case -> type.
%mode handler-get-op +Handler +Instance +Operation -HandlerKont.

handler-get-op/val : handler-get-op (handler/val _) I O (hc (op (ins I) O)).

handler-get-op/op : handler-get-op (handler/op (ins I) O HK H) I' O' HK''
                      <- eq-instance-operation I O I' O' D
                      <- handler-get-op H I' O' HK'
                      <- if-then-handler-case D HK HK' HK''.

%worlds () (handler-get-op _ _ _ _).
% We cannot check totality of handler-get-op because it is not actually
% total without assuming that the handler is well typed!

% Small-step semantics

step : comp -> comp -> type.

step/let-val  : step (let (val E) C2) (C2 E).
step/let-op   : step (let (op Ei O Ep K) C2) (op Ei O Ep ([y] let (K y) C2)).
step/let-step : step (let C1 C2) (let C1' C2)
		 <- step C1 C1'.
step/letr     : step (letr C1 C2) (C2 (fun ([y] letr C1 ([f] C1 f y)))).
step/zro?-zro : step (zro? zro) (val tru).
step/zro?-suc : step (zro? (suc _)) (val fls).
step/cond-tru : step (cond tru C1 _) C1.
step/cond-fls : step (cond fls _ C2) C2.
step/app      : step (app (fun E1) E2) (E1 E2).

step/handle-step : step (handle E C) (handle E C')
                    <- step C C'.

step/handle-val : step (handle (hnd H) (val E)) (K E)
                   <- handler-get-val H (cc K).

step/handle-op : step (handle (hnd H) (op (ins I) O E K)) (HK E ([y] handle (hnd H) (K y)))
                  <- handler-get-op H I O (hc HK).
