% The core language of Eff

decide : type.
yes : decide.
no : decide.

%%% Operations and instances

operation : type. %name operation Op.
operation/z : operation.
operation/s : operation -> operation.

eq-operation : operation -> operation -> decide -> type.
- : eq-operation operation/z operation/z yes.
- : eq-operation operation/z (operation/s _) no.
- : eq-operation (operation/s _) operation/z no.
- : eq-operation (operation/s O) (operation/s O') D
     <- eq-operation O O' D.
%mode eq-operation +O +O' -D.

%worlds () (eq-operation _ _ _).
%total {O O'} (eq-operation O O' _).

instance : type. %name instance Iota.
instance/z : instance.
instance/s : instance -> instance.

eq-instance : instance -> instance -> decide -> type.
- : eq-instance instance/z instance/z yes.
- : eq-instance instance/z (instance/s _) no.
- : eq-instance (instance/s _) instance/z no.
- : eq-instance (instance/s I) (instance/s I') D
     <- eq-instance I I' D.
%mode eq-instance +I +I' -D.

%worlds () (eq-instance _ _ _).
%total {I I'} (eq-instance I I' _).

%%% Regions

region : type. %name region Rho.

region/empty : region.
region/cons  : instance -> region -> region.

in-region : instance -> region -> type.

in-region/here  : in-region I (region/cons I R).
in-region/there : in-region I (region/cons _ R)
		   <- in-region I R.

%%% Dirt

dirt : type. %name dirt Delta.

dirt/empty : dirt.
dirt/cons  : instance -> operation -> dirt -> dirt.


in-dirt-instance : instance -> operation -> dirt -> type.

in-dirt-instance/here  : in-dirt-instance I O (dirt/cons I O D).
in-dirt-instance/there : in-dirt-instance I O (dirt/cons _ _ D)
			  <- in-dirt-instance I O D.

in-dirt : region -> operation -> dirt -> type.

in-dirt/empty : in-dirt region/empty _ _.
in-dirt/cons  : in-dirt (region/cons I R) O D
		 <- in-dirt R O D
		 <- in-dirt-instance I O D.

%%% Types

ty : type. %name ty A.
effty : type. %name effty E.
dirty : type. %name dirty D.

effty/empty : effty.
effty/cons : operation -> ty -> ty -> effty -> effty.

in-effty : operation -> ty -> ty -> effty -> type.
in-effty/here : in-effty O A B (effty/cons O A B _).
in-effty/there : in-effty O A B (effty/cons _ _ _ E)
                  <- in-effty O A B E.

nat   : ty.
bool  : ty.
unit  : ty.
empty : ty.
eff  : effty -> region -> ty.
--> : ty -> dirty -> ty. %infix right 50 -->.
==> : dirty -> dirty -> ty. %infix right 55 ==>.

! : ty -> dirt -> dirty. %infix none 60 !.

%%%% Expressions and computations

expr : type. %name expr E.
comp : type. %name comp C.

handler-val-case : type. %name handler-val-case HVC.
handler-val-case/make : (expr -> comp) -> handler-val-case.
%abbrev hvc = handler-val-case/make.

handler-op-case : type. %name handler-op-case HOC.
handler-op-case/make : (expr -> (expr -> comp) -> comp) -> handler-op-case.
%abbrev hoc = handler-op-case/make.

handler : type.
handler/val : handler-val-case -> handler.
handler/op : expr -> operation -> handler-op-case -> handler -> handler.

zro : expr.
suc : expr -> expr.
tru : expr.
fls : expr.
unt : expr.
ins : instance -> expr.
fun : (expr -> comp) -> expr.
hnd : handler -> expr.

val  : expr -> comp.
op   : expr -> operation -> expr -> (expr -> comp) -> comp.
let  : comp -> (expr -> comp) -> comp.
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp.
zro? : expr -> comp.
cond : expr -> comp -> comp -> comp.
absd : expr -> comp.
app  : expr -> expr -> comp.
handle : expr -> comp -> comp.

%%%% Typing judgments

iof : instance -> effty -> type.
eof : expr -> ty -> type.
cof : comp -> dirty -> type.

region-ok : region -> effty -> type.
region-ok/empty : region-ok region/empty _.
region-ok/cons : region-ok (region/cons I R) E
                  <- region-ok R E
                  <- iof I E.

eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
	   <- eof E nat.
eof/tru : eof tru bool.
eof/fls : eof fls bool.
eof/unt : eof unt unit.
eof/ins : eof (ins I) (eff E R)
           <- iof I E
	   <- in-region I R
           <- region-ok R E.
eof/fun : eof (fun C) (A --> B)
	   <- ({x} eof x A -> cof (C x) B).

eof/hnd-val : eof (hnd (handler/val (hvc C))) ((A ! D) ==> B)
               <- ({x} eof x A -> cof (C x) B).

eof/hnd-op : eof (hnd (handler/op E O (hoc HC) H)) (A ==> B)
              <- eof (hnd H) (A ==> B)
              <- ({x} eof x A' -> {k : expr -> comp} ({y} eof y B' -> cof (k y) B) -> cof (HC x k) B)
              <- in-effty O A' B' Eff
              <- region-ok R Eff
              <- eof E (eff Eff R).

cof/val  : cof (val E) (A ! D)
	    <- eof E A.
cof/op   : cof (op Ei O Ep K) (B ! D)
	    <- in-dirt R O D
	    <- ({x} eof x A' -> cof (K x) (B ! D))
	    <- eof Ep A
	    <- in-effty O A A' E
	    <- eof Ei (eff E R).
cof/let  : cof (let C1 C2) (B ! D)
	    <- ({x} eof x A -> cof (C2 x) (B ! D))
	    <- cof C1 (A ! D).
cof/letr : cof (letr C1 C2) B
	    <- ({f} eof f (A --> A') -> cof (C2 f) B)
	    <- ({f} {x} eof f (A --> A') -> eof x A -> cof (C1 f x) A').
cof/zro? : cof (zro? E) (bool ! D)
	    <- eof E nat.
cof/cond : cof (cond E C1 C2) A
	    <- cof C2 A
	    <- cof C1 A
	    <- eof E bool.
cof/absd : cof (absd E) A
	    <- eof E empty.
cof/app  : cof (app E1 E2) B
	    <- eof E2 A
	    <- eof E1 (A --> B).
cof/handle : cof (handle E C) B
              <- cof C A
              <- eof E (A ==> B).

%%%% Operational semantics

handler-get-val : handler -> handler-val-case -> type.
%mode handler-get-val +H -HVC.

handler-get-val/val : handler-get-val (handler/val C) C.
handler-get-val/op : handler-get-val (handler/op _ _ _ H) C
                      <- handler-get-val H C.

%worlds () (handler-get-val _ _).
%total {H} (handler-get-val H _).

handler-get-op : handler -> instance -> operation -> handler-op-case -> type.
%mode handler-get-op +H +I +O -HOC.

handler-get-op/empty : handler-get-op (handler/val C) I' O' (hoc [x] [k] op (ins I') O' x k).

handler-get-op/hit : handler-get-op (handler/op (ins I) O K H) I' O' K
                      <- eq-instance I I' yes
                      <- eq-operation O O' yes.

handler-get-val/miss-I : handler-get-op (handler/op (ins I) O K H) I' O' K
                           <- handler-get-op H I' O' K
                           <- eq-instance I I' no.

handler-get-val/misso-O : handler-get-op (handler/op I O K H) I' O' K
                      <- handler-get-op H I' O' K
                      <- eq-operation O O' no.

%worlds () (handler-get-op _ _ _ _).
%total {H I O} (handler-get-op H I O _).


step : comp -> comp -> type.

step/let-val  : step (let (val E) C2) (C2 E).
step/let-op   : step (let (op Ei O Ep K) C2) (op Ei O Ep ([y] let (K y) C2)).
step/let-step : step (let C1 C2) (let C1' C2)
		 <- step C1 C1'.
step/letr     : step (letr C1 C2) (C2 (fun ([y] letr C1 ([f] C1 f y)))).
step/zro?-zro : step (zro? zro) (val tru).
step/zro?-suc : step (zro? (suc _)) (val fls).
step/cond-tru : step (cond tru C1 _) C1.
step/cond-fls : step (cond fls _ C2) C2.
step/app      : step (app (fun E1) E2) (E1 E2).

step/handle-step : step (handle E C) (handle E C')
                    <- step C C'.

step/handle-val : {C} step (handle (hnd H) (val E)) (C E)
                   <- handler-get-val H (hvc C).

step/handle-op : step (handle (hnd H) (op (ins I) O E K)) (C E ([y] handle (hnd H) (K y)))
                  <- handler-get-op H I O (hoc C).

%block var-effty : block {e : effty}.
%block var-instance : some {E : effty} block {i : instance}{_ : iof i E}.
%block vars = (var-effty | var-instance).
