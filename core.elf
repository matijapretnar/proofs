% The core language of Eff



%%%%{ Effect signature }%%%%%

effect : type.

%block var-effect : block {eff : effect}.

operation : effect -> type.

instance : effect -> type.

%block var-instance : some {E : effect} block {inst : instance E}.

%%%%{ Types }%%%%%

region : effect -> type.

region/empty : region E.
region/cons  : instance E -> region E -> region E.


in-region : instance E -> region E -> type.

in-region/here  : in-region I (region/cons I R).
in-region/there : in-region I (region/cons _ R)
		   <- in-region I R.

<=r : region E -> region E -> type. %infix none 30 <=r.

<=r/empty : region/empty <=r R.
<=r/cons : region/cons I R <=r R'
	    <- R <=r R'
	    <- in-region I R'.


dirt : type.

dirt/empty : dirt.
dirt/cons  : instance E -> operation E -> dirt -> dirt.


in-dirt-instance : instance E -> operation E -> dirt -> type.

in-dirt-instance/here  : in-dirt-instance I O (dirt/cons I O D).
in-dirt-instance/there : in-dirt-instance I O (dirt/cons _ _ D)
			  <- in-dirt-instance I O D.

<=d : dirt -> dirt -> type. %infix none 30 <=d.

<=d/empty : dirt/empty <=d D.
<=d/cons : dirt/cons I O D <=d D'
	    <- D <=d D'
	    <- in-dirt-instance I O D'.

in-dirt : region E -> operation E -> dirt -> type.

in-dirt/empty : in-dirt region/empty _ _.
in-dirt/cons  : in-dirt (region/cons I R) O D
		 <- in-dirt R O D
		 <- in-dirt-instance I O D.


ty : type.
dirty : type.

nat   : ty.
bool  : ty.
unit  : ty.
empty : ty.
inst  : region E -> ty.
--> : ty -> dirty -> ty. %infix right 50 -->.
==> : dirty -> dirty -> ty. %infix right 55 ==>.

! : ty -> dirt -> dirty. %infix none 60 !.

<=t : ty -> ty -> type. %infix none 30 <=t.
<=dt : dirty -> dirty -> type. %infix none 30 <=dt.

<=t/nat : nat <=t nat.
<=t/bool : bool <=t bool.
<=t/unit : unit <=t unit.
<=t/empty : empty <=t empty.
<=t/inst : inst R <=t inst R'
	    <- R <=r R'.
<=t/--> : (A --> B) <=t (A' --> B')
	   <- B <=dt B'
	   <- A' <=t A.
<=t/==> : (A ==> B) <=t (A' ==> B')
	   <- B <=dt B'
	   <- A' <=dt A.
<=dt/! : (A ! D) <=dt (A' ! D')
	  <- D <=d D'
	  <- A <=t A'.




sig : operation E -> ty -> ty -> type.

%block var-operation : some {E : effect} {A : ty} {B : ty} block {op : operation E}{_ : sig op A B}.
%block vars = (var-effect | var-instance | var-operation).

%%%%{ Expressions and computations }%%%%%

expr : type.
comp : type.

zro : expr.
suc : expr -> expr.
tru : expr.
fls : expr.
unt : expr.
ins : instance E -> expr.
fun : (expr -> comp) -> expr.

val  : expr -> comp.
op   : expr -> operation E -> expr -> (expr -> comp) -> comp.
let  : comp -> (expr -> comp) -> comp.
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp.
zro? : expr -> comp.
pred : expr -> comp.
cond : expr -> comp -> comp -> comp.
absd : expr -> comp.
app  : expr -> expr -> comp.



%%%%{ Typing judgements }%%%%%

eof : expr -> ty -> type.
cof : comp -> dirty -> type.

eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
	   <- eof E nat.
eof/tru : eof tru bool.
eof/fls : eof fls bool.
eof/unt : eof unt unit.
eof/ins : eof (ins I) (inst R)
	   <- in-region I R.
eof/fun : eof (fun E) (A --> B)
	   <- ({x} eof x A -> cof (E x) B).
eof/sub : eof E A'
	   <- A <=t A'
	   <- eof E A.

cof/val  : cof (val E) (A ! D)
	    <- eof E A.
cof/op   : cof (op Ei O Ep K) (B ! D)
	    <- in-dirt R O D
	    <- ({x} eof x A' -> cof (K x) (B ! D))
	    <- eof Ep A
	    <- sig O A A'
	    <- eof Ei (inst (R : region E)).
cof/let  : cof (let C1 C2) (B ! D)
	    <- ({x} eof x A -> cof (C2 x) (B ! D))
	    <- cof C1 (A ! D).
cof/letr : cof (letr C1 C2) B
	    <- ({f} eof f (A --> A') -> cof (C2 f) B)
	    <- ({f} {x} eof f (A --> A') -> eof x A -> cof (C1 f x) A').
cof/zro? : cof (zro? E) (bool ! D)
	    <- eof E nat.
cof/pred : cof (pred E) (nat ! D)
	    <- eof E nat.
cof/cond : cof (cond E C1 C2) A
	    <- cof C2 A
	    <- cof C1 A
	    <- eof E bool.
cof/absd : cof (absd E) A
	    <- eof E empty.
cof/app  : cof (app E1 E2) B
	    <- eof E2 A
	    <- eof E1 (A --> B).
cof/sub  : cof C B'
	    <- B <=dt B'
	    <- cof C B.



%%%%{ Operational semantics }%%%%%

step : comp -> comp -> type.

step/let-val  : step (let (val E) C2) (C2 E).
step/let-op   : step (let (op Ei O Ep K) C2) (op Ei O Ep ([y] let (K y) C2)).
step/let-step : step (let C1 C2) (let C1' C2)
		 <- step C1 C1'.
step/letr     : step (letr C1 C2) (C2 (fun ([y] letr C1 ([f] C1 f y)))).
step/zro?-zro : step (zro? zro) (val tru).
step/zro?-suc : step (zro? (suc _)) (val fls).
step/pred-zro : step (pred zro) (val zro).
step/pred-suc : step (pred (suc E)) (val E).
step/cond-tru : step (cond tru C1 _) C1.
step/cond-fls : step (cond fls _ C2) C2.
step/app      : step (app (fun E1) E2) (E1 E2).


<=r/rest : {E} {I : instance E} {R : region E} R <=r (region/cons I R) -> type. 
%mode <=r/rest +E +I +R -RIR.

- : <=r/rest _ _ _ <=r/empty.

%worlds (vars) (<=r/rest _ _ _ _).
%trustme %total {} (<=r/rest _ _ _ _).

<=r/refl : {R} R <=r R -> type.
%mode <=r/refl +R -RR.

- : <=r/refl region/empty <=r/empty.
- : <=r/refl (region/cons I R) (<=r/cons in-region/here RIR)
     <- <=r/rest _ _ R RIR.

%worlds (vars) (<=r/refl _ _).
%total {} (<=r/refl _ _).

<=d/rest : {E} {D} {I : instance E} {O} D <=d (dirt/cons I O D) -> type. 
%mode <=d/rest +E +D +I +O -DIOD.

- : <=d/rest _ _ _ _ <=d/empty.

%worlds (vars) (<=d/rest _ _ _ _ _).
%trustme %total {} (<=d/rest _ _ _ _ _).

<=d/refl : {D} D <=d D -> type.
%mode <=d/refl +D -DD.

- : <=d/refl dirt/empty <=d/empty.
- : <=d/refl (dirt/cons I O D) (<=d/cons in-dirt-instance/here DIOD)
     <- <=d/rest _ D I O DIOD.

%worlds (vars) (<=d/refl _ _).
%total {} (<=d/refl _ _).

<=t/refl : {A} A <=t A -> type.
%mode <=t/refl +A -AA.
<=dt/refl : {B} B <=dt B -> type.
%mode <=dt/refl +B -BB.

- : <=t/refl nat <=t/nat.
- : <=t/refl bool <=t/bool.
- : <=t/refl unit <=t/unit.
- : <=t/refl empty <=t/empty.
- : <=t/refl (inst R) (<=t/inst RR)
     <- <=r/refl R RR.
- : <=t/refl (A --> B) (<=t/--> AA BB)
     <- <=t/refl A AA
     <- <=dt/refl B BB.
- : <=t/refl (A ==> B) (<=t/==> AA BB)
     <- <=dt/refl A AA
     <- <=dt/refl B BB.
- : <=dt/refl (A ! D) (<=dt/! AA DD)
     <- <=t/refl A AA
     <- <=d/refl D DD.

%worlds (vars) (<=t/refl _ _) (<=dt/refl _ _).
%total {(A B)} (<=t/refl A _) (<=dt/refl B _).

<=d/in-dirt-instance : in-dirt-instance I O D -> D <=d D' -> in-dirt-instance I O D' -> type.
%mode <=d/in-dirt-instance +IiD +DD' -IiD'.

- : <=d/in-dirt-instance in-dirt-instance/here (<=d/cons IiD' _) IiD'.
- : <=d/in-dirt-instance (in-dirt-instance/there IiD) (<=d/cons _ DD') IiD'
     <- <=d/in-dirt-instance IiD DD' IiD'.

%worlds (vars) (<=d/in-dirt-instance _ _ _).
%total {IiD} (<=d/in-dirt-instance IiD _ _).

<=d/in-dirt : in-dirt R O D -> D <=d D' -> in-dirt R O D' -> type.
%mode <=d/in-dirt +RiD +DD' -RiD'.

- : <=d/in-dirt in-dirt/empty _ in-dirt/empty.
- : <=d/in-dirt (in-dirt/cons IiD RiD) DD' (in-dirt/cons IiD' RiD')
     <- <=d/in-dirt-instance IiD DD' IiD'
     <- <=d/in-dirt RiD DD' RiD'.

%worlds (vars) (<=d/in-dirt _ _ _).
%total {IiR} (<=d/in-dirt IiR _ _).

<=d/trans : D <=d D' -> D' <=d D'' -> D <=d D'' -> type.
%mode <=d/trans +DD' +D'D'' -DD''.

- : <=d/trans <=d/empty _ <=d/empty.
- : <=d/trans (<=d/cons IOD' DD') D'D'' (<=d/cons IOD'' DD'')
     <- <=d/trans DD' D'D'' DD''
     <- <=d/in-dirt-instance IOD' D'D'' IOD''.

%worlds (vars) (<=d/trans _ _ _).
%total {DD'} (<=d/trans DD' _ _).

<=d/in-dirt : in-dirt R O D -> D <=d D' -> in-dirt R O D' -> type.
%mode <=d/in-dirt +RiD +DD' -RiD'.

- : <=d/in-dirt in-dirt/empty _ in-dirt/empty.
- : <=d/in-dirt (in-dirt/cons IiD RiD) DD' (in-dirt/cons IiD' RiD')
     <- <=d/in-dirt RiD DD' RiD'
     <- <=d/in-dirt-instance IiD DD' IiD'.

%worlds (vars) (<=d/in-dirt _ _ _).
%total {RiD} (<=d/in-dirt RiD _ _).


instance-in-region-in-dirt : in-region I R -> in-dirt R O D -> in-dirt-instance I O D -> type.
%mode instance-in-region-in-dirt +IinR +ROinD -IOinD.

%worlds (vars) (instance-in-region-in-dirt _ _ _).
%trustme %total {} (instance-in-region-in-dirt _ _ _).


<=r/in-dirt : R <=r R' -> in-dirt R' O D -> in-dirt R O D -> type.
%mode <=r/in-dirt +RR' +R'OinD -ROinD.

%worlds (vars) (<=r/in-dirt _ _ _).
%trustme %total {} (<=r/in-dirt _ _ _).

