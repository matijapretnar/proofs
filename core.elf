% The core language of Eff

%%% Operations and instances

operation : type. %name operation Op.
operation/z : operation.
operation/s : operation -> operation.

instance : type. %name instance Iota.
instance/z : instance.
instance/s : instance -> instance.

%%% Regions

region : type. %name region Rho.

region/empty : region.
region/cons  : instance -> region -> region.

in-region : instance -> region -> type.

in-region/here  : in-region I (region/cons I R).
in-region/there : in-region I (region/cons _ R)
		   <- in-region I R.

%%% Dirt

dirt : type. %name dirt Delta.

dirt/empty : dirt.
dirt/cons  : instance -> operation -> dirt -> dirt.


in-dirt-instance : instance -> operation -> dirt -> type.

in-dirt-instance/here  : in-dirt-instance I O (dirt/cons I O D).
in-dirt-instance/there : in-dirt-instance I O (dirt/cons _ _ D)
			  <- in-dirt-instance I O D.

in-dirt : region -> operation -> dirt -> type.

in-dirt/empty : in-dirt region/empty _ _.
in-dirt/cons  : in-dirt (region/cons I R) O D
		 <- in-dirt R O D
		 <- in-dirt-instance I O D.

%%% Types

ty : type. %name ty A.
effty : type. %name effty E.
dirty : type. %name dirty D.

effty/empty : effty.
effty/cons : operation -> ty -> ty -> effty -> effty.

in-effty : operation -> ty -> ty -> effty -> type.
in-effty/here : in-effty O A B (effty/cons O A B _).
in-effty/there : in-effty O A B (effty/cons _ _ _ E)
                  <- in-effty O A B E.

nat   : ty.
bool  : ty.
unit  : ty.
empty : ty.
eff  : effty -> region -> ty.
--> : ty -> dirty -> ty. %infix right 50 -->.
==> : dirty -> dirty -> ty. %infix right 55 ==>.

! : ty -> dirt -> dirty. %infix none 60 !.

%%%% Expressions and computations

expr : type. %name expr E.
comp : type. %name comp C.

zro : expr.
suc : expr -> expr.
tru : expr.
fls : expr.
unt : expr.
ins : instance -> expr.
fun : (expr -> comp) -> expr.

val  : expr -> comp.
op   : expr -> operation -> expr -> (expr -> comp) -> comp.
let  : comp -> (expr -> comp) -> comp.
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp.
zro? : expr -> comp.
cond : expr -> comp -> comp -> comp.
absd : expr -> comp.
app  : expr -> expr -> comp.

%%%% Typing judgments

iof : instance -> effty -> type.
eof : expr -> ty -> type.
cof : comp -> dirty -> type.

region-ok : region -> effty -> type.
region-ok/empty : region-ok region/empty _.
region-ok/cons : region-ok (region/cons I R) E
                  <- region-ok R E
                  <- iof I E.

eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
	   <- eof E nat.
eof/tru : eof tru bool.
eof/fls : eof fls bool.
eof/unt : eof unt unit.
eof/ins : eof (ins I) (eff E R)
           <- iof I E
	   <- in-region I R
           <- region-ok R E.
eof/fun : eof (fun E) (A --> B)
	   <- ({x} eof x A -> cof (E x) B).

cof/val  : cof (val E) (A ! D)
	    <- eof E A.
cof/op   : cof (op Ei O Ep K) (B ! D)
	    <- in-dirt R O D
	    <- ({x} eof x A' -> cof (K x) (B ! D))
	    <- eof Ep A
	    <- in-effty O A A' E
	    <- eof Ei (eff E R).
cof/let  : cof (let C1 C2) (B ! D)
	    <- ({x} eof x A -> cof (C2 x) (B ! D))
	    <- cof C1 (A ! D).
cof/letr : cof (letr C1 C2) B
	    <- ({f} eof f (A --> A') -> cof (C2 f) B)
	    <- ({f} {x} eof f (A --> A') -> eof x A -> cof (C1 f x) A').
cof/zro? : cof (zro? E) (bool ! D)
	    <- eof E nat.
cof/cond : cof (cond E C1 C2) A
	    <- cof C2 A
	    <- cof C1 A
	    <- eof E bool.
cof/absd : cof (absd E) A
	    <- eof E empty.
cof/app  : cof (app E1 E2) B
	    <- eof E2 A
	    <- eof E1 (A --> B).

%%%% Operational semantics

step : comp -> comp -> type.

step/let-val  : step (let (val E) C2) (C2 E).
step/let-op   : step (let (op Ei O Ep K) C2) (op Ei O Ep ([y] let (K y) C2)).
step/let-step : step (let C1 C2) (let C1' C2)
		 <- step C1 C1'.
step/letr     : step (letr C1 C2) (C2 (fun ([y] letr C1 ([f] C1 f y)))).
step/zro?-zro : step (zro? zro) (val tru).
step/zro?-suc : step (zro? (suc _)) (val fls).
step/cond-tru : step (cond tru C1 _) C1.
step/cond-fls : step (cond fls _ C2) C2.
step/app      : step (app (fun E1) E2) (E1 E2).

%block var-effty : block {e : effty}.
%block var-instance : some {E : effty} block {i : instance}{_ : iof i E}.
%block vars = (var-effty | var-instance).
