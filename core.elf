%%%% The core language of Eff



%%% Expressions and computations

expr : type.
comp : type.
op-cases : type.
%name expr E.
%name comp C.
%abbrev val-case = expr -> comp.
%abbrev op-case = expr -> expr -> comp.

tru : expr.
fls : expr.
zro : expr.
suc : expr -> expr.
unt : expr.
fun : (expr -> comp) -> expr.
ins : instance Eff -> expr.
hnd : val-case -> op-cases -> expr.

cond : expr -> comp -> comp -> comp.
zro? : expr -> comp.
pred : expr -> comp.
absd : expr -> comp.
app  : expr -> expr -> comp.
val  : expr -> comp.
op   : expr -> operation Eff -> expr -> (expr -> comp) -> comp.
let  : comp -> (expr -> comp) -> comp.
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp.
with : expr -> comp -> comp.

op-cases/nil : op-cases.
op-cases/cons : expr -> operation Eff -> op-case -> op-cases -> op-cases.

%%% Small step operational semantics

if-then-op-case : decide -> op-case -> op-case -> op-case -> type.

if-then-op-case/yes : if-then-op-case yes HC _  HC.
if-then-op-case/no : if-then-op-case no  _  HC HC.

get-op-case : instance Eff -> operation Eff -> op-cases -> op-case -> type.

get-op-case/nil  : get-op-case I O op-cases/nil ([x] [k] op (ins I) O x ([y] app k y)).
get-op-case/cons : get-op-case I O (op-cases/cons (ins I') O' HC H) HC''
                   <- eq-inst-op I O I' O' D
                   <- get-op-case I' O' H HC'
                   <- if-then-op-case D HC HC' HC''.

step : comp -> comp -> type.

step/cond-tru  : step (cond tru C1 _) C1.
step/cond-fls  : step (cond fls _ C2) C2.
step/zro?-zro  : step (zro? zro) (val tru).
step/zro?-suc  : step (zro? (suc _)) (val fls).
step/pred-zro  : step (pred zro) (val zro).
step/pred-suc  : step (pred (suc E)) (val E).
step/app       : step (app (fun E1) E2) (E1 E2).
step/let-val   : step (let (val E) C2) (C2 E).
step/let-op    : step (let (op Ei O Ep K) C2) (op Ei O Ep ([x] let (K x) C2)).
step/let-step  : step (let C1 C2) (let C1' C2)
                  <- step C1 C1'.
step/letr      : step (letr C1 C2) (C2 (fun ([x] letr C1 ([f] C1 f x)))).
step/with-val  : step (with (hnd Cv _) (val E)) (Cv E).
step/with-op   : step (with (hnd Cv Cops) (op (ins I) O Ep K)) (Cop Ep (fun ([y] with (hnd Cv Cops) (K y))))
                  <- get-op-case I O Cops Cop.
step/with-step : step (with E C) (with E C')
                  <- step C C'.


final : comp -> dirt -> type.

final/val : final (val _) _.
final/op  : final (op (ins I) O _ _) D
             <- in-dirt-instance I O D.



%%% Types

ty : type.
dirty : type.
%name ty A.
%name dirty B.

bool  : ty.
nat   : ty.
unit  : ty.
empty : ty.
-->   : ty -> dirty -> ty.
inst  : region Eff -> ty.
==>   : dirty -> dirty -> ty.
!     : ty -> dirt -> dirty.
%infix right 50 -->.
%infix right 55 ==>.
%infix none 60 !.


sig : operation Eff -> ty -> ty -> type.

%block var-effect : block {eff : effect}.
%block var-instance : some {eff : effect} block {inst : instance eff}.
%block var-operation : some {eff : effect} {par : ty} {res : ty} block {op : operation eff}{_ : sig op par res}.
%block vars = (var-effect | var-instance | var-operation).


always-if-then-op : {D} {HC} {HC'} {HC''} if-then-op-case D HC HC' HC'' -> type.
%mode always-if-then-op +D +HC +HC' -HC'' -ITE.

- : always-if-then-op yes HC _ HC if-then-op-case/yes.
- : always-if-then-op no _ HC HC if-then-op-case/no.

%worlds (vars) (always-if-then-op _ _ _ _ _).
%total {} (always-if-then-op _ _ _ _ _).

always-eq-inst-op : {Eff} {Eff'} {I : instance Eff} {O} {I' : instance Eff'} {O'} {D} eq-inst-op I O I' O' D -> type.
%mode always-eq-inst-op +Eff +Eff' +I +O +I' +O' -D -Eq.

- : always-eq-inst-op _ _ I O I O yes eq-inst-op/yes.

%worlds (vars) (always-eq-inst-op _ _ _ _ _ _ _ _).
%trustme %total {} (always-eq-inst-op _ _ _ _ _ _ _ _).




%%% Subtyping judgements

<t : ty -> ty -> type. %infix none 30 <t.
<dt : dirty -> dirty -> type. %infix none 30 <dt.

<t/bool  : bool <t bool.
<t/nat   : nat <t nat.
<t/unit  : unit <t unit.
<t/empty : empty <t empty.
<t/-->   : A --> B <t A' --> B'
            <- B <dt B'
            <- A' <t A.
<t/inst  : inst R <t inst R'
            <- R <r R'.
<t/==>   : B1 ==> B2 <t B1' ==> B2'
            <- B2 <dt B2'
            <- B1' <dt B1.
<dt/!    : A ! D <dt A' ! D'
            <- D <d D'
            <- A <t A'.



%%% Typing judgements

eof : expr -> ty -> type.
cof : comp -> dirty -> type.
opcof : op-cases -> dirty -> dirt -> type.
covers : dirt -> dirt -> dirt -> type.


covers/empty      : covers dirt/empty _ _.
covers/cons-here  : covers (dirt/cons I O D) D1 D2
                     <- covers D D1 D2
                     <- in-dirt-instance I O D1.
covers/cons-there : covers (dirt/cons I O D) D1 D2
                     <- covers D D1 D2
                     <- in-dirt-instance I O D2.

add-if-singleton : dirt -> region Eff -> operation Eff -> dirt -> type.
add-if-singleton/zero : add-if-singleton D region/empty _ D.
add-if-singleton/one : add-if-singleton D (region/cons I region/empty) O (dirt/cons I O D).
add-if-singleton/more : add-if-singleton D (region/cons _ (region/cons _ _)) _ D.

eof/tru : eof tru bool.
eof/fls : eof fls bool.
eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
           <- eof E nat.
eof/unt : eof unt unit.
eof/fun : eof (fun E) (A --> B)
           <- ({x} eof x A -> cof (E x) B).
eof/ins : eof (ins I) (inst R)
           <- in-region I R.
eof/sub : eof E A'
           <- A <t A'
           <- eof E A.
eof/hnd : eof (hnd Cv Cops) (A ! D ==> A' ! D')
           <- covers D Dcov D'
           <- opcof Cops (A' ! D') Dcov
           <- ({x} eof x A -> cof (Cv x) (A' ! D')).

opcof/nil  : opcof op-cases/nil B dirt/empty.
opcof/cons : opcof (op-cases/cons E O Cop Cops) B D'
              <- add-if-singleton D R O D'
              <- opcof Cops B D
              <- ({x} eof x A1 -> {k} eof k (A2 --> B) -> cof (Cop x k) B)
              <- sig O A1 A2
              <- eof E (inst (R : region Eff)). 

cof/cond : cof (cond E C1 C2) B
            <- cof C2 B
            <- cof C1 B
            <- eof E bool.
cof/zro? : cof (zro? E) (bool ! D)
            <- eof E nat.
cof/pred : cof (pred E) (nat ! D)
            <- eof E nat.
cof/absd : cof (absd E) B
            <- eof E empty.
cof/app  : cof (app E1 E2) B
            <- eof E2 A
            <- eof E1 (A --> B).
cof/val  : cof (val E) (A ! D)
            <- eof E A.
cof/op   : cof (op Ei O Ep K) (B ! D)
            <- in-dirt R O D
            <- ({x} eof x A2 -> cof (K x) (B ! D))
            <- eof Ep A1
            <- sig O A1 A2
            <- eof Ei (inst (R : region Eff)).
cof/let  : cof (let C1 C2) (A' ! D)
            <- ({x} eof x A -> cof (C2 x) (A' ! D))
            <- cof C1 (A ! D).
cof/letr : cof (letr C1 C2) B'
            <- ({f} eof f (A --> B) -> cof (C2 f) B')
            <- ({f} {x} eof f (A --> B) -> eof x A -> cof (C1 f x) B).
cof/with : cof (with E C) B'
            <- cof C B
            <- eof E (B ==> B').
cof/sub  : cof C B'
            <- B <dt B'
            <- cof C B.
