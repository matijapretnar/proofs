% The core language of Eff



%%%%{ Types }%%%%%

ty : type.

nat   : ty.
arrow : ty -> ty -> ty.


%%%%{ Expressions and computations }%%%%%

expr : type.
comp : type.

zro : expr.
suc : expr -> expr.
fun : (expr -> comp) -> expr.

val : expr -> comp.
app : expr -> expr -> comp.
let : comp -> (expr -> comp) -> comp.



%%%%{ Typing judgements }%%%%%

eof : expr -> ty -> type.
cof : comp -> ty -> type.

eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
	   <- eof E nat.
eof/fun : eof (fun E) (arrow A B)
	   <- ({x} eof x A -> cof (E x) B).

cof/val : cof (val E) A
	   <- eof E A.
cof/app : cof (app E1 E2) B
	   <- eof E2 A
	   <- eof E1 (arrow A B).
cof/let : cof (let C1 C2) B
	   <- ({x} eof x A -> cof (C2 x) B)
	   <- cof C1 A.



%%%%{ Operational semantics }%%%%%

step : comp -> comp -> type.

step/app      : step (app (fun E1) E2) (E1 E2).
step/let-val  : step (let (val E) C2) (C2 E).
step/let-step : step (let C1 C2) (let C1' C2)
		 <- step C1 C1'.


non-stuck : comp -> type.

non-stuck/val  : non-stuck (val E).
non-stuck/step : non-stuck C
		  <- step C C'.
