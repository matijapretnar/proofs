%%% Core Elf: abstract syntax, typing and operational semantics

% An Eff term is either an expression (inert, free from effects) or a
% computation (can be evaluated, may cause effects).

expr : type.
%name expr E.

comp : type.
%name comp C.

% Auxiliary types for constructing handlers

op-cases : type. % A list of operation handler cases, see below
%name op-cases OCs.

%abbrev val-case = expr -> comp.
%abbrev op-case = expr -> expr -> comp.
%name op-case OC.

% Expressions

tru : expr.                            % true
fls : expr.                            % false
zro : expr.                            % zero
suc : expr -> expr.                    % successor
unt : expr.                            % unit
fun : (expr -> comp) -> expr.          % function
ins : instance Eff -> expr.            % instance
hnd : val-case -> op-cases -> expr.    % handler

% Computations

cond : expr -> comp -> comp -> comp.   % conditional statement
zro? : expr -> comp.                   % zero test
pred : expr -> comp.                   % predecessor
absd : expr -> comp.                   % eliminator for empty type
app  : expr -> expr -> comp.           % application
val  : expr -> comp.                   % injection of values into computations
op   : expr -> operation Eff -> expr -> (expr -> comp) -> comp. % operation
let  : comp -> (expr -> comp) -> comp. % let-binding
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp. % recursive function
with : expr -> comp -> comp.           % handling construct

% A handler has a "val-case" and a list of cases for handling operations, these
% are encoded with "op-cases":

op-cases/nil  : op-cases.
op-cases/cons : expr -> operation Eff -> op-case -> op-cases -> op-cases.

%%% Small step operational semantics

% The handling construct must decide how to handle an operation.
% For this purpose we define "if-then-op-case".

if-then-op-case : decide -> op-case -> op-case -> op-case -> type.

if-then-op-case/yes : if-then-op-case yes OC _  OC.
if-then-op-case/no  : if-then-op-case no  _  OC OC.

% "get-op-case" finds the handler case which applies to a given operation,
% or gives the default handler if none applies.

get-op-case : instance Eff -> operation Eff -> op-cases -> op-case -> type.

get-op-case/nil  : get-op-case I O op-cases/nil ([x] [k] op (ins I) O x ([y] app k y)).
get-op-case/cons : get-op-case I O (op-cases/cons (ins I') O' OC OCs) OC''
                    <- if-then-op-case D OC OC' OC''
                    <- get-op-case I O OCs OC'
                    <- eq-inst-op I O I' O' D.

% The small step semantics relation.

~> : comp -> comp -> type.
%infix none 40 ~>.

~>/cond-tru  : cond tru C1 _ ~> C1.
~>/cond-fls  : cond fls _ C2 ~> C2.
~>/zro?-zro  : zro? zro ~> val tru.
~>/zro?-suc  : zro? (suc _) ~> val fls.
~>/pred-zro  : pred zro ~> val zro.
~>/pred-suc  : pred (suc E) ~> val E.
~>/app       : app (fun E1) E2 ~> E1 E2.
~>/let-val   : let (val E) C2 ~> C2 E.
~>/let-op    : let (op Ei O Ep K) C2 ~> op Ei O Ep ([x] let (K x) C2).
~>/let-step  : let C1 C2 ~> let C1' C2
                <- C1 ~> C1'.
~>/letr      : letr C1 C2 ~> C2 (fun ([x] letr C1 ([f] C1 f x))).
~>/with-val  : with (hnd Cv _) (val E) ~> Cv E.
~>/with-op   : with (hnd Cv OCs) (op (ins I) O Ep K) ~> OC Ep (fun ([y] with (hnd Cv OCs) (K y)))
                <- get-op-case I O OCs OC.
~>/with-step : with E C ~> with E C'
                <- C ~> C'.

% A computation is considered "final" if it is a value or an operation.

final : comp -> dirt -> type.

final/val : final (val _) _.
final/op  : final (op (ins I) O _ _) D
             <- in-dirt-instance I O D.

% The big step semantics relation.

result : type.

result/val : expr -> result.
result/op  : instance Eff -> operation Eff -> expr -> (expr -> comp) -> result.

~>* : comp -> result -> type.
%infix none 40 ~>*.

~>*/val  : val E ~>* result/val E.
~>*/op   : op (ins I) O E K ~>* result/op I O E K.
~>*/step : C ~>* R
            <- C' ~>* R
            <- C ~> C'.

=> : comp -> result -> type.
%infix none 40 =>.

=>/cond-tru : cond tru C1 _ => R
               <- C1 => R.
=>/cond-fls : cond fls _ C2 => R
               <- C2 => R.
=>/zro?-zro : zro? zro => result/val tru.
=>/zro?-suc : zro? (suc _) => result/val fls.
=>/pred-zro : pred zro => result/val zro.
=>/pred-suc : pred (suc E) => result/val E.
=>/app      : app (fun E1) E2 => R
               <- E1 E2 => R.
=>/val      : val E => result/val E.
=>/op       : op (ins I) O E K => result/op I O E K.
=>/let-val  : let C1 C2 => R
               <- C2 E => R
               <- C1 => result/val E.
=>/let-op   : let C1 C2 => result/op I O E ([x] let (K x) C2)
               <- C1 => result/op I O E K.
=>/letr     : letr C1 C2 => R
               <- C2 (fun ([x] letr C1 ([f] C1 f x))) => R.
=>/with-val : with (hnd Cv _) C => R
               <- Cv E => R
               <- C => result/val E.
=>/with-op  : with (hnd Cv OCs) C => R
               <- OC E (fun ([y] with (hnd Cv OCs) (K y))) => R
               <- get-op-case I O OCs OC
               <- C => result/op I O E K.



%%% Types

% Expression types "ty" and computation types "dirty":

ty : type.
%name ty A.

dirty : type.
%name dirty B.

% A dirty type is a pair "A ! D" where "A" is an expression type and
% "D" is dirt (see "sig.elf").

! : ty -> dirt -> dirty.
%infix none 60 !.

% Expression type constructors:

bool  : ty.                   % the type of booleans
nat   : ty.                   % the type of natural numbers
unit  : ty.                   % the unit type
empty : ty.                   % the empty type
-->   : ty -> dirty -> ty.    % functions
inst  : region Eff -> ty.     % the type of instances of a given effect
==>   : dirty -> dirty -> ty. % the type of handlers
%infix right 50 -->.
%infix right 55 ==>.

% Each operation "O : operation E" has an associated signature, namely the
% type "A1" of its parameter and its return type "A2". The mapping from operations
% to their signature is encoded by "sig".


effsignature : type.

effsignature/empty : effsignature.
effsignature/cons : ty -> ty -> effsignature -> effsignature.

signature : type.

signature/empty : signature.
signature/cons : effsignature -> signature -> signature.

sig : signature -> operation Eff -> ty -> ty -> type.

sig/here-here   : sig (signature/cons (effsignature/cons A1 A2 _) _) (operation/z effect/z) A1 A2.
sig/here-there  : sig (signature/cons (effsignature/cons _ _ ESig) Sig) (operation/s O) A1 A2
                   <- sig (signature/cons ESig Sig) O A1 A2.
sig/there-here  : sig (signature/cons _ Sig) (operation/z (effect/s E)) A1 A2
                   <- sig Sig (operation/z E) A1 A2.
sig/there-there : sig (signature/cons _ Sig) (operation/s O) A1 A2
                  <- sig Sig O A1 A2.

% Block declarations to be used in theorems.

%block vars = ().

% We assume here that equality on instances and operations is decidable
% by using a "%trustme" directive.

eq-inst-op-total : {I : instance Eff} {O} {I' : instance Eff'} {O'} eq-inst-op I O I' O' D -> type.
%mode eq-inst-op-total +I +O +I' +O' -Eq.

%worlds (vars) (eq-inst-op-total _ _ _ _ _).
%trustme %total {} (eq-inst-op-total _ _ _ _ _).



%%% Subtyping judgments

% "A <t A'" means that expression type "A" is a subtype of "A'".
% "B <dt B'" means that computation type "B" is a subtype of "B'".

<t : ty -> ty -> type.
<dt : dirty -> dirty -> type.
%infix none 30 <t.
%infix none 30 <dt.

<t/bool  : bool <t bool.
<t/nat   : nat <t nat.
<t/unit  : unit <t unit.
<t/empty : empty <t empty.
<t/-->   : A --> B <t A' --> B'
            <- B <dt B'
            <- A' <t A.
<t/inst  : inst R <t inst R'
            <- R <r R'.
<t/==>   : B1 ==> B2 <t B1' ==> B2'
            <- B2 <dt B2'
            <- B1' <dt B1.
<dt/!    : A ! D <dt A' ! D'
            <- D <d D'
            <- A <t A'.

%%% Typing judgements

% "eof E A" means that expression "E" has expression type "A".
% "cof C B" means that computation "C" has computation type "B".

eof : signature -> expr -> ty -> type.
cof : signature -> comp -> dirty -> type.

% "opcof Cases B D" does the hard part of checking that
% a handler is well-typed, see definition below.

opcof : signature -> op-cases -> dirty -> dirt -> type.

% "covers D D1 D2" checks that "D" is contained in the union of "D1"
% and "D2".

covers : dirt -> dirt -> dirt -> type.

covers/empty      : covers dirt/empty _ _.
covers/cons-here  : covers (dirt/cons I O D) D1 D2
                     <- covers D D1 D2
                     <- in-dirt-instance I O D1.
covers/cons-there : covers (dirt/cons I O D) D1 D2
                     <- covers D D1 D2
                     <- in-dirt-instance I O D2.

% "add-if-singleton D R O D'" adds "I#O" to dirt "D" to obtain dirt "D'",
% provided "R" is the singleton list containing just "I". This is used for
% type checking of handlers below.

add-if-singleton : dirt -> region Eff -> operation Eff -> dirt -> type.
add-if-singleton/zero : add-if-singleton D region/empty _ D.
add-if-singleton/one  : add-if-singleton D (region/cons I region/empty) O (dirt/cons I O D).
add-if-singleton/more : add-if-singleton D (region/cons _ (region/cons _ _)) _ D.

%%% Typing rules for expressions

eof/tru : eof _ tru bool.
eof/fls : eof _ fls bool.
eof/zro : eof _ zro nat.
eof/suc : eof Sig (suc E) nat
           <- eof Sig E nat.
eof/unt : eof _ unt unit.
eof/fun : eof Sig (fun E) (A --> B)
           <- ({x} eof Sig x A -> cof Sig (E x) B).
eof/ins : eof _ (ins I) (inst R)
           <- in-region I R.
eof/sub : eof Sig E A'
           <- A <t A'
           <- eof Sig E A.
eof/hnd : eof Sig (hnd Cv OCs) (A ! D ==> A' ! D')
           <- covers D Dcov D'
           <- opcof Sig OCs (A' ! D') Dcov
           <- ({x} eof Sig x A -> cof Sig (Cv x) (A' ! D')).

% "opcof OCs B D" checks the following things (where "OCs" is a
% list of handler cases of the form "E # O OC", where "E" is an
% expression, "O" is an operation, and "OC" is the body of the case):
% 
% 1. every "E" has an instance type
% 2. every "OC" has return type "B"
% 3. the dirt "D" is covered by those cases whose associated region is a singleton.

opcof/nil  : opcof Sig op-cases/nil B dirt/empty.
opcof/cons : opcof Sig (op-cases/cons E O OC OCs) B D'
              <- add-if-singleton D R O D'
              <- opcof Sig OCs B D
              <- ({x} eof Sig x A1 -> {k} eof Sig k (A2 --> B) -> cof Sig (OC x k) B)
              <- sig Sig O A1 A2
              <- eof Sig E (inst R). 

%%% Typing rules for computations

cof/cond : cof Sig (cond E C1 C2) B
            <- cof Sig C2 B
            <- cof Sig C1 B
            <- eof Sig E bool.
cof/zro? : cof Sig (zro? E) (bool ! D)
            <- eof Sig E nat.
cof/pred : cof Sig (pred E) (nat ! D)
            <- eof Sig E nat.
cof/absd : cof Sig (absd E) B
            <- eof Sig E empty.
cof/app  : cof Sig (app E1 E2) B
            <- eof Sig E2 A
            <- eof Sig E1 (A --> B).
cof/val  : cof Sig (val E) (A ! D)
            <- eof Sig E A.
cof/op   : cof Sig (op Ei O Ep K) (B ! D)
            <- in-dirt R O D
            <- ({x} eof Sig x A2 -> cof Sig (K x) (B ! D))
            <- eof Sig Ep A1
            <- sig Sig O A1 A2
            <- eof Sig Ei (inst R).
cof/let  : cof Sig (let C1 C2) (A' ! D)
            <- ({x} eof Sig x A -> cof Sig (C2 x) (A' ! D))
            <- cof Sig C1 (A ! D).
cof/letr : cof Sig (letr C1 C2) B'
            <- ({f} eof Sig f (A --> B) -> cof Sig (C2 f) B')
            <- ({f} {x} eof Sig f (A --> B) -> eof Sig x A -> cof Sig (C1 f x) B).
cof/with : cof Sig (with E C) B'
            <- cof Sig C B
            <- eof Sig E (B ==> B').
cof/sub  : cof Sig C B'
            <- B <dt B'
            <- cof Sig C B.


~>/=> : C ~> C' -> C' => R -> C => R -> type.
~>/=>-let : C1 ~> C1' -> let C1' C2 => R -> let C1 C2 => R -> type.
~>/=>-with : C2 ~> C2' -> with E C2' => R -> with E C2 => R -> type.
%mode ~>/=> +C~>C' +C'=>R -C=>R.
%mode ~>/=>-let +C1~C1' +C=>R -C'=>R.
%mode ~>/=>-with +C2~C2' +C=>R -C'=>R.

- : ~>/=> ~>/cond-tru C'=>R (=>/cond-tru C'=>R).
- : ~>/=> ~>/cond-fls C'=>R (=>/cond-fls C'=>R).
- : ~>/=> ~>/zro?-zro _ =>/zro?-zro.
- : ~>/=> ~>/zro?-suc _ =>/zro?-suc.
- : ~>/=> ~>/pred-zro _ =>/pred-zro.
- : ~>/=> ~>/pred-suc _ =>/pred-suc.
- : ~>/=> ~>/app C'=>R (=>/app C'=>R).
- : ~>/=> ~>/let-val C'=>R (=>/let-val =>/val C'=>R).
- : ~>/=> ~>/let-op _ (=>/let-op =>/op).
- : ~>/=> (~>/let-step C1~>C1') C'=>R C=>R
     <- ~>/=>-let C1~>C1' C'=>R C=>R.
- : ~>/=> ~>/letr C'=>R (=>/letr C'=>R).
- : ~>/=> ~>/with-val C'=>R (=>/with-val =>/val C'=>R).
- : ~>/=> (~>/with-op CO) C'=>R (=>/with-op =>/op CO C'=>R).
- : ~>/=> (~>/with-step C1~>C1') C'=>R C=>R
     <- ~>/=>-with C1~>C1' C'=>R C=>R.

- : ~>/=>-let C1~>C1' (=>/let-val C1'=>E C2E=>R) (=>/let-val C1=>E C2E=>R)
     <- ~>/=> C1~>C1' C1'=>E C1=>E.
- : ~>/=>-let C1~>C1' (=>/let-op C1'=>Op) (=>/let-op C1=>Op)
     <- ~>/=> C1~>C1' C1'=>Op C1=>Op.

- : ~>/=>-with C1~>C1' (=>/with-val C1'=>E C2E=>R) (=>/with-val C1=>E C2E=>R)
     <- ~>/=> C1~>C1' C1'=>E C1=>E.
- : ~>/=>-with C1~>C1' (=>/with-op C1'=>Op OC OC=>R) (=>/with-op C1=>Op OC OC=>R)
     <- ~>/=> C1~>C1' C1'=>Op C1=>Op.

%worlds (vars) (~>/=> _ _ _) (~>/=>-let _ _ _) (~>/=>-with _ _ _).
%total {(C~>C' C1~>C1' C2~>C2') (C'=>R C1C2~>R EC~>R)} (~>/=> C~>C' C'=>R _) (~>/=>-let C1~>C1' C1C2~>R _) (~>/=>-with C2~>C2' EC~>R _).

~>*/=> : C ~>* R -> C => R -> type.
%mode ~>*/=> +C~>*R -C=>R.

- : ~>*/=> ~>*/val =>/val.
- : ~>*/=> ~>*/op =>/op.
- : ~>*/=> (~>*/step C~>C' C'~>*R) C=>R
     <- ~>*/=> C'~>*R C'=>R
     <- ~>/=> C~>C' C'=>R C=>R.

%worlds (vars) (~>*/=> _ _).
%total {C~>*R} (~>*/=> C~>*R _).

~>*-let-val : C1 ~>* result/val E -> C2 E ~>* R -> let C1 C2 ~>* R -> type.
%mode ~>*-let-val +C1~>*E +C2E~>*R -C1C2~>*R.

- : ~>*-let-val ~>*/val C2E~>*R (~>*/step ~>/let-val C2E~>*R).
- : ~>*-let-val (~>*/step C1~>C1' C1'~*>E) C2E~>*R (~>*/step (~>/let-step C1~>C1') C1'C2~>*R)
     <- ~>*-let-val C1'~*>E C2E~>*R C1'C2~>*R.

%worlds (vars) (~>*-let-val _ _ _).
%total {C1~>*E} (~>*-let-val C1~>*E _ _).

~>*-let-op : C1 ~>* result/op I O E K -> {C2} let C1 C2 ~>* result/op I O E ([x] let (K x) C2) -> type.
%mode ~>*-let-op +C1~>*Op +C2 -C1C2~>*Op.

- : ~>*-let-op ~>*/op _ (~>*/step ~>/let-op ~>*/op).
- : ~>*-let-op (~>*/step C1~>C1' C1'~*>Op) C2 (~>*/step (~>/let-step C1~>C1') C1'C2~>*Op)
     <- ~>*-let-op C1'~*>Op C2 C1'C2~>*Op.

%worlds (vars) (~>*-let-op _ _ _).
%total {C1~>*Op} (~>*-let-op C1~>*Op _ _).

~>*-with-val : C ~>* result/val E -> Cv E ~>* R -> {OCs} with (hnd Cv OCs) C ~>* R -> type.
%mode ~>*-with-val +C~>*E +CvE~>*R +OCs -HC~>*R.

- : ~>*-with-val ~>*/val CvE~>*R _ (~>*/step ~>/with-val CvE~>*R).
- : ~>*-with-val (~>*/step C~>C' C'~*>E) CvE~>*R OCs (~>*/step (~>/with-step C~>C') HC~>*R)
     <- ~>*-with-val C'~*>E CvE~>*R OCs HC~>*R.

%worlds (vars) (~>*-with-val _ _ _ _).
%total {C~>*E} (~>*-with-val C~>*E _ _ _).

~>*-with-op :
  C ~>* result/op I O E K
  -> get-op-case I O OCs OC
  -> OC E (fun ([y] with (hnd Cv OCs) (K y))) ~>* R
  -> with (hnd Cv OCs) C ~>* R -> type.
%mode ~>*-with-op +C~>*Op +OC +OC~>*R -HC~>*R.

- : ~>*-with-op ~>*/op OC OC~>*R (~>*/step (~>/with-op OC) OC~>*R).
- : ~>*-with-op (~>*/step C~>C' C'~>*Op) OC OC~>*R (~>*/step (~>/with-step C~>C') HC~>*R)
     <- ~>*-with-op C'~>*Op OC OC~>*R HC~>*R.

%worlds (vars) (~>*-with-op _ _ _ _).
%total {C~>*Op} (~>*-with-op C~>*Op _ _ _).

=>/~>* : C => R -> C ~>* R -> type.
%mode =>/~>* +C=>R -C~>*R.

- : =>/~>* (=>/cond-tru C=>R) (~>*/step ~>/cond-tru C~>*R)
     <- =>/~>* C=>R C~>*R.
- : =>/~>* (=>/cond-fls C=>R) (~>*/step ~>/cond-fls C~>*R)
     <- =>/~>* C=>R C~>*R.
- : =>/~>* =>/zro?-zro (~>*/step ~>/zro?-zro ~>*/val).
- : =>/~>* =>/zro?-suc (~>*/step ~>/zro?-suc ~>*/val).
- : =>/~>* =>/pred-zro (~>*/step ~>/pred-zro ~>*/val).
- : =>/~>* =>/pred-suc (~>*/step ~>/pred-suc ~>*/val).
- : =>/~>* (=>/app C=>R) (~>*/step ~>/app C~>*R)
     <- =>/~>* C=>R C~>*R.
- : =>/~>* =>/val ~>*/val.
- : =>/~>* =>/op ~>*/op.
- : =>/~>* (=>/let-val C1=>E C2E=>R) C1C2~>*R
     <- =>/~>* C1=>E C1~>*E
     <- =>/~>* C2E=>R C2E~>*R
     <- ~>*-let-val C1~>*E C2E~>*R C1C2~>*R.
- : =>/~>* (=>/let-op C1=>Op) C1C2~>*Op
     <- =>/~>* C1=>Op C1~>*Op
     <- ~>*-let-op C1~>*Op _ C1C2~>*Op.
- : =>/~>* (=>/letr C=>R) (~>*/step ~>/letr C~>*R)
     <- =>/~>* C=>R C~>*R.
- : =>/~>* (=>/with-val C=>E CvE=>R) HC~>*R
     <- =>/~>* C=>E C~>*E
     <- =>/~>* CvE=>R CvE~>*R
     <- ~>*-with-val C~>*E CvE~>*R _ HC~>*R.
- : =>/~>* (=>/with-op C=>Op OC OC=>R) HC~>*R
     <- =>/~>* C=>Op C~>*Op
     <- =>/~>* OC=>R OC~>*R
     <- ~>*-with-op C~>*Op OC OC~>*R HC~>*R.

%worlds (vars) (=>/~>* _ _).
%total {C=>R} (=>/~>* C=>R _).
