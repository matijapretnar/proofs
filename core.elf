%%% Core Elf: abstract syntax, typing and operational semantics

% An Eff term is either an expression (inert, free from effects) or a
% computation (can be evaluated, may cause effects).

expr : type.
%name expr E.

comp : type.
%name comp C.

% Auxiliary types for constructing handlers

op-cases : type. % A list of operation handler cases, see below
%name op-cases OCs.

%abbrev val-case = expr -> comp.
%abbrev op-case = expr -> expr -> comp.
%name op-case OC.

% Expressions

tru : expr.                            % true
fls : expr.                            % false
zro : expr.                            % zero
suc : expr -> expr.                    % successor
unt : expr.                            % unit
fun : (expr -> comp) -> expr.          % function
ins : instance Eff -> expr.            % instance
hnd : val-case -> op-cases -> expr.    % handler

% Computations

cond : expr -> comp -> comp -> comp.   % conditional statement
zro? : expr -> comp.                   % zero test
pred : expr -> comp.                   % predecessor
absd : expr -> comp.                   % eliminator for empty type
app  : expr -> expr -> comp.           % application
val  : expr -> comp.                   % injection of values into computations
op   : expr -> operation Eff -> expr -> (expr -> comp) -> comp. % operation
let  : comp -> (expr -> comp) -> comp. % let-binding
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp. % recursive function
with : expr -> comp -> comp.           % handling construct

% A handler has a "val-case" and a list of cases for handling operations, these
% are encoded with "op-cases":

op-cases/nil  : op-cases.
op-cases/cons : expr -> operation Eff -> op-case -> op-cases -> op-cases.

%%% Small step operational semantics

% The handling construct must decide how to handle an operation.
% For this purpose we define "if-then-op-case".

if-then-op-case : {I : instance Eff} {O : operation Eff} {I' : instance Eff'} {O' : operation Eff'} op-case -> op-case -> op-case -> type.
%mode if-then-op-case +I +O +I' +O' +OC1 +OC2 -OC.

if-then-op-case/yes : if-then-op-case I O I' O' OC _ OC
                       <- equal I O I' O'.
if-then-op-case/no  : if-then-op-case I O I' O' _ OC OC
                       <- apart I O I' O'.

% "get-op-case" finds the handler case which applies to a given operation,
% or gives the default handler if none applies.

get-op-case : instance Eff -> operation Eff -> op-cases -> op-case -> type.
%mode get-op-case +I +O +OCs -OC.

get-op-case/nil  : get-op-case I O op-cases/nil ([x] [k] op (ins I) O x ([y] app k y)).
get-op-case/cons : get-op-case I O (op-cases/cons (ins I') O' OC OCs) OC''
                    <- get-op-case I O OCs OC'
                    <- if-then-op-case I O I' O' OC OC' OC''.

% The big step semantics relation.

result : type.

result/val : expr -> result.
result/op  : instance Eff -> operation Eff -> expr -> (expr -> comp) -> result.




%%% Types

% Expression types "ty" and computation types "dirty":

ty : type.
%name ty A.

dirty : type.
%name dirty B.

% A dirty type is a pair "A ! D" where "A" is an expression type and
% "D" is dirt (see "sig.elf").

! : ty -> dirt -> dirty.
%infix none 60 !.

% Expression type constructors:

bool  : ty.                   % the type of booleans
nat   : ty.                   % the type of natural numbers
unit  : ty.                   % the unit type
empty : ty.                   % the empty type
-->   : ty -> dirty -> ty.    % functions
inst  : region Eff -> ty.     % the type of instances of a given effect
==>   : dirty -> dirty -> ty. % the type of handlers
%infix right 50 -->.
%infix right 55 ==>.

% Each operation "O : operation E" has an associated signature, namely the
% type "A1" of its parameter and its return type "A2". The mapping from operations
% to their signature is encoded by "sig".


effsignature : type.

effsignature/empty : effsignature.
effsignature/cons : ty -> ty -> effsignature -> effsignature.

signature : type.

signature/empty : signature.
signature/cons : effsignature -> signature -> signature.

effsig : effsignature -> name -> ty -> ty -> type.

effsig/here : effsig (effsignature/cons A1 A2 _) name/z A1 A2.
effsig/there : effsig (effsignature/cons _ _ ESig) (name/s O) A1 A2
                <- effsig ESig O A1 A2.

%worlds () (effsig _ _ _ _).
%unique effsig +Sig +X -1A1 -1A2.

sig : signature -> operation Eff -> ty -> ty -> type.

sig/here : sig (signature/cons ESig _) (operation/ (effect/ name/z) O) A1 A2
            <- effsig ESig O A1 A2.
sig/there : sig (signature/cons _ Sig) (operation/ (effect/ (name/s Eff)) O) A1 A2
            <- sig Sig (operation/ (effect/ Eff) O) A1 A2.

%worlds () (sig _ _ _ _).
%unique sig +Sig +O -1A1 -1A2.

%%% Subtyping judgments

% "A <t A'" means that expression type "A" is a subtype of "A'".
% "B <dt B'" means that computation type "B" is a subtype of "B'".

<t : ty -> ty -> type.
<dt : dirty -> dirty -> type.
%infix none 30 <t.
%infix none 30 <dt.

<t/bool  : bool <t bool.
<t/nat   : nat <t nat.
<t/unit  : unit <t unit.
<t/empty : empty <t empty.
<t/-->   : A --> B <t A' --> B'
            <- B <dt B'
            <- A' <t A.
<t/inst  : inst R <t inst R'
            <- R <r R'.
<t/==>   : B1 ==> B2 <t B1' ==> B2'
            <- B2 <dt B2'
            <- B1' <dt B1.
<dt/!    : A ! D <dt A' ! D'
            <- D <d D'
            <- A <t A'.
