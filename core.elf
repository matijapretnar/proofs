% The core language of Eff



%%%%{ Types }%%%%%

ty : type.

nat   : ty.
bool  : ty.
unit  : ty.
empty : ty.
arrow : ty -> ty -> ty.


%%%%{ Expressions and computations }%%%%%

expr : type.
comp : type.

zro : expr.
suc : expr -> expr.
tru : expr.
fls : expr.
unt : expr.
fun : (expr -> comp) -> expr.

val  : expr -> comp.
let  : comp -> (expr -> comp) -> comp.
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp.
zro? : expr -> comp.
cond : expr -> comp -> comp -> comp.
absd : expr -> comp.
app  : expr -> expr -> comp.



%%%%{ Typing judgements }%%%%%

eof : expr -> ty -> type.
cof : comp -> ty -> type.

eof/zro : eof zro nat.
eof/suc : eof (suc E) nat
	   <- eof E nat.
eof/tru : eof tru bool.
eof/fls : eof fls bool.
eof/unt : eof unt unit.
eof/fun : eof (fun E) (arrow A B)
	   <- ({x} eof x A -> cof (E x) B).

cof/val  : cof (val E) A
	    <- eof E A.
cof/let  : cof (let C1 C2) B
	    <- ({x} eof x A -> cof (C2 x) B)
	    <- cof C1 A.
cof/letr : cof (letr C1 C2) B
	    <- ({f} eof f (arrow A A') -> cof (C2 f) B)
	    <- ({f} {x} eof f (arrow A A') -> eof x A -> cof (C1 f x) A').
cof/zro? : cof (zro? E) bool
	    <- eof E nat.
cof/cond : cof (cond E C1 C2) A
	    <- cof C2 A
	    <- cof C1 A
	    <- eof E bool.
cof/absd : cof (absd E) A
	    <- eof E empty.
cof/app  : cof (app E1 E2) B
	    <- eof E2 A
	    <- eof E1 (arrow A B).



%%%%{ Operational semantics }%%%%%

step : comp -> comp -> type.

step/let-val  : step (let (val E) C2) (C2 E).
step/let-step : step (let C1 C2) (let C1' C2)
		 <- step C1 C1'.
step/letr     : step (letr C1 C2) (C2 (fun ([y] letr C1 ([f] C1 f y)))).
step/zro?-zro : step (zro? zro) (val tru).
step/zro?-suc : step (zro? (suc _)) (val fls).
step/cond-tru : step (cond tru C1 _) C1.
step/cond-fls : step (cond fls _ C2) C2.
step/app      : step (app (fun E1) E2) (E1 E2).


non-stuck : comp -> type.

non-stuck/val  : non-stuck (val _).
non-stuck/step : non-stuck C
		  <- step C _.
