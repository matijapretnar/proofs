%%% Terms

% Terms are split into:
% - expressions "expr", which are inert and free from effects, and
% - computations "comp", which can be evaluated and may cause effects.
% In addition to these two, we include an auxiliary third type "op-cases"
% that represents a list of operation cases in handlers.

expr : type.
comp : type.
op-cases : type.
%name comp C.
%name expr E.
%name op-cases OCs.

% Abbreviations for handler cases
%abbrev val-case = expr -> comp.
%abbrev op-case = expr -> expr -> comp.
%name op-case OC.

tru : expr.                            % true
fls : expr.                            % false
zro : expr.                            % zero
suc : expr -> expr.                    % successor
unt : expr.                            % unit
fun : (expr -> comp) -> expr.          % function
ins : instance Eff -> expr.            % instance
hnd : val-case -> op-cases -> expr.    % handler

op-cases/nil  : op-cases.
op-cases/cons : expr -> opsym Eff -> op-case -> op-cases -> op-cases.

cond : expr -> comp -> comp -> comp.   % conditional statement
zro? : expr -> comp.                   % zero test
pred : expr -> comp.                   % predecessor
absd : expr -> comp.                   % eliminator for empty type
app  : expr -> expr -> comp.           % application
val  : expr -> comp.                   % injection of values into computations
op   : expr -> opsym Eff -> expr -> (expr -> comp) -> comp. % operation call
let  : comp -> (expr -> comp) -> comp. % let-binding
letv : expr -> (expr -> comp) -> comp. % polymorphic binding of values
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp. % recursive definition
with : expr -> comp -> comp.           % handling construct
