%%% Core Elf: abstract syntax, typing and operational semantics

% An Eff term is either an expression (inert, free from effects) or a
% computation (can be evaluated, may cause effects).

expr : type.
%name expr E.

comp : type.
%name comp C.

% Auxiliary types for constructing handlers

op-cases : type. % A list of operation handler cases, see below
%name op-cases OCs.

%abbrev val-case = expr -> comp.
%abbrev op-case = expr -> expr -> comp.
%name op-case OC.

% Expressions

tru : expr.                            % true
fls : expr.                            % false
zro : expr.                            % zero
suc : expr -> expr.                    % successor
unt : expr.                            % unit
fun : (expr -> comp) -> expr.          % function
ins : instance Eff -> expr.            % instance
hnd : val-case -> op-cases -> expr.    % handler

% Computations

cond : expr -> comp -> comp -> comp.   % conditional statement
zro? : expr -> comp.                   % zero test
pred : expr -> comp.                   % predecessor
absd : expr -> comp.                   % eliminator for empty type
app  : expr -> expr -> comp.           % application
val  : expr -> comp.                   % injection of values into computations
op   : expr -> operation Eff -> expr -> (expr -> comp) -> comp. % operation
let  : comp -> (expr -> comp) -> comp. % let-binding
letv : expr -> (expr -> comp) -> comp. % polymorphic binding of values
letr : (expr -> expr -> comp) -> (expr -> comp) -> comp. % recursive function
with : expr -> comp -> comp.           % handling construct

% A handler has a "val-case" and a list of cases for handling operations, these
% are encoded with "op-cases":

op-cases/nil  : op-cases.
op-cases/cons : expr -> operation Eff -> op-case -> op-cases -> op-cases.

%%% Small step operational semantics

% "get-op-case" finds the handler case which applies to a given operation,
% or gives the default handler if none applies.

get-op-case : instance Eff -> operation Eff -> op-cases -> op-case -> type.
%mode get-op-case +I +O +OCs -OC.

get-op-case/nil   : get-op-case I O op-cases/nil ([x] [k] op (ins I) O x ([y] app k y)).
get-op-case/here  : get-op-case I O (op-cases/cons (ins I) O OC _) OC.
get-op-case/there : get-op-case I O (op-cases/cons (ins I') O' _ OCs) OC
                     <- apart I O I' O'
                     <- get-op-case I O OCs OC.

% The big step semantics relation.

result : type.

result/val : expr -> result.
result/op  : instance Eff -> operation Eff -> expr -> (expr -> comp) -> result.
