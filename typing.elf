%%%%% Typing judgments %%%%%

% The three typing judgments that correspond to the three families of terms:
% - "eof Sig E A" means that expression "E" has type "A" under signature "Sig"
% - "cof Sig C B" states the same for computation "C" and ty type "B"
% - "opcof Sig OCs B D" states that operation cases "OCs" all have a return type "B"
%   and cover operations from dirt "D"

eof : signature -> expr -> ty -> type.
cof : signature -> comp -> ty -> type.
sof : signature -> comp -> sch -> type.
opcof : signature -> op-cases -> ty -> type.

% We have an additional judgment "var E A" to represent variables of type "A"
% in a context. We could use "eof" instead of "var" in hypothetical judgments,
% but the latter presentation of contexts is closer to the formalization
% in the paper, and also later allow us to relate variables between typing
% and type inference judgments.

var : expr -> ty -> type.
pvar : expr -> sch -> type.

% Block declaration to be used in theorems that hold for open typed terms.

%block mopen : some {A : ty} block {x : expr}{_ : var x A}.
%block popen : some {S : sch} block {x : expr}{_ : pvar x S}.
%block topen : block {t : ty}.
%block open = (mopen | popen | topen).


%%% Expressions %%%

eof/var : eof _ E A
           <- var E A.
eof/pvar : eof _ E A
           <- concrete S A
           <- pvar E S.
eof/tru : eof _ tru bool.
eof/fls : eof _ fls bool.
eof/zro : eof _ zro nat.
eof/suc : eof Sig (suc E) nat
           <- eof Sig E nat.
eof/unt : eof _ unt unit.
eof/fun : eof Sig (fun A E) (A --> B)
           <- ({x} var x A -> cof Sig (E x) B).
eof/ins : eof _ (ins (I : instance Eff)) (inst Eff).
eof/sub : eof Sig E A'
           <- A <t A'
           <- eof Sig E A.
eof/hnd : eof Sig (hnd A Cv OCs) (A ==> A')
           <- opcof Sig OCs A'
           <- ({x} var x A -> cof Sig (Cv x) A').


%%% Operation cases %%%

opcof/nil  : opcof Sig (op-cases/nil B) B.
opcof/cons : opcof Sig (op-cases/cons E O OC OCs) B
              <- opcof Sig OCs B
              <- ({x} var x A1 -> {k} var k (A2 --> B) -> cof Sig (OC x k) B)
              <- sig Sig (O : opsym Eff) A1 A2
              <- eof Sig E (inst Eff).


%%% Computations %%%

cof/cond : cof Sig (cond E C1 C2) B
            <- cof Sig C2 B
            <- cof Sig C1 B
            <- eof Sig E bool.
cof/mtch : cof Sig (mtch E C1 C2) B
            <- ({x} var x nat -> cof Sig (C2 x) B)
            <- cof Sig C1 B
            <- eof Sig E nat.
cof/absd : cof Sig (absd B E) B
            <- eof Sig E empty.
cof/app  : cof Sig (app E1 E2) B
            <- eof Sig E2 A
            <- eof Sig E1 (A --> B).
cof/val  : cof Sig (val E) A
            <- eof Sig E A.
cof/op   : cof Sig (op Ei O Ep K) B
            <- ({x} var x A2 -> cof Sig (K x) B)
            <- eof Sig Ep A1
            <- sig Sig (O : opsym Eff) A1 A2
            <- eof Sig Ei (inst Eff).
cof/let  : cof Sig (let C1 C2) A
            <- ({x} pvar x S -> cof Sig (C2 x) A)
            <- sof Sig C1 S.
cof/letr : cof Sig (letr A B C1 C2) B'
            <- ({f} var f (A --> B) -> cof Sig (C2 f) B')
            <- ({f} var f (A --> B) -> {x} var x A -> cof Sig (C1 f x) B).
cof/with : cof Sig (with E C) B'
            <- cof Sig C B
            <- eof Sig E (B ==> B').
cof/sub  : cof Sig C B'
            <- B <t B'
            <- cof Sig C B.

sof/plain : sof Sig C (plain A)
             <- cof Sig C A.

sof/forall: sof Sig C (forall A)
             <- {x} sof Sig C (A x).
