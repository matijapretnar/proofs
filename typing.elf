%%% Typing judgements

% Each operation "O : operation E" has an associated signature, namely the
% type "A1" of its parameter and its return type "A2". The mapping from operations
% to their signature is encoded by "sig".


effsignature : type.

effsignature/empty : effsignature.
effsignature/cons : ty -> ty -> effsignature -> effsignature.

signature : type.

signature/empty : signature.
signature/cons : effsignature -> signature -> signature.

effsig : effsignature -> name -> ty -> ty -> type.

effsig/here : effsig (effsignature/cons A1 A2 _) name/z A1 A2.
effsig/there : effsig (effsignature/cons _ _ ESig) (name/s O) A1 A2
                <- effsig ESig O A1 A2.

%worlds () (effsig _ _ _ _).
%unique effsig +Sig +X -1A1 -1A2.

sig : signature -> opsym Eff -> ty -> ty -> type.

sig/here : sig (signature/cons ESig _) (opsym/ (effect/ name/z) O) A1 A2
            <- effsig ESig O A1 A2.
sig/there : sig (signature/cons _ Sig) (opsym/ (effect/ (name/s Eff)) O) A1 A2
            <- sig Sig (opsym/ (effect/ Eff) O) A1 A2.

%worlds () (sig _ _ _ _).
%unique sig +Sig +O -1A1 -1A2.

var : expr -> ty -> type.

% "eof E A" means that expression "E" has expression type "A".
% "cof C B" means that computation "C" has computation type "B".
eof : signature -> expr -> ty -> type.
cof : signature -> comp -> dirty -> type.

% "opcof Cases B D" does the hard part of checking that
% a handler is well-typed, see definition below.

opcof : signature -> op-cases -> dirty -> dirt -> type.


%%% Typing rules for expressions

eof/var : eof _ E A
           <- var E A.
eof/tru : eof _ tru bool.
eof/fls : eof _ fls bool.
eof/zro : eof _ zro nat.
eof/suc : eof Sig (suc E) nat
           <- eof Sig E nat.
eof/unt : eof _ unt unit.
eof/fun : eof Sig (fun E) (A --> B)
           <- ({x} var x A -> cof Sig (E x) B).
eof/ins : eof _ (ins I) (inst R)
           <- in-region I R.
eof/sub : eof Sig E A'
           <- A <t A'
           <- eof Sig E A.
eof/hnd : eof Sig (hnd Cv OCs) (A ! D ==> A' ! D')
           <- covers D Dcov D'
           <- opcof Sig OCs (A' ! D') Dcov
           <- ({x} var x A -> cof Sig (Cv x) (A' ! D')).

% "opcof OCs B D" checks the following things (where "OCs" is a
% list of handler cases of the form "E # O OC", where "E" is an
% expression, "O" is an operation, and "OC" is the body of the case):
% 
% 1. every "E" has an instance type
% 2. every "OC" has return type "B"
% 3. the dirt "D" is covered by those cases whose associated region is a singleton.

opcof/nil  : opcof Sig op-cases/nil B dirt/empty.
opcof/cons : opcof Sig (op-cases/cons E O OC OCs) B D'
              <- add-if-singleton D R O D'
              <- opcof Sig OCs B D
              <- ({x} var x A1 -> {k} var k (A2 --> B) -> cof Sig (OC x k) B)
              <- sig Sig O A1 A2
              <- eof Sig E (inst R). 

%%% Typing rules for computations

cof/cond : cof Sig (cond E C1 C2) B
            <- cof Sig C2 B
            <- cof Sig C1 B
            <- eof Sig E bool.
cof/zro? : cof Sig (zro? E) (bool ! D)
            <- eof Sig E nat.
cof/pred : cof Sig (pred E) (nat ! D)
            <- eof Sig E nat.
cof/absd : cof Sig (absd E) B
            <- eof Sig E empty.
cof/app  : cof Sig (app E1 E2) B
            <- eof Sig E2 A
            <- eof Sig E1 (A --> B).
cof/val  : cof Sig (val E) (A ! D)
            <- eof Sig E A.
cof/op   : cof Sig (op Ei O Ep K) (B ! D)
            <- in-dirt R O D
            <- ({x} var x A2 -> cof Sig (K x) (B ! D))
            <- eof Sig Ep A1
            <- sig Sig O A1 A2
            <- eof Sig Ei (inst R).
cof/let  : cof Sig (let C1 C2) (A' ! D)
            <- ({x} var x A -> cof Sig (C2 x) (A' ! D))
            <- cof Sig C1 (A ! D).
cof/letr : cof Sig (letr C1 C2) B'
            <- ({f} var f (A --> B) -> cof Sig (C2 f) B')
            <- ({f} var f (A --> B) -> {x} var x A -> cof Sig (C1 f x) B).
cof/letv : cof Sig (letv E C) B
            <- cof Sig (C E) B
            <- eof Sig E _.
cof/with : cof Sig (with E C) B'
            <- cof Sig C B
            <- eof Sig E (B ==> B').
cof/sub  : cof Sig C B'
            <- B <dt B'
            <- cof Sig C B.

% Block declarations to be used in theorems.

%block open : some {A : ty} block {x : expr}{_ : var x A}.

