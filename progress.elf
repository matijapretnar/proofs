%%% Non-stuckness

non-stuck : comp -> dirt -> type.

non-stuck/final : non-stuck C D
                   <- final C D.
non-stuck/step  : non-stuck C _
                   <- C ~> _.


non-stuck/<d : non-stuck C D -> D <d D' -> non-stuck C D' -> type.
%mode non-stuck/<d +NS +D<D' -NS'.

- : non-stuck/<d (non-stuck/final final/val) _ (non-stuck/final final/val).

- : non-stuck/<d (non-stuck/final (final/op IOinD)) D<D' (non-stuck/final (final/op IOinD'))
     <- in-dirt-instance/<d IOinD D<D' IOinD'.

- : non-stuck/<d (non-stuck/step S) _ (non-stuck/step S).

%worlds (vars) (non-stuck/<d _ _ _).
%total {NS} (non-stuck/<d NS _ _).



%%% Effectiveness lemmas

% A so-called effectivness lemma for "if-then-op", which says that "if-then-op"
% always delivers an answer.

if-then-op-case-total : {D} {OC1} {OC2} if-then-op-case D OC1 OC2 OC -> type.
%mode if-then-op-case-total +D +OC1 +OC2 -OC.

- : if-then-op-case-total yes _ _ if-then-op-case/yes.
- : if-then-op-case-total no _ _ if-then-op-case/no.

%worlds (vars) (if-then-op-case-total _ _ _ _).
%total {} (if-then-op-case-total _ _ _ _).


% A so-called effectivness lemma for "get-op-case", which says that "get-op-case"
% always delivers an answer.

get-op-case-total : {I} {O} opcof OCs B D -> get-op-case I O OCs OC -> type.
get-op-case-total/cons : {I} {O} eof E (inst (R : region Eff'))
                          -> {O' : operation Eff'} {OC} get-op-case I O OCs OC'
                          -> get-op-case I O (op-cases/cons E O' OC OCs) OC'' -> type.
%mode get-op-case-total +I +O +OCs -OC.
%mode get-op-case-total/cons +I +O +E +O' +OC +OC' -OC''.

- : get-op-case-total _ _ opcof/nil get-op-case/nil.

- : get-op-case-total I O (opcof/cons E _ _ OCs _) OC''
     <- get-op-case-total I O OCs OC'
     <- get-op-case-total/cons I O E _ _ OC' OC''.


- : get-op-case-total/cons _ _ (eof/ins _) _ _ OC' (get-op-case/cons Eq OC' OC'')
     <- eq-inst-op-total _ _ _ _ Eq
     <- if-then-op-case-total _ _ _ OC''.

- : get-op-case-total/cons I O (eof/sub E _) _ _ OC' OC''
     <- get-op-case-total/cons I O E _ _ OC' OC''.

%worlds (vars) (get-op-case-total _ _ _ _) (get-op-case-total/cons _ _ _ _ _ _ _).
%total {(OCs E)} (get-op-case-total _ _ OCs _) (get-op-case-total/cons _ _ E _ _ _ _).



%%% Progress

progress-cond : {D} eof E bool -> {C1} {C2} non-stuck (cond E C1 C2) D -> type.
%mode progress-cond +D +E +C1 +C2 -NS.

- : progress-cond _ eof/tru _ _ (non-stuck/step ~>/cond-tru).

- : progress-cond _ eof/fls _ _ (non-stuck/step ~>/cond-fls).

- : progress-cond D (eof/sub E _) _ _ NS
     <- progress-cond D E _ _ NS.

%worlds (vars) (progress-cond _ _ _ _ _).
%total {E} (progress-cond _ E _ _ _).


progress-zro? : {D} eof E nat -> non-stuck (zro? E) D -> type.
%mode progress-zro? +D +E -NS.

- : progress-zro? D eof/zro (non-stuck/step ~>/zro?-zro).

- : progress-zro? D (eof/suc _) (non-stuck/step ~>/zro?-suc).

- : progress-zro? D (eof/sub E _) NS
     <- progress-zro? D E NS.

%worlds (vars) (progress-zro? _ _ _).
%total {E} (progress-zro? _ E _).


progress-pred : {D} eof E nat -> non-stuck (pred E) D -> type.
%mode progress-pred +D +E -NS.

- : progress-pred D eof/zro (non-stuck/step ~>/pred-zro).

- : progress-pred D (eof/suc _) (non-stuck/step ~>/pred-suc).

- : progress-pred D (eof/sub E _) NS
     <- progress-pred D E NS.

%worlds (vars) (progress-pred _ _ _).
%total {E} (progress-pred _ E _).


progress-absd : {D} eof E empty -> non-stuck (absd E) D -> type.
%mode progress-absd +D +E -NS.

- : progress-absd D (eof/sub E _) NS
     <- progress-absd D E NS.

%worlds (vars) (progress-absd _ _ _).
%total {E} (progress-absd _ E _).


progress-app : {D} eof E1 (A --> B) -> {E2} non-stuck (app E1 E2) D -> type.
%mode progress-app +D +E1 +E2 -NS.

- : progress-app _ (eof/fun _) _ (non-stuck/step ~>/app).

- : progress-app D (eof/sub E1 _) E2 NS
     <- progress-app D E1 E2 NS.

%worlds (vars) (progress-app _ _ _ _).
%total {E1} (progress-app _ E1 _ _).


progress-op : eof Ei (inst R) -> {Ep} {K} in-dirt R O D -> non-stuck (op Ei O Ep K) D -> type.
%mode progress-op +Ei +Ep +K +ROinD -NS.

- : progress-op (eof/ins IinR) _ _ ROinD (non-stuck/final (final/op IOinD))
     <- instance-in-region-in-dirt IinR ROinD IOinD.

- : progress-op (eof/sub Ei (<t/inst R<R')) Ep K R'OinD NS
     <- <r/in-dirt R<R' R'OinD ROinD
     <- progress-op Ei Ep K ROinD NS.

%worlds (vars) (progress-op _ _ _ _ _).
%total {Ei} (progress-op Ei _ _ _ _).


progress-let : non-stuck C1 D -> {C2} non-stuck (let C1 C2) D -> type.
%mode progress-let +NS1 +C2 -NS.

- : progress-let (non-stuck/final final/val) _ (non-stuck/step ~>/let-val).

- : progress-let (non-stuck/final (final/op _)) _ (non-stuck/step ~>/let-op).

- : progress-let (non-stuck/step S1) _ (non-stuck/step (~>/let-step S1)).

%worlds (vars) (progress-let _ _ _).
%total {NS1} (progress-let NS1 _ _).


progress-with : eof E (_ ! D1 ==> _ ! D2) -> non-stuck C D1 -> non-stuck (with E C) D2 -> type.
%mode progress-with +E +NS1 -NS2.

- : progress-with (eof/hnd _ _ _) (non-stuck/final final/val) (non-stuck/step ~>/with-val).

- : progress-with (eof/hnd _ OCs _) (non-stuck/final (final/op _)) (non-stuck/step (~>/with-op OC))
     <- get-op-case-total _ _ OCs OC.

- : progress-with (eof/hnd _ _ _) (non-stuck/step S) (non-stuck/step (~>/with-step S)).

- : progress-with (eof/sub E (<t/==> (<dt/! _ D1<D1') (<dt/! _ D2'<D2))) NS1 NS2
     <- non-stuck/<d NS1 D1<D1' NS1'
     <- progress-with E NS1' NS2'
     <- non-stuck/<d NS2' D2'<D2 NS2.

%worlds (vars) (progress-with _ _ _).
%total {E} (progress-with E _ _).


progress : cof C (_ ! D) -> non-stuck C D -> type.
%mode progress +C -NS.

- : progress (cof/cond E _ _) NS
     <- progress-cond _ E _ _ NS.

- : progress (cof/zro? E) NS
     <- progress-zro? _ E NS.

- : progress (cof/pred E) NS
     <- progress-pred _ E NS.

- : progress (cof/absd E) NS
     <- progress-absd _ E NS.

- : progress (cof/app E1 _) NS
     <- progress-app _ E1 _ NS.

- : progress (cof/val _) (non-stuck/final final/val).

- : progress (cof/op Ei _ _ _ ROinD) NS
     <- progress-op Ei _ _ ROinD NS.

- : progress (cof/let C1 _) NS
     <- progress C1 NS1
     <- progress-let NS1 _ NS.

- : progress (cof/letr _ _) (non-stuck/step ~>/letr).

- : progress (cof/with E C) NS'
     <- progress C NS
     <- progress-with E NS NS'.

- : progress (cof/sub C (<dt/! _ D<D')) NS'
     <- progress C NS
     <- non-stuck/<d NS D<D' NS'.

%worlds (vars) (progress _ _).
%total {C} (progress C _).
