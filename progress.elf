%%% Non-stuckness

non-stuck : comp -> dirt -> type.

non-stuck/final : non-stuck C D
                  <- final C D.
non-stuck/step  : non-stuck C _
                  <- step C _.

non-stuck/<d : non-stuck C D -> D <d D' -> non-stuck C D' -> type.
%mode non-stuck/<d +NS +D<D' -NS'.

- : non-stuck/<d (non-stuck/final final/val) _ (non-stuck/final final/val).

- : non-stuck/<d (non-stuck/final (final/op IOinDrt)) D<D' (non-stuck/final (final/op IOinDrt'))
     <- <d/in-dirt-instance IOinDrt D<D' IOinDrt'.

- : non-stuck/<d (non-stuck/step S) _ (non-stuck/step S).

%worlds (vars) (non-stuck/<d _ _ _).
%total {NS} (non-stuck/<d NS _ _).

% We assume here that equality on instances and operations is decidable
% by using a "%trustme" directive.

always-eq-inst-op : {I : instance Eff} {I' : instance Eff'} {O} {O'} eq-inst-op I O I' O' D -> type.
%mode always-eq-inst-op +I +O +I' +O' -Eq.

%worlds (vars) (always-eq-inst-op _ _ _ _ _).
%trustme %total {} (always-eq-inst-op _ _ _ _ _).

% A so-called effectivness lemma for "if-then-op", which says that "if-then-op"
% always delivers an answer.

always-if-then-op : {D} {HC} {HC'} if-then-op-case D HC HC' HC'' -> type.
%mode always-if-then-op +D +HC +HC' -ITE.

- : always-if-then-op yes HC _ if-then-op-case/yes.
- : always-if-then-op no _ HC if-then-op-case/no.

%worlds (vars) (always-if-then-op _ _ _ _).
%total {} (always-if-then-op _ _ _ _).

%%% Progress

progress-cond : {D} {C1} {C2} eof E bool -> non-stuck (cond E C1 C2) D -> type.
%mode progress-cond +D +C1 +C2 +E -NS.

- : progress-cond _ _ _ eof/tru (non-stuck/step step/cond-tru).

- : progress-cond _ _ _ eof/fls (non-stuck/step step/cond-fls).

- : progress-cond D _ _ (eof/sub E _) NS
     <- progress-cond D _ _ E NS.

%worlds (vars) (progress-cond _ _ _ _ _).
%total {E} (progress-cond _ _ _ E _).


progress-zro? : {D} eof E nat -> non-stuck (zro? E) D -> type.
%mode progress-zro? +D +E -NS.

- : progress-zro? D eof/zro (non-stuck/step step/zro?-zro).

- : progress-zro? D (eof/suc _) (non-stuck/step step/zro?-suc).

- : progress-zro? D (eof/sub E _) NS
     <- progress-zro? D E NS.

%worlds (vars) (progress-zro? _ _ _).
%total {E} (progress-zro? _ E _).


progress-pred : {D} eof E nat -> non-stuck (pred E) D -> type.
%mode progress-pred +D +E -NS.

- : progress-pred D eof/zro (non-stuck/step step/pred-zro).

- : progress-pred D (eof/suc _) (non-stuck/step step/pred-suc).

- : progress-pred D (eof/sub E _) NS
     <- progress-pred D E NS.

%worlds (vars) (progress-pred _ _ _).
%total {E} (progress-pred _ E _).


progress-absd : {D} eof E empty -> non-stuck (absd E) D -> type.
%mode progress-absd +D +E -NS.

- : progress-absd D (eof/sub E _) NS
     <- progress-absd D E NS.

%worlds (vars) (progress-absd _ _ _).
%total {E} (progress-absd _ E _).


progress-app : {D} eof E1 (A --> B) -> {E2} non-stuck (app E1 E2) D -> type.
%mode progress-app +D +E1 +E2 -NS.

- : progress-app _ (eof/fun _) _ (non-stuck/step step/app).

- : progress-app D (eof/sub E1 _) E2 NS
     <- progress-app D E1 E2 NS.

%worlds (vars) (progress-app _ _ _ _).
%total {E1} (progress-app _ E1 _ _).


progress-op : {D} {Ep} {K} eof Ei (inst R) -> in-dirt R O D -> non-stuck (op Ei O Ep K) D -> type.
%mode progress-op +D +Ep +K +Ei +ROinDrt -NS.

- : progress-op _ _ _ (eof/ins IinR) ROinDrt (non-stuck/final (final/op IOinDrt))
     <- instance-in-region-in-dirt IinR ROinDrt IOinDrt.

- : progress-op D Ep K (eof/sub E1 (<t/inst R<R')) R'OinDrt NS
     <- <r/in-dirt R<R' R'OinDrt ROinDrt
     <- progress-op D Ep K E1 ROinDrt NS.

%worlds (vars) (progress-op _ _ _ _ _ _).
%total {Ei} (progress-op _ _ _ Ei _ _).


progress-let : {C2} non-stuck C1 D -> non-stuck (let C1 C2) D -> type.
%mode progress-let +C2 +NS1 -NS.

- : progress-let _
     (non-stuck/final final/val)
     (non-stuck/step step/let-val).

- : progress-let _
     (non-stuck/final (final/op _))
     (non-stuck/step step/let-op).

- : progress-let _
     (non-stuck/step S1)
     (non-stuck/step (step/let-step S1)).

%worlds (vars) (progress-let _ _ _).
%total {NS1} (progress-let _ NS1 _).

% Totality of "get-op-case" (also known as an "effectiveness lemma"), i.e.,
% "get-op-case" always delivers a result.

always-get-cons-case : {I} {O} eof E (inst (R : region Eff')) -> sig (O' : operation Eff') A1 A2 -> ({x} eof x A1 -> {k} eof k (A2 --> B) -> cof (Cop x k) B) -> get-op-case I O Cops Cop' -> get-op-case I O (op-cases/cons E O' Cop Cops) Cop'' -> type.
%mode always-get-cons-case +I +O +E +S +Cop +Cop' -Cop''.

- : always-get-cons-case _ _ (eof/ins _) _ _ GetRest (get-op-case/cons ITE GetRest Eq)
     <- always-eq-inst-op _ _ _ _ Eq
     <- always-if-then-op _ _ _ ITE.

- : always-get-cons-case I O (eof/sub E _) S X GetRest Case
     <- always-get-cons-case I O E S X GetRest Case.

%worlds (vars) (always-get-cons-case _ _ _ _ _ _ _).
%total {E} (always-get-cons-case _ _ E _ _ _ _).

always-get-case : {I} {O} opcof Cops B D -> get-op-case I O Cops Cop -> type.
%mode always-get-case +I +O +Cops -Get.

- : always-get-case _ _ opcof/nil get-op-case/nil.

- : always-get-case I O (opcof/cons E S X Cops _) Case
     <- always-get-case I O Cops Case'
     <- always-get-cons-case I O E S X Case' Case.

%worlds (vars) (always-get-case _ _ _ _).
%total {Cops} (always-get-case _ _ Cops _).

progress-with : eof E (_ ! D1 ==> _ ! D2) -> non-stuck C D1 -> non-stuck (with E C) D2 -> type.
%mode progress-with +E +NS -NS'.

- : progress-with (eof/hnd _ _ _)
     (non-stuck/final final/val)
     (non-stuck/step step/with-val).

- : progress-with (eof/hnd _ Cops _)
     (non-stuck/final (final/op _))
     (non-stuck/step (step/with-op Get))
     <- always-get-case _ _ Cops Get.

- : progress-with (eof/hnd _ _ _)
     (non-stuck/step S)
     (non-stuck/step (step/with-step S)).

- : progress-with (eof/sub E (<t/==> (<dt/! _ D1D1') (<dt/! _ D2'D2))) NS1 NS2
     <- non-stuck/<d NS1 D1D1' NS1'
     <- progress-with E NS1' NS2'
     <- non-stuck/<d NS2' D2'D2 NS2.

%worlds (vars) (progress-with _ _ _).
%total {E} (progress-with E _ _).


progress : {D : dirt} cof C (A ! D) -> non-stuck C D -> type.
%mode progress +D +CO -NS.

- : progress _ (cof/cond E _ _) NS
     <- progress-cond _ _ _ E NS.

- : progress _ (cof/zro? E) NS
     <- progress-zro? _ E NS.

- : progress _ (cof/pred E) NS
     <- progress-pred _ E NS.

- : progress _ (cof/absd E) NS
     <- progress-absd _ E NS.

- : progress _ (cof/app E1 E2) NS
     <- progress-app _ E1 _ NS.

- : progress _ (cof/val _) (non-stuck/final final/val).

- : progress _ (cof/op Ei _ _ _ ROinDrt) NS
     <- progress-op _ _ _ Ei ROinDrt NS.

- : progress D (cof/let C1 _) NS
     <- progress D C1 NS1
     <- progress-let _ NS1 NS.

- : progress _ (cof/letr _ _) (non-stuck/step step/letr).

- : progress D' (cof/with E C) NS'
     <- progress D C NS
     <- progress-with E NS NS'.

- : progress D' (cof/sub C (<dt/! _ D<D')) NS'
     <- progress D C NS
     <- non-stuck/<d NS D<D' NS'.

%worlds (vars) (progress _ _ _).
%total {C} (progress _ C _).
