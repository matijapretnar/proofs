%%% Subcases of the preservation theorem %%%


%%% Preservation of handled operations %%%

% The most technical part of the proof lies here. We know an operation is
% handled by a handler either if one of the cases is guaranteed to match it,
% or if it appears in the outgoing dirt. We analyze both cases and show that
% types are preserved in both of them.

% Preservation in case an operation is covered by some operation case

% preservation-handled-op : in-dirt O Dcov -> sig Sig O A1 A2
%                            -> eof Sig E A1 -> eof Sig K (A2 --> B)
%                            -> get-op-case O OCs OC -> opcof Sig OCs B Dcov
%                            -> cof Sig (OC E K) B -> type.
% %mode preservation-handled-op +OinDcov +O +E +K +OC +OCs -C'.

% % When the first case matches.
% - : preservation-handled-op _ _ E K
%      get-op-case/here
%      (opcof/cons _ OC _)
%      OC'
%      <- subst2 OC E K OC'.

% % When the first case does not match, the covered dirt changes.
% % However, since the case did not match, the handled operation
% % must be in the remainder of the covered dirt, so we continue as before.
% - : preservation-handled-op OinDcov O E K
%      (get-op-case/there OC A)
%      (opcof/cons _ _ OCs)
%      C'
%      <- unequal-instance-in-rest OinDcov A OinDcov'
%      <- preservation-handled-op OinDcov' O E K OC OCs C'.

% %worlds (topen) (preservation-handled-op _ _ _ _ _ _ _).
% %total {OC} (preservation-handled-op _ _ _ _ OC _ _).


% % Preservation in case an operation appears in the outgoing dirt

% preservation-unhandled-op : in-dirt O D' -> sig Sig O A1 A2
%                              -> eof Sig E A1 -> eof Sig K (A2 --> A' ! D')
%                              -> get-op-case O OCs OC -> opcof Sig OCs (A' ! D') _
%                              -> cof Sig (OC E K) (A' ! D') -> type.
% %mode preservation-unhandled-op +OinD' +O +E +K +OC +OCs -C'.

% % When the first case matches.
% - : preservation-unhandled-op _ _ Ep K
%      get-op-case/here
%      (opcof/cons _ OC _)
%      OC'
%      <- subst2 OC Ep K OC'.

% % When the first case does not match, but there are more cases,
% % we continue as before.
% - : preservation-unhandled-op OinD' O Ep K
%      (get-op-case/there OC _)
%      (opcof/cons _ _ OCs)
%      C'
%      <- preservation-unhandled-op OinD' O Ep K OC OCs C'.

% % When there are no more cases, we propagate the operation call.
% - : preservation-unhandled-op OinD' O Ep K
%      get-op-case/nil
%      opcof/nil
%      (cof/op O Ep ([_] [x] cof/app K (eof/var x)) OinD').


% %worlds (topen) (preservation-unhandled-op _ _ _ _ _ _ _).
% %total {OC} (preservation-unhandled-op _ _ _ _ OC _ _).


apart-not-refl : apart O O -> {C} {B} cof C B -> type.
%mode apart-not-refl +O!O +C +B -CofB.

- : apart-not-refl (apart/ss O!O) C B CofB
     <- apart-not-refl O!O C B CofB.

%worlds (topen) (apart-not-refl _ _ _ _).
%total {O!O} (apart-not-refl O!O _ _ _).

apart-not-refl-eof : apart O O -> {C} {B} eof C B -> type.
%mode apart-not-refl-eof +O!O +C +B -CofB.

- : apart-not-refl-eof (apart/ss O!O) C B CofB
     <- apart-not-refl-eof O!O C B CofB.

%worlds (topen) (apart-not-refl-eof _ _ _ _).
%total {O!O} (apart-not-refl-eof O!O _ _ _).

% % Preservation in any case

preservation-with-op : sig D O A1 A2
                        -> eof Ep A1 -> eof K (A2 --> A' ! D')
                        -> get-op-case O OCs OC -> opcof OCs (A' ! D') D
                        -> cof (OC Ep K) (A' ! D') -> type.
%mode preservation-with-op +O +Ep +K +OC +OCs -OC.

- : preservation-with-op sig/here Ep K get-op-case/here (opcof/cons OC _) OC'
    <- subst2 OC Ep K OC'.

- : preservation-with-op (sig/there O _) Ep K (get-op-case/there OC _) (opcof/cons _ OCs) OC'
    <- preservation-with-op O Ep K OC OCs OC'.

- : preservation-with-op sig/here _ _ (get-op-case/there _ O!O) _ OC
     <- apart-not-refl O!O _ _ OC.

- : preservation-with-op (sig/there _ O!O) _ _ get-op-case/here _ OC
     <- apart-not-refl O!O _ _ OC.

%worlds (topen) (preservation-with-op _ _ _ _ _ _).
%total {O} (preservation-with-op O _ _ _ _ _).
