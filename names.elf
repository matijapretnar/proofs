%%%%% Entity names %%%%%

% We need a way of representing names of effects, operation symbols and instances.
% Furthermore, these names have to be equipped with a decidable equality.
% Ideally, we would prefer to *hypothesize* about this fact,
% but there is no legal way of doing this in Twelf.
%
% Instead, we represent names with natural numbers
% and implement the relevant decision procedures.
% We consider this to be a very clumsy solution,
% mainly because it exposes implementation details.

name : type.
%name name X.

name/z : name.
name/s : name -> name.


% We only have to define the apartness relation,
% because two names are equal only if they are identical.

apart-name : name -> name -> type.
%mode apart-name +X +Y.

apart-name/sz : apart-name (name/s _) name/z.
apart-name/zs : apart-name name/z (name/s _).
apart-name/ss : apart-name (name/s X) (name/s Y)
                 <- apart-name X Y.


% Two names are decidable if they are either equal or apart.

decidable-name : name -> name -> type.

decidable-name/equal : decidable-name X X.
decidable-name/apart : decidable-name X Y
                        <- apart-name X Y.


decidable-name/s : decidable-name X Y -> decidable-name (name/s X) (name/s Y) -> type.
%mode decidable-name/s +Dec -Dec'.

- : decidable-name/s decidable-name/equal decidable-name/equal.

- : decidable-name/s (decidable-name/apart A) (decidable-name/apart (apart-name/ss A)).

%worlds () (decidable-name/s _ _).
%total {} (decidable-name/s _ _).


% Any two names are decidable.

decide-name : {X} {Y} decidable-name X Y -> type.
%mode decide-name +X +Y -Dec.

- : decide-name name/z name/z decidable-name/equal.

- : decide-name name/z (name/s _) (decidable-name/apart apart-name/zs).

- : decide-name (name/s _) name/z (decidable-name/apart apart-name/sz).

- : decide-name (name/s X) (name/s Y) Dec'
     <- decide-name X Y Dec
     <- decidable-name/s Dec Dec'.

%worlds () (decide-name _ _ _).
%total {X Y} (decide-name X Y _).
